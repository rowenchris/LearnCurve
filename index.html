<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Interactive visualization of neural network learning. Watch a network learn to approximate any function in real-time.">
    <meta name="keywords" content="neural network, machine learning, deep learning, education, visualization, gradient descent">
    <title>LearnCurve - Interactive Neural Network Demo</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 16px;
            background: #f5f5f5;
            color: #333;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .container {
            max-width: 1700px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 10px 14px 14px 14px;
            min-height: calc(100vh - 20px);
            display: grid;
            grid-template-columns: 1fr 310px;
            gap: 16px;
            align-items: start;
        }

        #mainContent {
            grid-column: 1;
            grid-row: 1;
            min-width: 0;
        }
        
        #guideSidebar {
            grid-column: 2;
            grid-row: 1;
            position: sticky;
            top: 16px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }

        h1 {
            font-size: 22px;
            margin: 0 0 8px 0;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 10px;
            width: 100%;
            min-width: 0;
        }
        
        .controls-strip {
            grid-column: 1 / -1;
        }
        
        .viz-grid {
            display: contents;
        }

        .panel {
            background: #fafafa;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            min-width: 0;
            overflow: hidden;
        }

        .panel h2 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #444;
            border-bottom: 2px solid #007bff;
            padding-bottom: 3px;
        }

        .panel h3 {
            font-size: 14px;
            margin: 6px 0;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            font-size: 12px;
            min-width: 150px;
        }

        .control-group label {
            margin-bottom: 2px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 160px;
        }

        .control-group select,
        .control-group input[type="text"] {
            font-size: 13px;
            padding: 2px 4px;
        }

        .value {
            font-size: 11px;
            color: #777;
        }

        button {
            padding: 5px 9px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        #networkCanvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 10px auto;
            max-width: 100%;
            height: auto;
        }

        canvas.chart {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
            touch-action: manipulation;  /* Better touch handling on mobile */
        }
        
        canvas {
            touch-action: manipulation;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
        }

        .stat-value {
            font-size: 13px;
            font-weight: bold;
        }

        .activation-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .activation-option {
            font-size: 11px;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid #ccc;
            cursor: pointer;
            background: #fff;
        }

        .activation-option.selected {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .equations-panel {
            grid-column: 1 / -1;  /* Span all columns */
            flex: 1;  /* Fill remaining height */
            display: flex;
            flex-direction: column;
        }
        
        .equations-panel h2 {
            margin-bottom: 4px;
            flex-shrink: 0;
        }
        
        .equations {
            font-size: 11px;
            line-height: 1.3;
            flex: 1;
            min-height: 150px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;  /* 2 columns: Forward | Backward */
            gap: 12px;
        }

        .equation-block {
            padding: 4px 6px;
        }

        .equation-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .math {
            font-family: "Courier New", monospace;
            color: #333;
            font-size: 13px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #777;
            margin-bottom: 2px;
        }

        /* Tablet and smaller - single column layout */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
                max-width: 100%;
                grid-template-columns: 1fr 220px;
            }
            #guideSidebar {
                font-size: 9px;
                width: 220px;
            }
            .grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
            }
            .control-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .control-group {
                flex-wrap: wrap;
            }
            .equations-panel {
                grid-column: 1;  /* Single column on mobile */
            }
            .equations {
                grid-template-columns: 1fr 1fr;  /* 2 columns on tablet */
                font-size: 12px;
                max-height: 220px;
            }
        }
        
        /* Tablet portrait - sidebar moves to bottom */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
            }
            #mainContent {
                grid-row: 1;
            }
            #guideSidebar {
                grid-column: 1;
                grid-row: 2;
                width: 100%;
                max-width: 100%;
                max-height: none;
                position: static;
                margin-top: 16px;
                font-size: 11px;
            }
            #guideSidebar h3 {
                font-size: 15px;
            }
            #guideSidebar h4 {
                font-size: 13px;
            }
            #guideToggle {
                display: none;
            }
            /* Phase panel controls should stack */
            #phase1Panel > div, #phase2Panel > div {
                flex-wrap: wrap;
            }
            /* Smaller fonts for cramped controls */
            #phase1Panel, #phase2Panel, #phase3Panel {
                font-size: 11px;
            }
            #phase1Panel label, #phase2Panel label {
                font-size: 10px;
            }
        }
        
        /* iPhone and small mobile */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                max-width: 100%;
                overflow-x: hidden;
                grid-template-columns: 1fr;
            }
            #guideSidebar {
                font-size: 10px;
                padding: 10px;
                max-height: none;
            }
            #guideSidebar h3 {
                font-size: 14px;
            }
            #guideSidebar h4 {
                font-size: 12px;
            }
            h1 {
                font-size: 18px;
            }
            .subtitle {
                font-size: 11px;
                line-height: 1.4;
            }
            .panel {
                padding: 8px;
                overflow-x: auto;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
                height: auto;
            }
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
            }
            .control-group input[type="range"] {
                width: 100%;
            }
            .control-group select {
                width: 100%;
            }
            .stats {
                flex-direction: column;
                gap: 4px;
                align-items: flex-start;
            }
            button {
                padding: 8px 12px;
                font-size: 13px;
            }
            .chart-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            .checkbox-group {
                font-size: 12px;
            }
            .equations {
                grid-template-columns: 1fr;  /* Single column on small screens */
                font-size: 11px;
                max-height: 250px;
            }
            /* Hide drag handles on mobile - they don't work well with touch */
            #sizeHandle, #layersHandle, #trainMinHandle, #trainMaxHandle, #traceViewHandle {
                display: none !important;
            }
            /* Show mobile control containers */
            .mobile-sliders {
                display: flex !important;
                flex-wrap: wrap;
                gap: 8px;
                padding: 6px 8px;
                background: #f0f4f8;
                border-radius: 4px;
            }
            /* Hide desktop-only train range controls header inputs on mobile */
            #trainRangeControls {
                display: none !important;
            }
            /* Make activation buttons stack */
            #networkActivation {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            #networkActivation > div {
                flex-wrap: wrap;
            }
        }
    </style>
    <!-- GIF library for capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body>
<div class="container">
    <!-- Main Content Area -->
    <div id="mainContent" style="display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:6px;">
            <div>
                <h1 style="margin-bottom:2px;">LearnCurve</h1>
                <p style="margin:0; font-size:11px; color:#666;">An interactive tool for understanding how neural networks learn. ¬© 2025 Chris Rowen ‚Äî <a href="https://opensource.org/licenses/MIT" style="color:#007bff; text-decoration:none;">MIT License</a></p>
            </div>
            <button id="guideToggle" style="padding:4px 10px; font-size:11px; background:#138496; border:none; border-radius:4px; color:white; cursor:pointer; white-space:nowrap;" title="Show/hide learning guide">Hide Guide ‚óÄ</button>
        </div>

        <div class="grid">
        <!-- PHASE 1: CREATE TRAINING DATA - spans full width -->
        <div class="panel controls-strip" id="phase1Panel" style="padding:8px 12px; border-left:4px solid #28a745;">
            <div id="phase1Header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div style="display:flex; align-items:center; gap:8px;">
                    <span style="font-size:12px; font-weight:bold; color:#28a745;">‚ë† CREATE TRAINING DATA</span>
                    <button id="toggleRecipeBtn" style="padding:4px 12px; font-size:11px; background:#28a745; font-weight:bold; display:none;" title="Edit data recipe and regenerate">‚úèÔ∏è Edit Recipe</button>
                </div>
                <span id="dataStatus" style="font-size:10px; color:#555;">Define a data recipe, then generate training data</span>
            </div>
            
            <!-- Recipe Controls - single row -->
            <div id="recipeControls" style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:5px 8px; background:#f8f9fa; border-radius:4px;">
                <!-- Data Recipe -->
                <div style="display:flex; align-items:center; gap:4px;">
                    <label style="font-size:11px; font-weight:600;">Recipe:</label>
                    <input type="text" id="targetFuncInput" value="sin(x)" style="width:90px; font-size:11px; padding:3px 5px;" title="Formula for generating data" />
                </div>
                
                <!-- Data Range -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">x:</label>
                    <input type="number" id="dataXMinInput" value="-3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                    <span style="font-size:9px;">to</span>
                    <input type="number" id="dataXMaxInput" value="3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                </div>
                
                <!-- Count -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Total number of data points to generate">Samples:</label>
                    <input type="range" id="totalSamples" min="20" max="500" step="10" value="100" style="width:80px;">
                    <span class="value" id="totalSamplesValue" style="font-size:10px; min-width:24px;">100</span>
                </div>
                
                <!-- Noise -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Noise level - random variation added to y values">Noise:</label>
                    <input type="range" id="noise" min="0" max="1" step="0.01" value="0.02" style="width:80px;">
                    <span class="value" id="noiseValue" style="font-size:10px; min-width:24px;">0.02</span>
                </div>
                
                <!-- Generate Button -->
                <button id="generateDataBtn" style="padding:5px 12px; font-size:11px; background:#28a745; font-weight:bold;">üé≤ Generate</button>
            </div>
            
            <!-- Data Summary (accordion, collapsed by default after generation) -->
            <div id="dataSummary" style="display:none; background:#f0f8f0; border:1px solid #c3e6c3; border-radius:4px;">
                <!-- Summary header (always visible) -->
                <div id="dataSummaryHeader" style="display:flex; align-items:center; gap:8px; padding:4px 10px; cursor:pointer;" title="Click to show/hide data preview">
                    <span id="dataSummaryToggle" style="font-size:10px; color:#28a745;">‚ñ∂</span>
                    <span style="font-size:10px; color:#28a745; font-weight:bold;">‚úì Data Ready:</span>
                    <span style="font-size:10px; color:#333;"><span id="trainCount">80</span> training, <span id="testCount">20</span> held-out</span>
                    <span id="dataSummaryNote" style="flex:1; font-size:10px; color:#444; font-style:italic;"></span>
                    <button id="newDataBtn" style="padding:2px 6px; font-size:9px; background:#6c757d;" title="Generate new random data">‚Üª New</button>
                </div>
                <!-- Expandable data preview -->
                <div id="dataSummaryContent" style="display:none; padding:4px 10px 6px 10px; border-top:1px solid #c3e6c3;">
                    <div style="display:flex; align-items:flex-start; gap:12px;">
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#007bff; margin-bottom:2px;">üìä Training Points</div>
                            <div id="trainDataPreview" style="font-size:9px; font-family:monospace; color:#333; background:#fff; padding:2px 4px; border-radius:2px; border:1px solid #ddd; line-height:1.3;"></div>
                        </div>
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#ff9800; margin-bottom:2px;">üîí Held-Out Points</div>
                            <div id="testDataPreview" style="font-size:9px; font-family:monospace; color:#666; background:#fafafa; padding:2px 4px; border-radius:2px; border:1px solid #eee; line-height:1.3;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Hidden elements for compatibility -->
            <span id="trainRangeLabel" style="display:none;"></span>
            <span id="testRangeInfo" style="display:none;"></span>
        </div>
        
        <!-- PHASE 2: TRAIN THE MODEL - spans full width -->
        <div class="panel controls-strip" id="phase2Panel" style="padding:6px 12px; border-left:4px solid #007bff; opacity:0.5; pointer-events:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <span style="font-size:12px; font-weight:bold; color:#007bff;">‚ë° TRAIN THE MODEL</span>
                <span id="epochStatus" style="font-size:10px; color:#555;">Generate examples first...</span>
            </div>
            <!-- Row 1: Network and training parameters -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:4px;">
                <!-- Learning Rate -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Learning Rate:</label>
                    <input type="range" id="learningRate" min="-3" max="-0.3" step="0.01" value="-1" style="width:50px;">
                    <span class="value" id="learningRateValue" style="font-size:10px; min-width:32px;">0.100</span>
                </div>
                
                <!-- Optimizer -->
                <div id="optimizerButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Optimizer:</label>
                    <button class="opt-btn" data-opt="sgd" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer;" title="Simple Gradient Descent&#10;&#10;w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇL/‚àÇw&#10;&#10;Each weight moves opposite to its gradient, proportional to learning rate Œ∑.&#10;&#10;Recommended learning rate: 0.05-0.2&#10;Simple but can be slow or oscillate.">Simple</button>
                    <button class="opt-btn" data-opt="adam" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer;" title="Adam Optimizer&#10;&#10;Combines two ideas:&#10;‚Ä¢ Momentum: smooth out noisy gradients&#10;‚Ä¢ Adaptive rates: bigger steps for rare gradients&#10;&#10;Recommended learning rate: 0.001-0.02&#10;(Lower than Simple because Adam amplifies updates)&#10;&#10;Usually learns faster and more reliably.">Adam</button>
                </div>
                
                <!-- Activation -->
                <div id="activationButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Activation:</label>
                    <button class="act-btn" data-act="relu" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="14" height="10" viewBox="0 0 20 14"><path d="M1 10 L10 10 L19 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>ReLU
                    </button>
                    <button class="act-btn" data-act="sigmoid" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="16" height="10" viewBox="0 0 24 14"><path d="M1 12 L4 12 Q8 12 12 7 Q16 2 20 2 L23 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>Sigmoid
                    </button>
                </div>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Stats -->
                <span style="font-size:11px; color:#28a745;">Train Loss: <strong id="trainLossValue">‚Äî</strong></span>
                <span style="font-size:11px; color:#007bff;"><span id="stepsPerSec">‚Äî</span> steps/second</span>
                <span style="font-size:10px; color:#555;" title="Total arithmetic operations this training run (shows cost of training)">Total: <strong id="totalOpsDisplay" style="color:#6f42c1;">0</strong> ops</span>
            </div>
            <!-- Hidden elements for backwards compatibility -->
            <span id="epochCount" style="display:none;">0</span>
            <span id="stepCount" style="display:none;">0</span>
            <span id="stepsPerEpoch" style="display:none;">80</span>
            
            <!-- Row 2: Training action buttons -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <!-- Training buttons -->
                <button id="stepBtn" style="padding:4px 10px; font-size:11px;" title="Train one step (process one training example)">Step</button>
                <button id="runEpochBtn" style="padding:4px 10px; font-size:11px; background:#17a2b8;" title="Run one epoch = process ALL training examples once">Run Epoch</button>
                <button id="runBtn" style="padding:4px 10px; font-size:11px;" title="Run continuous training until stopped">Run</button>
                <button id="resetModelBtn" style="padding:4px 10px; font-size:11px; background:#ffc107; color:#333;" title="Re-initialize weights randomly (keeps data)">Reset Model</button>
                <button id="gifBtn" style="padding:4px 8px; font-size:10px;">Capture</button>
            </div>
            
            <!-- Hidden elements for backwards compatibility -->
            <input type="range" id="xMin" min="-5" max="0" step="0.1" value="-2" style="display:none;">
            <input type="range" id="xMax" min="0" max="5" step="0.1" value="2" style="display:none;">
            <span id="xMinLabel" style="display:none;">-2</span>
            <span id="xMaxLabel" style="display:none;">2</span>
            <span id="runALabel" style="display:none;"></span>
            <span id="runBLabel" style="display:none;"></span>
            <span id="totalAdds" style="display:none;">0</span>
            <span id="totalMuls" style="display:none;">0</span>
            <span id="opsLossAdd" style="display:none">0</span>
            <span id="opsLossMul" style="display:none">0</span>
            <span id="lossValue" style="display:none;">‚Äî</span>
            <button id="resetBtn" style="display:none;">Reset</button>
            <div class="activation-selector" id="activationSelector" style="display:none;">
                <span class="activation-option selected" data-act="relu">ReLU</span>
                <span class="activation-option" data-act="sigmoid">sigmoid</span>
            </div>
            <span id="numLayersValue" style="display:none;">1</span>
            <span id="hiddenSizeValue" style="display:none;">3</span>
        </div>

        <!-- 2x2 VISUALIZATION GRID -->
        <!-- Top Left: Network Design -->
        <div class="panel" style="padding:6px 6px 24px 6px; overflow:visible !important;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Network Design</h2>
                <div id="opsTableHtml" style="font-size:10px; background:#f8f9ff; border:1px solid #007bff; border-radius:3px; padding:2px 6px;">
                    <span style="color:#28a745;">Fwd:</span><span id="opsFwdAdds">0</span>+ <span id="opsFwdMuls">0</span>√ó
                    <span style="color:#dc3545; margin-left:4px;">Back:</span><span id="opsBackAdds">0</span>+ <span id="opsBackMuls">0</span>√ó
                </div>
            </div>
            <div style="position:relative; margin-bottom:8px; margin-right:20px;">
                <canvas id="networkCanvas" width="520" height="300" style="width:100%;"></canvas>
                <div id="sizeHandle" style="position:absolute; right:-22px; top:50%; transform:translateY(-50%); width:22px; height:55px; background:linear-gradient(to bottom, #007bff, #0056b3); border-radius:3px; cursor:ns-resize; display:flex; flex-direction:column; align-items:center; justify-content:space-evenly; color:white; font-size:9px; transition: transform 0.15s ease-out; z-index:10;" title="Drag to change neurons per layer"><span>‚ñ≤</span><span style="writing-mode:vertical-rl; text-orientation:mixed; font-size:9px;">Width</span><span>‚ñº</span></div>
            </div>
            <div style="text-align:center;">
                <div id="layersHandle" style="display:inline-flex; height:18px; width:76px; background:linear-gradient(to right, #007bff, #0056b3); border-radius:3px; cursor:ew-resize; align-items:center; justify-content:center; color:white; font-size:9px; transition: transform 0.15s ease-out;" title="Drag to change number of layers">‚óÄ Layers ‚ñ∂</div>
            </div>
            <!-- Mobile controls (shown via CSS on small screens) -->
            <div id="networkMobileControls" class="mobile-sliders" style="display:none; margin-top:8px;">
                <div style="display:flex; align-items:center; gap:6px;">
                    <label style="font-size:11px; min-width:45px;">Layers:</label>
                    <input type="range" id="numLayers" min="1" max="4" step="1" value="1" style="width:80px;">
                    <span id="numLayersDisplay" style="font-size:11px; min-width:16px;">1</span>
                </div>
                <div style="display:flex; align-items:center; gap:6px;">
                    <label style="font-size:11px; min-width:45px;">Width:</label>
                    <input type="range" id="hiddenSize" min="2" max="16" step="1" value="3" style="width:80px;">
                    <span id="hiddenSizeDisplay" style="font-size:11px; min-width:16px;">3</span>
                </div>
            </div>
            <span id="networkLayersDisplay" style="display:none;">1</span>
            <span id="networkSizeDisplay" style="display:none;">3</span>
            <div id="networkActivation" style="display:none;"></div>
        </div>

        <!-- Top Right: Fit Plot -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Examples vs Model</h2>
                <div id="trainRangeControls" style="display:flex; gap:6px; font-size:10px; align-items:center; opacity:0.5; pointer-events:none;">
                    <label style="color:#17a2b8; font-weight:bold;" title="Restrict which x-values are used for training. Points outside this range test extrapolation.">Train x:</label>
                    <input type="number" id="trainXMinInput" value="-2" step="0.5" style="width:40px; font-size:10px; padding:2px; border:1px solid #17a2b8;" title="Min x for training">
                    <span style="font-size:10px;">to</span>
                    <input type="number" id="trainXMaxInput" value="2" step="0.5" style="width:40px; font-size:10px; padding:2px; border:1px solid #17a2b8;" title="Max x for training">
                </div>
                <span id="trainPointCount" style="display:none;">‚Äî</span>
                <div id="revealControls" style="display:flex; gap:6px; font-size:10px; opacity:0.5; pointer-events:none;">
                    <label style="display:flex; align-items:center; gap:2px; cursor:pointer;" title="Show held-out examples">
                        <input type="checkbox" id="showHeldOut"> Held-Out
                    </label>
                    <label style="display:flex; align-items:center; gap:2px; cursor:pointer;" title="Show original recipe curve">
                        <input type="checkbox" id="showRecipe"> Recipe
                    </label>
                </div>
            </div>
            <div style="position:relative;">
                <canvas id="fitCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
                <div id="trainMinHandle" style="position:absolute; left:50px; bottom:2px; width:24px; height:12px; background:#17a2b8; border-radius:2px; cursor:ew-resize; display:flex; align-items:center; justify-content:center; color:white; font-size:7px; opacity:0.5; pointer-events:none;" title="Drag to restrict training range (test extrapolation)">‚óÄ‚ñ∂</div>
                <div id="trainMaxHandle" style="position:absolute; right:50px; bottom:2px; width:24px; height:12px; background:#17a2b8; border-radius:2px; cursor:ew-resize; display:flex; align-items:center; justify-content:center; color:white; font-size:7px; opacity:0.5; pointer-events:none;" title="Drag to restrict training range (test extrapolation)">‚óÄ‚ñ∂</div>
            </div>
            <span id="xMinDisplay" style="display:none;">-2.0</span>
            <span id="xMaxDisplay" style="display:none;">2.0</span>
            <!-- Mobile training range controls -->
            <div id="trainRangeMobileControls" class="mobile-sliders" style="display:none; margin-top:4px;">
                <div style="display:flex; align-items:center; gap:4px; flex-wrap:wrap;">
                    <label style="font-size:10px; color:#17a2b8; font-weight:bold;">Train Range:</label>
                    <input type="number" id="trainXMinMobile" step="0.5" style="width:50px; font-size:11px; padding:2px;">
                    <span style="font-size:10px;">to</span>
                    <input type="number" id="trainXMaxMobile" step="0.5" style="width:50px; font-size:11px; padding:2px;">
                    <button id="applyTrainRangeMobile" style="font-size:10px; padding:2px 6px;">Apply</button>
                </div>
            </div>
        </div>

        <!-- Bottom Left: Training Trace -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:3px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Training Trace</h2>
                <div style="display:flex; gap:5px; font-size:10px; align-items:center; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:1px;" title="Show loss curve"><input type="checkbox" id="traceLoss" checked>Loss</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Show weight trajectories"><input type="checkbox" id="traceWeights" checked>Weights</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Logarithmic scale"><input type="checkbox" id="traceLogScale">Log</label>
                    <span style="color:#ddd;">|</span>
                    <label style="display:flex; align-items:center; gap:1px;" title="Rolling average loss"><input type="checkbox" id="traceAvgLoss" checked>Average</label>
                    <input type="range" id="avgWindowSlider" min="10" max="1000" step="10" value="100" style="width:35px;" title="Averaging window size"><span id="avgWindowValue" style="color:#007bff; min-width:22px;">100</span>
                    <span style="color:#ddd;">|</span>
                    <span style="white-space:nowrap;" title="Loss change from start to now">ŒîLoss:<strong id="deltaLossValue" style="color:#28a745; min-width:45px;">‚Äî</strong></span>
                </div>
            </div>
            <div style="position:relative;">
                <canvas id="traceCanvas" class="chart" width="520" height="360" style="width:100%;"></canvas>
                <div id="traceViewHandle" style="position:absolute; bottom:4px; left:230px; width:66px; height:16px; background:linear-gradient(to right, #007bff, #0056b3); border-radius:3px; cursor:ew-resize; display:none; align-items:center; justify-content:center; color:white; font-size:9px; opacity:0.9; z-index:10;" title="Drag left/right to zoom into early training steps (when paused)">‚óÄ Zoom ‚ñ∂</div>
            </div>
            <!-- Mobile zoom control -->
            <div id="zoomMobileControls" class="mobile-sliders" style="display:none; margin-top:4px;">
                <div style="display:flex; align-items:center; gap:6px;">
                    <label style="font-size:10px;">Zoom (show first N steps):</label>
                    <input type="range" id="zoomSliderMobile" min="50" max="5000" step="50" value="5000" style="width:100px;">
                    <span id="zoomValueMobile" style="font-size:10px; min-width:40px;">All</span>
                </div>
            </div>
        </div>

        <!-- Bottom Right: Loss Landscape -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Loss Landscape</h2>
                <div style="display:flex; gap:3px; font-size:10px; align-items:center;">
                    <span id="weightSelectContainer" style="display:flex; gap:2px; align-items:center; opacity:0.5;" title="Click to manually select weights">
                        <select id="weightXSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="0">w‚ÇÅ</option></select>
                        <span style="font-size:9px;">vs</span>
                        <select id="weightYSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="1">w‚ÇÇ</option></select>
                    </span>
                    <button id="autoSelectBtn" style="font-size:10px; padding:1px 4px; background:#007bff; border:2px solid #007bff; color:white;" title="Auto-select interesting weights">Auto</button>
                </div>
            </div>
            <canvas id="lossCanvas" class="chart" width="520" height="360"></canvas>
            <div style="font-size:9px; color:#555; text-align:center; margin-top:2px;">üü¢ Start üî¥ Current ‚Ä¢ <span style="color:#00f;">‚ñ†</span>‚â§.001 <span style="color:#0aa;">‚ñ†</span>.01 <span style="color:#0a0;">‚ñ†</span>.1 <span style="color:#aa0;">‚ñ†</span>1 <span style="color:#f00;">‚ñ†</span>‚â•10</div>
        </div>
    </div>
    
    <!-- STEP 3: EVALUATE - spans full width -->
    <div class="panel controls-strip" id="phase3Panel" style="padding:6px 12px; border-left:4px solid #ff9800; opacity:0.5; pointer-events:none; margin-top:10px;">
        <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
            <span style="font-size:12px; font-weight:bold; color:#ff9800;">‚ë¢ EVALUATE & COMPARE</span>
            
            <button id="evaluateBtn" style="padding:5px 14px; font-size:11px; background:#ff9800; font-weight:bold;" title="Test model on held-out data to measure generalization">üîç Evaluate on Held-Out</button>
            
            <span id="evalResults" style="font-size:10px; color:#555; display:none;"></span>
            
            <span style="color:#ddd;">|</span>
            
            <button id="saveRunA" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run A</button>
            <button id="saveRunB" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run B</button>
            <button id="compareBtn" style="padding:4px 10px; font-size:10px; background:#6c757d;" disabled>Compare A vs B</button>
        </div>
    </div>
    
    <!-- THE MATH - spans full width, collapsible -->
    <div class="panel equations-panel" style="padding:6px 10px; margin-top:10px;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="equationsHeader">
            <h2 style="margin:0; font-size:13px; border:none; padding:0;">üìê Equations</h2>
            <button id="toggleEquationsBtn" style="padding:2px 8px; font-size:10px; background:#6c757d;">‚ñº Collapse</button>
        </div>
        <div class="equations" id="equationsDiv" style="margin-top:6px;"></div>
    </div>
    </div><!-- end main content -->
    
    <!-- Learning Guide Sidebar -->
    <div id="guideSidebar" style="background:#f8f9fa; border:1px solid #dee2e6; border-radius:6px; padding:12px 14px;">
        <div style="margin-bottom:8px; border-bottom:2px solid #17a2b8; padding-bottom:4px;">
            <span style="font-size:16px; font-weight:bold; color:#17a2b8;">üìñ How Neural Networks Learn</span>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Big Picture</h4>
        <p style="margin:0 0 6px 0;">We use <strong>machine learning</strong> to build equations that serve as <strong>predictive models</strong>‚Äîestimating the next word in a composition or identifying objects in a picture. You have <strong>data</strong> representing typical inputs and desired outputs, but don't know the <strong>pattern</strong>. A <strong>neural network</strong> finds a <strong>function that fits</strong> the data‚Äîlike recreating a curve from scattered dots, but for arbitrarily complex functions.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Three Phases</h4>
        <p style="margin:0 0 3px 0;"><span style="color:#28a745; font-weight:bold;">‚ë†</span> <strong>Create Data</strong> ‚Äî Generate examples from a hidden "recipe."</p>
        <p style="margin:0 0 3px 0;"><span style="color:#007bff; font-weight:bold;">‚ë°</span> <strong>Train</strong> ‚Äî Measure error, adjust parameters, repeat.</p>
        <p style="margin:0 0 6px 0;"><span style="color:#6f42c1; font-weight:bold;">‚ë¢</span> <strong>Evaluate</strong> ‚Äî Test on held-out data to verify learning.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Key Terms</h4>
        <div style="font-size:12px; line-height:1.4;">
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Data Recipe</strong> ‚Äî Function that generates data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Training Data</strong> ‚Äî Examples the model learns from</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Held-Out Data</strong> ‚Äî Reserved to test real learning</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Noise</strong> ‚Äî Random variation (real data is messy)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Step</strong> ‚Äî Update from one example</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Epoch</strong> ‚Äî Full pass through training data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Loss</strong> ‚Äî Model error (lower = better)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Learning Rate</strong> ‚Äî Step size for parameter updates</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Optimizer</strong> ‚Äî Weight update algorithm</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Weights</strong> ‚Äî Multipliers on connections</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Biases</strong> ‚Äî Offset added at each neuron</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Gradient</strong> ‚Äî Steepest uphill direction</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#dc3545;">Overfitting</strong> ‚Äî Memorizing instead of learning</p>
            <p style="margin:0 0 6px 0;"><strong style="color:#dc3545;">Extrapolation</strong> ‚Äî Predicting outside training range</p>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Math</h4>
        <p style="margin:0 0 3px 0;"><strong>Forward:</strong> Each layer: weighted sum ‚Üí activation ‚Üí output.</p>
        <p style="margin:0 0 3px 0;"><strong>Loss:</strong> ¬Ω(predicted ‚àí actual)¬≤ penalizes big errors.</p>
        <p style="margin:0 0 3px 0;"><strong>Backward:</strong> Trace error via <em>chain rule</em> to find each weight's effect.</p>
        <p style="margin:0 0 3px 0; font-size:11px; color:#666; font-style:italic; padding-left:6px;">d[f(g(x))]/dx = f'(g(x)) ¬∑ g'(x)</p>
        <p style="margin:0 0 6px 0;"><strong>Update:</strong> Step opposite to gradient (downhill).</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Optimizers</h4>
        <p style="margin:0 0 3px 0;"><strong>Simple (SGD)</strong> ‚Äî Basic: weight -= rate √ó gradient</p>
        <p style="margin:0 0 6px 0;"><strong>Adam</strong> ‚Äî Adapts rate per-weight. Usually faster.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Try These</h4>
        <p style="margin:0 0 2px 0;">üìà <strong>Simple:</strong> <code>x</code>, <code>x^2</code>, <code>x^3-3*x</code></p>
        <p style="margin:0 0 2px 0;">üåä <strong>Waves:</strong> <code>sin(x)</code>, <code>sin(x)+sin(3*x)</code></p>
        <p style="margin:0 0 2px 0;">üìê <strong>Sharp:</strong> <code>abs(x)</code>, <code>sign(x)</code>, <code>floor(x)</code></p>
        <p style="margin:0 0 2px 0;">üî¨ Restrict training range ‚Üí extrapolation fails</p>
        <p style="margin:0 0 2px 0;">‚ö° Compare SGD vs Adam</p>
        <p style="margin:0;">üìä Increase noise ‚Üí learning breaks down</p>
        
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid #ddd; font-size:12px; color:#888; text-align:center;">
            üí° <em>ML = adjusting numbers to minimize error!</em>
        </div>
    </div>
</div><!-- end container -->

<script>
    // ---------------- Config & State ----------------

    let config = {
        learningRate: 0.1,
        activation: 'relu',
        // Data generation range (full range)
        dataXMin: -3,
        dataXMax: 3,
        // Training range (can be subset of data range)
        trainXMin: -2,
        trainXMax: 2,
        // Legacy compatibility
        xMin: -3,
        xMax: 3,
        noise: 0.02,
        targetFunc: null,
        targetFuncStr: 'sin(x)',
        optimizer: 'sgd',
        avgWindow: 100,
        // Dataset configuration
        totalSamples: 100,      // Total number of samples to generate
        trainTestSplit: 0.8,    // 80% train, 20% test
        testEvalInterval: 10    // Legacy - test loss now evaluated at epoch boundaries
    };

    // Training dataset - fixed points generated from target function
    let dataset = {
        generated: false,       // Has data been generated?
        allTrain: [],           // All training points (full data range)
        allTest: [],            // All test points (full data range)
        train: [],              // Training points within trainXMin..trainXMax
        test: [],               // Test points (all held-out, for evaluation)
        epoch: 0,               // Current epoch number
        stepInEpoch: 0,         // Current step within epoch
        shuffleOrder: [],       // Randomized order for current epoch
        totalEpochs: 0          // Total epochs completed
    };
    
    // Reveal controls for assessment
    let revealOptions = {
        showHeldOut: false,     // Show held-out (test) examples
        showRecipe: false,      // Show original data recipe curve
        evaluated: false        // Has evaluation been run?
    };
    
    // Evaluation results
    let evaluationResults = {
        testLossInRange: null,    // MSE for test points within training range
        testLossOutRange: null,   // MSE for test points outside training range
        testLossTotal: null,      // Total test MSE
        pointsInRange: 0,
        pointsOutRange: 0
    };

    let network = {
        numLayers: 1,
        hiddenSize: 3,
        weights: [],
        biases: []
    };

    let grads = {
        weights: [],
        biases: []
    };

    let history = {
        steps: [],
        loss: [],           // Training loss per step
        testLoss: [],       // Test loss evaluated periodically [{step, loss}, ...]
        avgLoss: [],
        weights: []
    };

    let trainingState = {
        running: false,
        animating: false,
        step: 0,
        totalAdds: 0,
        totalMuls: 0,
        lastUpdateTime: performance.now(),
        stepsSinceLastUpdate: 0,
        recentSamples: []
    };
    
    // Training trace view control - null means show all, otherwise show steps 0 to this value
    let traceViewEndStep = null;

    let gifCapture = {
        recording: false,
        gif: null,
        framesRemaining: 0
    };

    let optimizerState = {
        m: [],
        v: [],
        r: [],
        t: 0
    };

    let savedRuns = {
        A: null,
        B: null
    };

    let comparisonModeActive = false;

    function exitComparisonMode() {
        if (!comparisonModeActive) return;
        comparisonModeActive = false;
        const compareBtn = document.getElementById('compareBtn');
        if (compareBtn && savedRuns.A && savedRuns.B) {
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
            compareBtn.textContent = 'Compare A vs B';
        }
    }

    const activationFns = {
        relu: {
            fn: (z) => Math.max(0, z),
            dfn: (z) => z > 0 ? 1 : 0
        },
        tanh: {
            fn: (z) => Math.tanh(z),
            dfn: (z) => {
                const t = Math.tanh(z);
                return 1 - t * t;
            }
        },
        sigmoid: {
            fn: (z) => 1 / (1 + Math.exp(-z)),
            dfn: (z) => {
                const s = 1 / (1 + Math.exp(-z));
                return s * (1 - s);
            }
        }
    };

    // --------------- Utility Functions ---------------
    
    // Fix fuzzy text on HiDPI displays
    function setupHiDPICanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return ctx;
    }

    function gaussianNoise(mean=0, std=1) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const n = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + std * n;
    }
    
    // Generate nice round tick values for axes
    function getNiceTicks(min, max, targetCount = 5) {
        const range = max - min;
        if (range <= 0) return [min];
        
        // Find a nice step size
        const roughStep = range / targetCount;
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const normalized = roughStep / magnitude;
        
        let niceStep;
        if (normalized <= 1) niceStep = magnitude;
        else if (normalized <= 2) niceStep = 2 * magnitude;
        else if (normalized <= 5) niceStep = 5 * magnitude;
        else niceStep = 10 * magnitude;
        
        // Generate ticks
        const ticks = [];
        const start = Math.ceil(min / niceStep) * niceStep;
        for (let tick = start; tick <= max; tick += niceStep) {
            ticks.push(tick);
        }
        
        // Ensure we have at least start and end
        if (ticks.length === 0 || ticks[0] > min) ticks.unshift(Math.floor(min / niceStep) * niceStep);
        if (ticks[ticks.length - 1] < max) ticks.push(Math.ceil(max / niceStep) * niceStep);
        
        return ticks;
    }
    
    // Generate nice tick values for log scale (powers of 10)
    function getLogTicks(logMin, logMax) {
        const ticks = [];
        const startPow = Math.floor(logMin);
        const endPow = Math.ceil(logMax);
        
        for (let p = startPow; p <= endPow; p++) {
            if (p >= logMin && p <= logMax) {
                ticks.push(p);
            }
        }
        
        // If range is very small, add intermediate ticks
        if (ticks.length < 3 && (logMax - logMin) < 2) {
            const midTicks = [];
            for (let p = startPow; p <= endPow; p++) {
                midTicks.push(p);
                // Add 0.5 log step (sqrt(10) ‚âà 3.16x)
                if (p + 0.5 <= logMax && p + 0.5 >= logMin) {
                    midTicks.push(p + 0.5);
                }
            }
            return midTicks.filter(t => t >= logMin && t <= logMax);
        }
        
        return ticks;
    }

    function createCompositeCanvas() {
        // Get all three canvases
        const networkCanvas = document.getElementById('networkCanvas');
        const fitCanvas = document.getElementById('fitCanvas');
        const traceCanvas = document.getElementById('traceCanvas');
        
        // Create composite canvas: network on left, fit and trace stacked on right
        const padding = 10;
        const leftWidth = networkCanvas.width;
        const rightWidth = Math.max(fitCanvas.width, traceCanvas.width);
        const totalWidth = leftWidth + rightWidth + padding * 3;
        const totalHeight = Math.max(networkCanvas.height, fitCanvas.height + traceCanvas.height + padding) + padding * 2;
        
        const composite = document.createElement('canvas');
        composite.width = totalWidth;
        composite.height = totalHeight;
        const ctx = composite.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, totalWidth, totalHeight);
        
        // Draw network canvas (left side)
        ctx.drawImage(networkCanvas, padding, padding);
        
        // Draw fit canvas (top right)
        ctx.drawImage(fitCanvas, leftWidth + padding * 2, padding);
        
        // Draw trace canvas (bottom right)
        ctx.drawImage(traceCanvas, leftWidth + padding * 2, fitCanvas.height + padding * 2);
        
        // Add title
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Network', padding, padding - 2);
        ctx.fillText('Fit: f(x) vs ≈∑(x)', leftWidth + padding * 2, padding - 2);
        ctx.fillText('Training Trace', leftWidth + padding * 2, fitCanvas.height + padding * 2 - 2);
        
        return composite;
    }
    
    // Check if GIF capture with workers is available
    function canUseGifWorkers() {
        // Workers don't work from file:// protocol
        return window.location.protocol !== 'file:';
    }
    
    // Fallback: capture a single screenshot as PNG
    function captureScreenshot() {
        const composite = createCompositeCanvas();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        
        composite.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `learncurve_${timestamp}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }
    
    // Adaptive GIF capture - scans training to find interesting convergence region
    function startGifCapture() {
        if (gifCapture.recording) return;
        
        // Check if we can use web workers (required for GIF.js)
        if (!canUseGifWorkers()) {
            const useScreenshot = confirm(
                'Animated GIF capture requires running from a web server.\n\n' +
                'Options:\n' +
                '‚Ä¢ Click OK to download a PNG screenshot instead\n' +
                '‚Ä¢ Click Cancel, then run: python3 -m http.server 8000\n' +
                '  and open http://localhost:8000/index.html for GIF capture'
            );
            if (useScreenshot) {
                captureScreenshot();
            }
            return;
        }
        
        
        trainingState.running = false;
        document.getElementById('runBtn').textContent = 'Run';
        
        // Show status
        const gifBtn = document.getElementById('gifBtn');
        const originalText = gifBtn.textContent;
        gifBtn.textContent = 'Scanning...';
        gifBtn.disabled = true;
        
        // Phase 1: Scan training to find convergence
        setTimeout(() => {
            const scanResult = scanForConvergence();
            gifBtn.textContent = 'Recording...';
            
            // Phase 2: Reset and record with adaptive keyframes
            reset();
            
            setTimeout(() => {
                startAdaptiveCapture(scanResult, () => {
                    gifBtn.textContent = originalText;
                    gifBtn.disabled = false;
                });
            }, 100);
        }, 50);
    }
    
    function scanForConvergence() {
        // Save current state
        const savedNetwork = JSON.parse(JSON.stringify(network));
        const savedHistory = JSON.parse(JSON.stringify(history));
        const savedTrainingState = JSON.parse(JSON.stringify(trainingState));
        
        // Reset for scan
        reset();
        
        const losses = [];
        const maxScanSteps = 500;
        const targetFrames = 80;
        
        // Run silent training to collect loss data
        for (let i = 0; i < maxScanSteps; i++) {
            trainStep();
            losses.push(history.loss[history.loss.length - 1]);
            
            // Check for early convergence
            if (losses.length > 50) {
                const recent = losses.slice(-30);
                const variance = computeVariance(recent);
                const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                if (variance < 0.0001 * mean * mean) {
                    break; // Converged early
                }
            }
        }
        
        // Analyze loss curve to find interesting region
        const L0 = losses[0];
        const Lmin = Math.min(...losses);
        const totalDrop = L0 - Lmin;
        
        // Find key milestones
        let start5pct = 0, start50pct = 0, end90pct = losses.length - 1, convergencePoint = losses.length - 1;
        
        for (let i = 0; i < losses.length; i++) {
            const drop = L0 - losses[i];
            if (start5pct === 0 && drop >= 0.05 * totalDrop) start5pct = i;
            if (start50pct === 0 && drop >= 0.50 * totalDrop) start50pct = i;
            if (drop >= 0.90 * totalDrop) { end90pct = i; break; }
        }
        
        // Detect convergence (low variance)
        for (let i = 50; i < losses.length; i++) {
            const window = losses.slice(i - 30, i);
            const variance = computeVariance(window);
            const mean = window.reduce((a, b) => a + b, 0) / window.length;
            if (variance < 0.0001 * mean * mean) {
                convergencePoint = i;
                break;
            }
        }
        
        // Compute |dL/dt| for each step
        const derivatives = losses.map((L, i) => 
            i === 0 ? 0 : Math.abs(losses[i-1] - L)
        );
        
        // Select keyframes adaptively
        const keyframes = selectKeyframes(losses, derivatives, {
            start5pct, start50pct, end90pct, convergencePoint
        }, targetFrames);
        
        // Restore original state
        network = savedNetwork;
        history = savedHistory;
        trainingState = savedTrainingState;
        
        return { losses, keyframes, convergencePoint };
    }
    
    function computeVariance(arr) {
        if (arr.length === 0) return 0;
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
    }
    
    function selectKeyframes(losses, derivatives, milestones, targetFrames) {
        const frames = new Set([0]); // Always include first
        
        // Always include milestone frames
        frames.add(milestones.start5pct);
        frames.add(milestones.start50pct);
        frames.add(milestones.end90pct);
        frames.add(Math.min(milestones.convergencePoint, losses.length - 1));
        frames.add(losses.length - 1); // Always include last
        
        // Score each step by "interestingness" (derivative magnitude)
        const maxDeriv = Math.max(...derivatives.slice(1)) || 1;
        const scores = derivatives.map(d => d / maxDeriv);
        
        // Add frames based on derivative (more change = more frames)
        const numSegments = 20;
        const segmentSize = Math.ceil(losses.length / numSegments);
        
        for (let seg = 0; seg < numSegments; seg++) {
            const segStart = seg * segmentSize;
            const segEnd = Math.min((seg + 1) * segmentSize, losses.length);
            
            // Find max derivative in this segment
            let maxIdx = segStart;
            let maxScore = 0;
            for (let i = segStart; i < segEnd; i++) {
                if (scores[i] > maxScore) {
                    maxScore = scores[i];
                    maxIdx = i;
                }
            }
            
            // Add more frames for high-derivative segments
            if (maxScore > 0.1) {
                frames.add(maxIdx);
                // Add extra frames around high-action areas
                if (maxScore > 0.3 && seg < numSegments - 1) {
                    frames.add(Math.min(maxIdx + 2, losses.length - 1));
                }
            } else {
                // Low derivative - just sample the segment sparsely
                frames.add(Math.floor((segStart + segEnd) / 2));
            }
        }
        
        // Convert to sorted array and limit to targetFrames
        let result = [...frames].sort((a, b) => a - b);
        
        // If we have too many, subsample evenly
        while (result.length > targetFrames) {
            // Remove every other frame except first/last
            const newResult = [result[0]];
            for (let i = 2; i < result.length - 1; i += 2) {
                newResult.push(result[i]);
            }
            newResult.push(result[result.length - 1]);
            result = newResult;
        }
        
        return result;
    }
    
    function startAdaptiveCapture(scanResult, onComplete) {
        const { keyframes } = scanResult;
        
        // Reset to fresh state with same random seed
        reset();
        
        const composite = createCompositeCanvas();
        
        try {
            gifCapture.gif = new GIF({
                workers: 2,
                quality: 10,
                width: composite.width,
                height: composite.height,
                workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
            });
        } catch (e) {
            console.error('Failed to create GIF:', e);
            alert('GIF capture failed: ' + e.message);
            if (onComplete) onComplete();
            return;
        }
        
        gifCapture.recording = true;
        gifCapture.keyframes = keyframes;
        gifCapture.keyframeIndex = 0;
        gifCapture.currentStep = 0;
        
        gifCapture.gif.on('finished', function (blob) {
            // Clear timeout since we finished normally
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `convergence_${timestamp}.gif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            gifCapture.recording = false;
            if (onComplete) onComplete();
        });
        
        // Timeout safety - force complete after 30 seconds
        gifCapture.timeout = setTimeout(() => {
            if (gifCapture.recording) {
                console.warn('GIF capture timeout - forcing completion');
                gifCapture.recording = false;
                gifCapture.gif = null;
                if (onComplete) onComplete();
            }
        }, 30000);
        
        adaptiveCaptureLoop();
    }
    
    function adaptiveCaptureLoop() {
        if (!gifCapture.recording || gifCapture.keyframeIndex >= gifCapture.keyframes.length) {
            if (gifCapture.gif) {
                gifCapture.gif.render();
            }
            return;
        }
        
        const targetStep = gifCapture.keyframes[gifCapture.keyframeIndex];
        
        // Train until we reach the target step (with safety limit)
        let safetyCounter = 0;
        const maxIterations = 10000;
        while (gifCapture.currentStep < targetStep && safetyCounter < maxIterations) {
            const prevStep = trainingState.step;
            trainStep();
            gifCapture.currentStep++;
            safetyCounter++;
            
            // If trainStep didn't actually train (NaN or other issue), break out
            if (trainingState.step === prevStep || !Number.isFinite(history.loss[history.loss.length - 1])) {
                console.warn('GIF capture: training issue detected, finishing early');
                gifCapture.keyframeIndex = gifCapture.keyframes.length; // Force finish
                break;
            }
        }
        
        updateUI();
        
        // Calculate delay based on next keyframe distance (variable speed)
        let delay = 100;
        if (gifCapture.keyframeIndex < gifCapture.keyframes.length - 1) {
            const gap = gifCapture.keyframes[gifCapture.keyframeIndex + 1] - targetStep;
            // Bigger gaps = less action = shorter delay (faster playback)
            delay = gap > 20 ? 50 : gap > 5 ? 100 : 150;
        } else {
            delay = 200; // Pause at end
        }
        
        // Capture frame
        const composite = createCompositeCanvas();
        gifCapture.gif.addFrame(composite, {copy: true, delay});
        
        gifCapture.keyframeIndex++;
        setTimeout(adaptiveCaptureLoop, 30);
    }

    function initializeOptimizerState() {
        optimizerState.m = [];
        optimizerState.v = [];
        optimizerState.r = [];
        optimizerState.t = 0;

        // For each weight matrix/vector
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            if (Array.isArray(w[0])) {
                optimizerState.m.push(w.map(row => row.map(() => 0)));
                optimizerState.v.push(w.map(row => row.map(() => 0)));
                optimizerState.r.push(w.map(row => row.map(() => 0)));
            } else {
                optimizerState.m.push(w.map(() => 0));
                optimizerState.v.push(w.map(() => 0));
                optimizerState.r.push(w.map(() => 0));
            }
        }

        // Biases
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            optimizerState.m.push(b.map(() => 0));
            optimizerState.v.push(b.map(() => 0));
            optimizerState.r.push(b.map(() => 0));
        }
    }
function updateParameters() {
    const lr = config.learningRate;
    const beta1 = 0.9;
    const beta2 = 0.999;
    const epsilon = 1e-8;
    const rho = 0.9;
    const momentumCoeff = 0.9;
    const gradClip = 5.0;  // Gradient clipping threshold

    // Clip gradients to prevent explosion
    function clipGrad(g) {
        if (!Number.isFinite(g)) return 0;
        return Math.max(-gradClip, Math.min(gradClip, g));
    }
    
    // Apply gradient clipping to all gradients
    for (let l = 0; l < grads.weights.length; l++) {
        const gw = grads.weights[l];
        if (Array.isArray(gw[0])) {
            for (let i = 0; i < gw.length; i++) {
                for (let j = 0; j < gw[i].length; j++) {
                    gw[i][j] = clipGrad(gw[i][j]);
                }
            }
        } else {
            for (let i = 0; i < gw.length; i++) {
                gw[i] = clipGrad(gw[i]);
            }
        }
    }
    for (let l = 0; l < grads.biases.length; l++) {
        const gb = grads.biases[l];
        for (let i = 0; i < gb.length; i++) {
            gb[i] = clipGrad(gb[i]);
        }
    }

    let idx = 0;

    // Plain SGD
    if (config.optimizer === 'sgd') {
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            const gw = grads.weights[l];
            if (Array.isArray(w[0])) {
                // matrix
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        w[i][j] -= lr * gw[i][j];
                    }
                }
            } else {
                // vector
                for (let i = 0; i < w.length; i++) {
                    w[i] -= lr * gw[i];
                }
            }
        }
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            const gb = grads.biases[l];
            for (let i = 0; i < b.length; i++) {
                b[i] -= lr * gb[i];
            }
        }
        return;
    }

    // Momentum / RMSProp / Adam
    optimizerState.t += 1;

    // Weights
    for (let l = 0; l < network.weights.length; l++) {
        const w = network.weights[l];
        const gw = grads.weights[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;

            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        v[i][j] = vCoeff * v[i][j] + oneMinus * gw[i][j];
                        w[i][j] -= lr * v[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    v[i] = vCoeff * v[i] + oneMinus * gw[i];
                    w[i] -= lr * v[i];
                }
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        r[i][j] = rho * r[i][j] + oneMinusRho * gw[i][j] * gw[i][j];
                        const step = lr / Math.sqrt(r[i][j] + epsilon);
                        w[i][j] -= step * gw[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    r[i] = rho * r[i] + oneMinusRho * gw[i] * gw[i];
                    const step = lr / Math.sqrt(r[i] + epsilon);
                    w[i] -= step * gw[i];
                }
            }
        } else if (config.optimizer === 'adam') {
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        m[i][j] = beta1 * m[i][j] + (1 - beta1) * gw[i][j];
                        v[i][j] = beta2 * v[i][j] + (1 - beta2) * gw[i][j] * gw[i][j];
                        const mHat = m[i][j] / (1 - Math.pow(beta1, optimizerState.t));
                        const vHat = v[i][j] / (1 - Math.pow(beta2, optimizerState.t));
                        w[i][j] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    m[i] = beta1 * m[i] + (1 - beta1) * gw[i];
                    v[i] = beta2 * v[i] + (1 - beta2) * gw[i] * gw[i];
                    const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                    const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                    w[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                }
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }

    // Biases
    for (let l = 0; l < network.biases.length; l++) {
        const b = network.biases[l];
        const gb = grads.biases[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;
            for (let i = 0; i < b.length; i++) {
                v[i] = vCoeff * v[i] + oneMinus * gb[i];
                b[i] -= lr * v[i];
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            for (let i = 0; i < b.length; i++) {
                r[i] = rho * r[i] + oneMinusRho * gb[i] * gb[i];
                const step = lr / Math.sqrt(r[i] + epsilon);
                b[i] -= step * gb[i];
            }
        } else if (config.optimizer === 'adam') {
            for (let i = 0; i < b.length; i++) {
                m[i] = beta1 * m[i] + (1 - beta1) * gb[i];
                v[i] = beta2 * v[i] + (1 - beta2) * gb[i] * gb[i];
                const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                b[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }
}

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    function makeRunLabel(slot) {
        const optName = config.optimizer === 'sgd' ? 'Simple' : config.optimizer;
        return `${slot}: ${config.activation}, L=${network.numLayers}, H=${network.hiddenSize}, Œ∑=${config.learningRate.toFixed(3)}, ${optName}`;
    }

    function saveRun(slot) {
        if (history.steps.length < 2) {
            alert('Train the network for a few steps before saving a run.');
            return;
        }

        const run = {
            label: makeRunLabel(slot),
            steps: history.steps.slice(),
            loss: history.loss.slice(),
            avgLoss: history.avgLoss.slice(),
            network: deepClone(network),
            config: {
                activation: config.activation,
                learningRate: config.learningRate,
                numLayers: network.numLayers,
                hiddenSize: network.hiddenSize,
                targetFuncStr: config.targetFuncStr,
                optimizer: config.optimizer
            },
            // Save loss landscape trail for comparison visualization
            lossSurfaceTrail: lossSurfaceTrail.slice(),
            lossSurfaceWeightIndices: lossSurfaceWeightIndices.slice()
        };

        savedRuns[slot] = run;

        const labelEl = document.getElementById(slot === 'A' ? 'runALabel' : 'runBLabel');
        if (labelEl) {
            labelEl.textContent = run.label;
        }

        // Style the save button to show it has saved data (subtle indicator - thicker border)
        const saveBtn = document.getElementById(slot === 'A' ? 'saveRunA' : 'saveRunB');
        if (saveBtn) {
            saveBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:8px; border:2px solid #28a745; box-shadow:0 0 3px rgba(40,167,69,0.3);';
        }

        // Enable and style compare button when both A and B are saved
        const compareBtn = document.getElementById('compareBtn');
        if (savedRuns.A && savedRuns.B) {
            compareBtn.disabled = false;
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
        }

        updateUI();
    }

    function forwardWithNetwork(x, net, activationName) {
        const actFn = activationFns[activationName].fn;
        const h = net.hiddenSize;
        const numLayers = net.numLayers;

        let activations = [];
        let zValues = [];

        activations.push([x]);

        // Hidden layer 1
        let z = new Array(h);
        let a = new Array(h);
        const w0 = net.weights[0]; // shape [h, 1] represented as [h]
        const b0 = net.biases[0];  // shape [h]
        for (let i = 0; i < h; i++) {
            let zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = actFn(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let layer = 1; layer < numLayers; layer++) {
            const prev = activations[activations.length - 1];
            const w = net.weights[layer];  // shape [h, h]
            const b = net.biases[layer];   // shape [h]

            z = new Array(h);
            a = new Array(h);

            for (let i = 0; i < h; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < h; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = actFn(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output layer
        const lastLayer = activations[activations.length - 1];
        const wOut = net.weights[net.weights.length - 1];       // shape [h]
        const bOut = net.biases[net.biases.length - 1][0];      // shape [1]
        let yhat = bOut;
        for (let i = 0; i < h; i++) {
            yhat += wOut[i] * lastLayer[i];
        }

        return yhat;
    }

    // -------------- Network, Target & Ops --------------

    function compileTargetFunc() {
        const input = document.getElementById('targetFuncInput');
        let originalStr = input.value.trim() || 'x^2';
        
        // Make case-insensitive by converting to lowercase for function matching
        let fStr = originalStr;
        
        // Allow ^ as power operator (convert to **)
        fStr = fStr.replace(/\^/g, '**');
        
        // Convert shorthand functions to Math.* (case-insensitive)
        // Order matters - longer names first
        fStr = fStr.replace(/\blog10\b/gi, 'Math.log10');  // log base 10
        fStr = fStr.replace(/\bsqrt\b/gi, 'Math.sqrt');
        fStr = fStr.replace(/\babs\b/gi, 'Math.abs');
        fStr = fStr.replace(/\bsin\b/gi, 'Math.sin');
        fStr = fStr.replace(/\bcos\b/gi, 'Math.cos');
        fStr = fStr.replace(/\btan\b/gi, 'Math.tan');
        fStr = fStr.replace(/\bexp\b/gi, 'Math.exp');      // e^x (natural exponential)
        fStr = fStr.replace(/\blog\b/gi, 'Math.log');      // natural log (ln)
        fStr = fStr.replace(/\bfloor\b/gi, 'Math.floor');
        fStr = fStr.replace(/\bceil\b/gi, 'Math.ceil');
        fStr = fStr.replace(/\bround\b/gi, 'Math.round');
        fStr = fStr.replace(/\bsign\b/gi, 'Math.sign');
        fStr = fStr.replace(/\bmin\b/gi, 'Math.min');
        fStr = fStr.replace(/\bmax\b/gi, 'Math.max');
        fStr = fStr.replace(/\bpow\b/gi, 'Math.pow');
        
        // Convert constants (case-insensitive)
        fStr = fStr.replace(/\bPI\b/gi, 'Math.PI');        // œÄ ‚âà 3.14159
        fStr = fStr.replace(/\bE\b/gi, 'Math.E');          // e ‚âà 2.71828
        
        // Make x case-insensitive (X -> x)
        fStr = fStr.replace(/\bX\b/g, 'x');

        // Get or create error display elements
        let errorSpan = document.getElementById('targetFuncError');
        if (!errorSpan) {
            errorSpan = document.createElement('span');
            errorSpan.id = 'targetFuncError';
            errorSpan.style.cssText = 'color:#dc3545; font-size:11px; margin-left:8px; display:block;';
            input.parentNode.appendChild(errorSpan);
        }

        try {
            const fn = new Function('x', 'return ' + fStr + ';');
            // Test it at a few points
            fn(0);
            fn(1);
            fn(-1);
            config.targetFunc = fn;
            config.targetFuncStr = fStr;
            input.style.borderColor = '#28a745';  // Green border for valid
            input.style.backgroundColor = '#fff';
            errorSpan.textContent = '';
            errorSpan.innerHTML = '';
        } catch (e) {
            // Highlight input in red but DON'T revert - let user continue editing
            input.style.borderColor = '#dc3545';
            input.style.backgroundColor = '#fff0f0';
            
            // Try to extract position info from error message
            const errorMsg = e.message;
            let highlightedError = errorMsg;
            
            // Try to find problematic tokens
            const unexpectedMatch = errorMsg.match(/Unexpected token '?([^']*)'?/i);
            const identifierMatch = errorMsg.match(/(\w+) is not defined/i);
            
            if (unexpectedMatch && unexpectedMatch[1]) {
                const badToken = unexpectedMatch[1];
                const pos = originalStr.indexOf(badToken);
                if (pos >= 0) {
                    // Show the input with the bad part highlighted
                    const before = originalStr.substring(0, pos);
                    const bad = originalStr.substring(pos, pos + badToken.length);
                    const after = originalStr.substring(pos + badToken.length);
                    highlightedError = `Error at "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>": ${errorMsg}`;
                }
            } else if (identifierMatch && identifierMatch[1]) {
                const badId = identifierMatch[1];
                // Find case-insensitive match in original
                const regex = new RegExp('\\b' + badId + '\\b', 'i');
                const match = originalStr.match(regex);
                if (match) {
                    const pos = originalStr.search(regex);
                    const before = originalStr.substring(0, pos);
                    const bad = match[0];
                    const after = originalStr.substring(pos + bad.length);
                    highlightedError = `Unknown: "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>" - did you mean a function like sin, cos, exp?`;
                }
            }
            
            errorSpan.innerHTML = '‚ö† ' + highlightedError;
            // Keep the previous valid function running - don't change config.targetFunc
        }
    }

    function initializeNetwork() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        network.weights = [];
        network.biases = [];
        grads.weights = [];
        grads.biases = [];

        function randnScaled(scale) {
            return scale * gaussianNoise(0, 1);
        }

        // Input -> Layer 1: weights shape [H, 1]
        const w0 = new Array(H);
        const b0 = new Array(H);
        const scale0 = 1 / Math.sqrt(1);
        for (let i = 0; i < H; i++) {
            w0[i] = randnScaled(scale0);
            b0[i] = 0;
        }
        network.weights.push(w0);
        network.biases.push(b0);
        grads.weights.push(new Array(H).fill(0));
        grads.biases.push(new Array(H).fill(0));

        // Hidden ‚Üí Hidden
        for (let l = 1; l < L; l++) {
            const w = new Array(H);
            const b = new Array(H);
            const scale = 1 / Math.sqrt(H);
            for (let i = 0; i < H; i++) {
                w[i] = new Array(H);
                for (let j = 0; j < H; j++) {
                    w[i][j] = randnScaled(scale);
                }
                b[i] = 0;
            }
            network.weights.push(w);
            network.biases.push(b);

            const gw = new Array(H);
            for (let i = 0; i < H; i++) {
                gw[i] = new Array(H).fill(0);
            }
            grads.weights.push(gw);
            grads.biases.push(new Array(H).fill(0));
        }

        // Output layer: weights [H], bias [1]
        const wOut = new Array(H);
        const bOut = [0];
        const scaleOut = 1 / Math.sqrt(H);
        for (let i = 0; i < H; i++) {
            wOut[i] = randnScaled(scaleOut);
        }
        network.weights.push(wOut);
        network.biases.push(bOut);

        grads.weights.push(new Array(H).fill(0));
        grads.biases.push([0]);

        initializeOptimizerState();
        computeOpsPerStep();
    }

    function computeOpsPerStep() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        let fwdAdds = 0, fwdMuls = 0;
        let backAdds = 0, backMuls = 0;
        let lossAdds = 0, lossMuls = 0;

        // Forward ops: each neuron does sum of inputs + bias + activation
        // Layer 1: H neurons, each 1 multiply + 1 add + (bias add)
        fwdMuls += H;  // w*x
        fwdAdds += H;  // plus bias

        // Hidden layers
        for (let l = 1; l < L; l++) {
            // each H neuron: H multiplies + H adds + 1 add for bias
            fwdMuls += H * H;
            fwdAdds += H * (H + 1);
        }

        // Output layer: H multiplies + H adds + 1 bias
        fwdMuls += H;
        fwdAdds += H + 1;

        // Loss = 1/2 (yhat - y)^2 -> 1 sub, 1 mul
        lossAdds += 1;
        lossMuls += 1;

        // Backward (rough estimate, symmetrical to forward)
        backMuls += fwdMuls * 2;
        backAdds += fwdAdds * 2;

        // Ops are now drawn on the Network Design canvas
        // Keep these for backwards compatibility if elements exist
        const setIfExists = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
        setIfExists('opsFwdAdd', fwdAdds);
        setIfExists('opsFwdMul', fwdMuls);
        setIfExists('opsLossAdd', lossAdds);
        setIfExists('opsLossMul', lossMuls);
        setIfExists('opsBackAdd', backAdds);
        setIfExists('opsBackMul', backMuls);
        setIfExists('opsTotAdd', fwdAdds + lossAdds + backAdds);
        setIfExists('opsTotMul', fwdMuls + lossMuls + backMuls);

        return { fwdAdds, fwdMuls, lossAdds, lossMuls, backAdds, backMuls };
    }

    // Generate a single point from the target function (used for visualization)
    function sampleTargetPoint() {
        const x = config.xMin + Math.random() * (config.xMax - config.xMin);
        let y;
        try {
            y = config.targetFunc(x);
        } catch {
            y = 0;
        }
        if (config.noise > 0) {
            y += gaussianNoise(0, config.noise);
        }
        return { x, y };
    }
    
    // Legacy function - now gets next point from dataset
    function sampleTrainingPoint() {
        if (!dataset.generated || dataset.train.length === 0) {
            // Fallback to random sampling if no dataset
            return sampleTargetPoint();
        }
        
        // Get the current training sample based on shuffle order
        const idx = dataset.shuffleOrder[dataset.stepInEpoch % dataset.train.length];
        return dataset.train[idx];
    }
    
    // Generate fixed training and test datasets
    function generateDataset() {
        const totalSamples = config.totalSamples;
        const trainRatio = config.trainTestSplit;
        
        // Generate all points across the FULL data range
        const allPoints = [];
        const dataRange = config.dataXMax - config.dataXMin;
        
        for (let i = 0; i < totalSamples; i++) {
            // Use stratified sampling for better coverage
            const x = config.dataXMin + (i + Math.random()) * dataRange / totalSamples;
            let y;
            try {
                y = config.targetFunc(x);
            } catch {
                y = 0;
            }
            if (config.noise > 0) {
                y += gaussianNoise(0, config.noise);
            }
            // Mark if point is within training range
            const inTrainRange = x >= config.trainXMin && x <= config.trainXMax;
            allPoints.push({ x, y, inTrainRange });
        }
        
        // Shuffle all points
        for (let i = allPoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allPoints[i], allPoints[j]] = [allPoints[j], allPoints[i]];
        }
        
        // Split into train candidates and test
        const trainCount = Math.floor(totalSamples * trainRatio);
        const allTrainCandidates = allPoints.slice(0, trainCount);
        const allTestPoints = allPoints.slice(trainCount);
        
        // Store all points
        dataset.allTrain = allTrainCandidates;
        dataset.allTest = allTestPoints;
        
        // Filter training points to only those within training range
        dataset.train = allTrainCandidates.filter(p => p.inTrainRange);
        
        // Test set includes ALL held-out points (both in and out of range)
        dataset.test = allTestPoints;
        
        // Count test points in/out of training range
        const testInRange = allTestPoints.filter(p => p.inTrainRange).length;
        const testOutRange = allTestPoints.length - testInRange;
        
        dataset.generated = true;
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        
        // Reset evaluation
        revealOptions.evaluated = false;
        evaluationResults = {
            testLossInRange: null,
            testLossOutRange: null,
            testLossTotal: null,
            pointsInRange: testInRange,
            pointsOutRange: testOutRange
        };
        
        // Initialize shuffle order for first epoch
        shuffleTrainingOrder();
        
        // Update x range for Fit Plot to show full data range
        config.xMin = config.dataXMin;
        config.xMax = config.dataXMax;
        
        // Update UI
        updatePhaseUI();
        updateTrainingHandlePositions();
        
        const outsideCount = allTrainCandidates.filter(p => !p.inTrainRange).length;
        console.log(`Generated ${totalSamples} total points:`);
        console.log(`  Training: ${dataset.train.length} in range (${outsideCount} excluded outside train range)`);
        console.log(`  Held-out: ${testInRange} in range, ${testOutRange} outside (extrapolation test)`);
        
        return { 
            trainCount: dataset.train.length, 
            testCount: dataset.test.length,
            testInRange,
            testOutRange
        };
    }
    
    // Run evaluation on held-out data
    function runEvaluation() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let lossInRange = 0;
        let lossOutRange = 0;
        let countInRange = 0;
        let countOutRange = 0;
        
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            const loss = 0.5 * error * error;
            
            if (point.inTrainRange) {
                lossInRange += loss;
                countInRange++;
            } else {
                lossOutRange += loss;
                countOutRange++;
            }
        }
        
        evaluationResults = {
            testLossInRange: countInRange > 0 ? lossInRange / countInRange : null,
            testLossOutRange: countOutRange > 0 ? lossOutRange / countOutRange : null,
            testLossTotal: (lossInRange + lossOutRange) / dataset.test.length,
            pointsInRange: countInRange,
            pointsOutRange: countOutRange
        };
        
        revealOptions.evaluated = true;
        revealOptions.showHeldOut = true;  // Automatically reveal held-out points
        
        // Update the checkbox
        const showHeldOutCheckbox = document.getElementById('showHeldOut');
        if (showHeldOutCheckbox) showHeldOutCheckbox.checked = true;
        
        // Record in history
        history.testLoss.push({ 
            step: trainingState.step, 
            loss: evaluationResults.testLossTotal,
            inRange: evaluationResults.testLossInRange,
            outRange: evaluationResults.testLossOutRange
        });
        
        return evaluationResults;
    }
    
    // Shuffle the training order for a new epoch
    function shuffleTrainingOrder() {
        dataset.shuffleOrder = [];
        for (let i = 0; i < dataset.train.length; i++) {
            dataset.shuffleOrder.push(i);
        }
        // Fisher-Yates shuffle
        for (let i = dataset.shuffleOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [dataset.shuffleOrder[i], dataset.shuffleOrder[j]] = [dataset.shuffleOrder[j], dataset.shuffleOrder[i]];
        }
    }
    
    // Compute loss over the entire test set
    function computeTestLoss() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.test.length;
    }
    
    // Compute loss over the entire training set
    function computeTrainLoss() {
        if (!dataset.generated || dataset.train.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.train) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.train.length;
    }
    
    // Update training range from config and re-filter dataset
    function updateTrainingRangeFromConfig() {
        if (!dataset.generated) return;
        if (!dataset.allTrain || !dataset.allTest) return;
        
        // Re-filter training points based on new training range
        // (allTrain and allTest are preserved from original generation)
        dataset.train = dataset.allTrain.filter(p => 
            p.x >= config.trainXMin && p.x <= config.trainXMax
        );
        
        // Update test points' inTrainRange status
        dataset.test = dataset.allTest.map(p => ({
            ...p,
            inTrainRange: p.x >= config.trainXMin && p.x <= config.trainXMax
        }));
        
        // Reset training state (new dataset means starting fresh)
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        shuffleTrainingOrder();
        
        updatePhaseUI();
    }
    
    // Update training handle positions based on training range
    function updateTrainingHandlePositions() {
        const fitCanvas = document.getElementById('fitCanvas');
        const trainMinHandle = document.getElementById('trainMinHandle');
        const trainMaxHandle = document.getElementById('trainMaxHandle');
        
        if (!fitCanvas || !trainMinHandle || !trainMaxHandle) return;
        
        // Calculate plot area (must match drawFitPlot padding)
        const paddingLeft = 50;
        const paddingRight = 50;
        const canvasWidth = fitCanvas.offsetWidth || 520;
        const plotWidth = canvasWidth - paddingLeft - paddingRight;
        
        const dataRange = config.xMax - config.xMin;
        if (dataRange <= 0) return;
        
        // Calculate handle positions based on training range relative to data range
        const minFrac = (config.trainXMin - config.xMin) / dataRange;
        const maxFrac = (config.trainXMax - config.xMin) / dataRange;
        
        // Position handles (12px handle width, so offset by 12 to center)
        const minPx = paddingLeft + (minFrac * plotWidth) - 12;
        const maxPx = paddingLeft + (maxFrac * plotWidth) - 12;
        
        trainMinHandle.style.left = minPx + 'px';
        trainMinHandle.style.right = 'auto';
        trainMaxHandle.style.left = maxPx + 'px';
        trainMaxHandle.style.right = 'auto';
        
        // Enable handles if data is generated
        if (dataset.generated) {
            trainMinHandle.style.opacity = '1';
            trainMinHandle.style.pointerEvents = 'auto';
            trainMaxHandle.style.opacity = '1';
            trainMaxHandle.style.pointerEvents = 'auto';
        } else {
            trainMinHandle.style.opacity = '0.5';
            trainMinHandle.style.pointerEvents = 'none';
            trainMaxHandle.style.opacity = '0.5';
            trainMaxHandle.style.pointerEvents = 'none';
        }
    }
    
    // Update phase UI based on data state
    function updatePhaseUI() {
        const phase1 = document.getElementById('phase1Panel');
        const phase2 = document.getElementById('phase2Panel');
        const dataStatus = document.getElementById('dataStatus');
        const epochStatus = document.getElementById('epochStatus');
        const generateBtn = document.getElementById('generateDataBtn');
        const newDataBtn = document.getElementById('newDataBtn');
        const stepsPerEpoch = document.getElementById('stepsPerEpoch');
        const revealControls = document.getElementById('revealControls');
        const recipeControls = document.getElementById('recipeControls');
        const dataSummary = document.getElementById('dataSummary');
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        
        if (dataset.generated) {
            // Phase 1: Data is ready - keep header bright, show Edit Recipe button
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Hide recipe controls (they get dulled when shown again after collapse)
            recipeControls.style.display = 'none';
            recipeControls.style.opacity = '0.6';
            toggleRecipeBtn.style.display = 'inline-block';
            toggleRecipeBtn.textContent = '‚úèÔ∏è Edit Recipe';
            
            // Show data summary (bright)
            dataSummary.style.display = 'block';
            dataSummary.style.opacity = '1';
            
            // Update data counts
            document.getElementById('trainCount').textContent = dataset.train.length;
            document.getElementById('testCount').textContent = dataset.test.length;
            
            // Show training range info
            const trainRangeLabel = document.getElementById('trainRangeLabel');
            if (trainRangeLabel) {
                trainRangeLabel.textContent = `[${config.trainXMin} to ${config.trainXMax}]`;
            }
            
            // Show test range breakdown
            const testInRange = dataset.test.filter(p => p.inTrainRange).length;
            const testOutRange = dataset.test.length - testInRange;
            const testRangeInfo = document.getElementById('testRangeInfo');
            if (testRangeInfo) {
                if (testOutRange > 0) {
                    testRangeInfo.innerHTML = `<span style="color:#ff9800;">${testInRange} in</span> / <span style="color:#dc3545;">${testOutRange} out</span>`;
                } else {
                    testRangeInfo.textContent = `(all in range)`;
                }
            }
            
            // Update summary note
            const dataSummaryNote = document.getElementById('dataSummaryNote');
            if (dataSummaryNote) {
                if (testOutRange > 0) {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points in range [${config.trainXMin}, ${config.trainXMax}]. ` +
                        `<span style="color:#dc3545;"><strong>${testOutRange}</strong> held-out points are outside this range</span> ‚Äî testing <strong>extrapolation</strong> (can the model generalize beyond its training?).</em>`;
                } else {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points. Held-out data tests if it learned the pattern vs. memorized points.</em>`;
                }
            }
            
            // Populate data previews (show first 4 points each, compact format)
            const formatPoint = (p) => `${p.x.toFixed(1)}‚Üí${p.y.toFixed(2)}`;
            
            const trainPreview = document.getElementById('trainDataPreview');
            const testPreview = document.getElementById('testDataPreview');
            
            // Sort by x for display
            const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
            const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
            
            trainPreview.innerHTML = sortedTrain.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTrain.length > 4 ? `<br><span style="color:#888;">+${sortedTrain.length - 4} more</span>` : '');
            testPreview.innerHTML = sortedTest.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTest.length > 4 ? `<br><span style="color:#888;">+${sortedTest.length - 4} more</span>` : '');
            
            // Update train point count in Fit Plot header
            const trainPointCount = document.getElementById('trainPointCount');
            if (trainPointCount) trainPointCount.textContent = dataset.train.length;
            
            // Enable training range controls
            const trainRangeControls = document.getElementById('trainRangeControls');
            if (trainRangeControls) {
                trainRangeControls.style.opacity = '1';
                trainRangeControls.style.pointerEvents = 'auto';
            }
            
            // Sync mobile training range inputs
            const trainXMinMobile = document.getElementById('trainXMinMobile');
            const trainXMaxMobile = document.getElementById('trainXMaxMobile');
            if (trainXMinMobile) trainXMinMobile.value = config.trainXMin;
            if (trainXMaxMobile) trainXMaxMobile.value = config.trainXMax;
            
            // Enable Phase 3
            const phase3 = document.getElementById('phase3Panel');
            if (phase3) {
                phase3.style.opacity = '1';
                phase3.style.pointerEvents = 'auto';
            }
            
            dataStatus.innerHTML = `‚úì Training data ready`;
            dataStatus.style.color = '#28a745';
            
            // Phase 2: Enable
            phase2.style.opacity = '1';
            phase2.style.pointerEvents = 'auto';
            epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            epochStatus.style.color = '#007bff';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = dataset.train.length;
            
            // Enable reveal controls (Assessment)
            if (revealControls) {
                revealControls.style.opacity = '1';
                revealControls.style.pointerEvents = 'auto';
            }
        } else {
            // Phase 1: Active - show recipe controls (bright)
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Show recipe controls (bright), hide toggle and summary
            recipeControls.style.display = 'flex';
            recipeControls.style.opacity = '1';
            toggleRecipeBtn.style.display = 'none';
            dataSummary.style.display = 'none';
            
            // Enable Phase 1 inputs
            document.getElementById('targetFuncInput').disabled = false;
            document.getElementById('dataXMinInput').disabled = false;
            document.getElementById('dataXMaxInput').disabled = false;
            document.getElementById('trainXMinInput').disabled = false;
            document.getElementById('trainXMaxInput').disabled = false;
            document.getElementById('totalSamples').disabled = false;
            document.getElementById('noise').disabled = false;
            
            dataStatus.textContent = 'Define a data recipe, then generate training data';
            dataStatus.style.color = '#888';
            
            // Phase 2: Disabled
            phase2.style.opacity = '0.5';
            phase2.style.pointerEvents = 'none';
            epochStatus.textContent = 'Generate training data first...';
            epochStatus.style.color = '#888';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = '‚Äî';
            
            // Disable reveal controls
            if (revealControls) {
                revealControls.style.opacity = '0.5';
                revealControls.style.pointerEvents = 'none';
            }
            
            // Reset reveal options
            revealOptions.showHeldOut = false;
            revealOptions.showRecipe = false;
            const showHeldOutCheckbox = document.getElementById('showHeldOut');
            const showRecipeCheckbox = document.getElementById('showRecipe');
            if (showHeldOutCheckbox) showHeldOutCheckbox.checked = false;
            if (showRecipeCheckbox) showRecipeCheckbox.checked = false;
        }
    }
    
    // Show full data in a popup/modal
    function showFullDataView() {
        if (!dataset.generated) return;
        
        const formatPoint = (p, i) => `${(i+1).toString().padStart(3, ' ')}. x = ${p.x.toFixed(4).padStart(8, ' ')}  ‚Üí  y = ${p.y.toFixed(4)}`;
        
        // Sort by x for display
        const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
        const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
        
        const trainText = sortedTrain.map((p, i) => formatPoint(p, i)).join('\n');
        const testText = sortedTest.map((p, i) => formatPoint(p, i)).join('\n');
        
        const fullText = `TRAINING DATA (${dataset.train.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${trainText}\n\n` +
            `HELD-OUT DATA (${dataset.test.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${testText}`;
        
        // Create a simple modal
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:1000;';
        modal.innerHTML = `
            <div style="background:white; border-radius:8px; padding:16px; max-width:600px; max-height:80vh; overflow:auto; box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <h3 style="margin:0; font-size:16px;">Generated Data (input ‚Üí output)</h3>
                    <button id="closeDataModal" style="padding:4px 12px; font-size:12px;">Close</button>
                </div>
                <pre style="font-size:11px; background:#f5f5f5; padding:12px; border-radius:4px; overflow:auto; max-height:60vh; margin:0;">${fullText}</pre>
                <div style="margin-top:12px; font-size:10px; color:#666;">
                    <strong>Note:</strong> The model only sees the training data. Held-out data is used to test if the model learned the underlying pattern (generalization) vs. just memorizing the training points (overfitting).
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target.id === 'closeDataModal') {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Clear dataset and return to Phase 1
    function clearDataset() {
        dataset.generated = false;
        dataset.train = [];
        dataset.test = [];
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.shuffleOrder = [];
        dataset.totalEpochs = 0;
        
        // Also reset the model
        resetModel();
        updatePhaseUI();
    }
    
    // Reset just the model (keep data)
    function resetModel() {
        trainingState.running = false;
        trainingState.animating = false;
        trainingState.step = 0;
        trainingState.totalAdds = 0;
        trainingState.totalMuls = 0;
        trainingState.lastUpdateTime = performance.now();
        trainingState.stepsSinceLastUpdate = 0;
        trainingState.recentSamples = [];
        
        // Reset epoch tracking
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        if (dataset.generated) {
            shuffleTrainingOrder();
        }
        
        history.steps = [];
        history.loss = [];
        history.testLoss = [];
        history.avgLoss = [];
        history.weights = [];
        
        // Reset evaluation state - must re-evaluate after model reset
        revealOptions.evaluated = false;
        
        exitComparisonMode();
        initializeNetwork();
        
        // Repopulate weight selectors and recompute loss surface
        populateWeightSelectors();
        lossSurfaceCache = null;
        lossSurfaceTrail = [];
        
        if (lossLandscapeAutoMode) {
            autoSelectInterestingWeights();
        }
        computeLossSurface();
        
        lossSurfaceStartPosition = {
            x: getWeightByIndex(lossSurfaceWeightIndices[0]),
            y: getWeightByIndex(lossSurfaceWeightIndices[1])
        };
        lossSurfaceTrail = [lossSurfaceStartPosition];
        
        // Compute initial losses if data exists
        if (dataset.generated) {
            const trainLoss = computeTrainLoss();
            const testLoss = computeTestLoss();
            
            history.steps.push(0);
            history.loss.push(trainLoss);
            history.avgLoss.push(null);
            history.testLoss.push({ step: 0, loss: testLoss });
            
            // Record initial weights
            const flatWeights = [];
            network.weights.forEach(layer => {
                if (Array.isArray(layer[0])) {
                    layer.forEach(row => row.forEach(w => flatWeights.push(w)));
                } else {
                    layer.forEach(w => flatWeights.push(w));
                }
            });
            history.weights.push(flatWeights);
        }
        
        updatePhaseUI();
        updateUI();
    }

    function forward(x) {
        const act = activationFns[config.activation].fn;
        const L = network.numLayers;
        const H = network.hiddenSize;

        const activations = [];
        const zValues = [];

        activations.push([x]);

        // Layer 1
        const w0 = network.weights[0];   // [H]
        const b0 = network.biases[0];    // [H]
        let z = new Array(H);
        let a = new Array(H);
        for (let i = 0; i < H; i++) {
            const zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = act(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let l = 1; l < L; l++) {
            const w = network.weights[l];  // [H,H]
            const b = network.biases[l];   // [H]
            const prev = activations[activations.length - 1];

            z = new Array(H);
            a = new Array(H);
            for (let i = 0; i < H; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < H; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = act(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output
        const last = activations[activations.length - 1];
        const wOut = network.weights[network.weights.length - 1]; // [H]
        const bOut = network.biases[network.biases.length - 1][0];
        let yhat = bOut;
        for (let i = 0; i < H; i++) {
            yhat += wOut[i] * last[i];
        }

        return { yhat, activations, zValues };
    }

    function backward(x, y, forwardResult) {
        const { yhat, activations, zValues } = forwardResult;
        const H = network.hiddenSize;
        const L = network.numLayers;
        const actPrime = activationFns[config.activation].dfn;

        const error = yhat - y;
        const loss = 0.5 * error * error;

        // Initialize grads
        for (let l = 0; l < grads.weights.length; l++) {
            if (Array.isArray(grads.weights[l])) {
                if (Array.isArray(grads.weights[l][0])) {
                    for (let i = 0; i < grads.weights[l].length; i++) {
                        grads.weights[l][i].fill(0);
                    }
                } else {
                    grads.weights[l].fill(0);
                }
            }
            grads.biases[l].fill(0);
        }

        // Output layer
        const deltaOut = error;
        const hL = activations[activations.length - 1];

        for (let i = 0; i < H; i++) {
            grads.weights[grads.weights.length - 1][i] = deltaOut * hL[i];
        }
        grads.biases[grads.biases.length - 1][0] = deltaOut;

        let deltaNext = new Array(H);
        for (let i = 0; i < H; i++) {
            deltaNext[i] = network.weights[network.weights.length - 1][i] * deltaOut;
        }

        const deltas = new Array(L);
        for (let l = L - 1; l >= 0; l--) {
            const z = zValues[l];
            const delta = new Array(H);

            for (let i = 0; i < H; i++) {
                delta[i] = deltaNext[i] * actPrime(z[i]);
            }
            deltas[l] = delta;

            // Get input to this layer: for l=0 it's x, otherwise it's activations[l-1]
            const gW = grads.weights[l];
            const gB = grads.biases[l];

            if (l === 0) {
                // First layer: input is x (scalar)
                for (let i = 0; i < H; i++) {
                    gW[i] = delta[i] * x;
                    gB[i] = delta[i];
                }
            } else {
                // Hidden layers: input is previous layer's activations
                const prev = activations[l - 1];
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        gW[i][j] = delta[i] * prev[j];
                    }
                    gB[i] = delta[i];
                }
            }

            if (l > 0) {
                const w = network.weights[l];
                const deltaPrev = new Array(H).fill(0);
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        deltaPrev[j] += w[i][j] * delta[i];
                    }
                }
                deltaNext = deltaPrev;
            }
        }

        return loss;
    }

    // --------------- Training Loop ------------------

    function trainStep() {
        trainingState.stepsSinceLastUpdate++;
        trainingState.step++;
        
        // Advance through the dataset
        if (dataset.generated) {
            dataset.stepInEpoch++;
            
            // Check if we've completed an epoch
            if (dataset.stepInEpoch >= dataset.train.length) {
                dataset.epoch++;
                dataset.totalEpochs++;
                dataset.stepInEpoch = 0;
                shuffleTrainingOrder();  // Reshuffle for next epoch
                
                // Update epoch display
                const epochCount = document.getElementById('epochCount');
                if (epochCount) epochCount.textContent = dataset.epoch;
            }
        }

        const sample = sampleTrainingPoint();
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);

        // Check for NaN - if detected, stop training and warn
        if (!Number.isFinite(loss) || !Number.isFinite(fwd.yhat)) {
            console.warn('NaN detected in training - stopping. Try reducing learning rate or resetting.');
            trainingState.running = false;
            return;
        }

        updateParameters();

        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Evaluate test loss at epoch boundaries (smoother curve)
        if (dataset.generated && dataset.stepInEpoch === 0) {
            const testLoss = computeTestLoss();
            history.testLoss.push({ step: trainingState.step, loss: testLoss, epoch: dataset.epoch });
        }
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);

        const window = config.avgWindow;
        let sum = 0;
        let count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < window; i--, count++) {
            sum += history.loss[i];
        }
        // Only show meaningful average after we have at least 10 data points
        const minPointsForAvg = 10;
        if (history.loss.length >= minPointsForAvg) {
            history.avgLoss.push(sum / count);
        } else {
            history.avgLoss.push(null);  // Will be skipped when drawing
        }

        const maxSamples = 500;
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > maxSamples) {
            trainingState.recentSamples.shift();
        }

        // Accumulate actual ops count
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        // Update loss surface trail - adaptive sampling for full history
        // Record more frequently at start, less frequently as training progresses
        const trailInterval = trainingState.step < 100 ? 2 : 
                             trainingState.step < 1000 ? 5 : 
                             trainingState.step < 5000 ? 10 : 20;
        if (trainingState.step % trailInterval === 0 && lossSurfaceCache) {
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            lossSurfaceTrail.push({ x: wx, y: wy });
            // No limit - keep full history for complete path visualization
        }
        
        // Auto-refresh loss surface every N steps (if cache exists)
        if (lossSurfaceAutoUpdate && lossSurfaceCache && trainingState.step % lossSurfaceUpdateInterval === 0) {
            // Check if current weights are outside the view - if so, recompute with expanded bounds
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const { minX, maxX, minY, maxY } = lossSurfaceCache;
            const margin = 0.1;  // 10% margin before triggering recompute
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            
            if (wx < minX + rangeX * margin || wx > maxX - rangeX * margin ||
                wy < minY + rangeY * margin || wy > maxY - rangeY * margin) {
                // Weights near edge or outside - recompute with expanded view
                computeLossSurface();
            }
            drawLossSurface();
        }
        
        // Update epoch status display
        if (dataset.generated) {
            const epochStatus = document.getElementById('epochStatus');
            if (epochStatus) {
                epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            }
        }
    }

    function runLoop() {
        if (!trainingState.running) return;

        const now = performance.now();
        const stepsPerFrame = 10;
        for (let i = 0; i < stepsPerFrame; i++) {
            trainStep();
        }

        const elapsed = now - trainingState.lastUpdateTime;
        if (elapsed > 0) {
            const stepsPerSec = (stepsPerFrame * 1000) / elapsed;
            document.getElementById('stepsPerSec').textContent = stepsPerSec.toFixed(0);
        }

        trainingState.lastUpdateTime = now;

        updateUI();

        // Auto-pause if no improvement in last 1000 steps
        if (shouldAutoPause()) {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            console.log('Auto-paused: no improvement in last 1000 steps');
            return;
        }

        if (trainingState.running) {
            requestAnimationFrame(runLoop);
        }
    }

    // Full reset - clears data and returns to Phase 1
    function reset() {
        // Stop any ongoing GIF recording
        if (gifCapture.recording || gifCapture.timeout) {
            gifCapture.recording = false;
            gifCapture.gif = null;
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const gifBtn = document.getElementById('gifBtn');
            if (gifBtn) {
                gifBtn.textContent = 'Capture GIF';
                gifBtn.disabled = false;
            }
        }
        
        // Clear dataset and reset model
        clearDataset();
        
        // Compile target function
        compileTargetFunc();
        
        updateUI();
    }

    // --------------- Drawing -----------------------

    function drawNetwork(animState = null) {
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        
        ctx.clearRect(0, 0, w, h);
        
        const numLayers = network.numLayers;
        const hiddenSize = network.hiddenSize;
        
        // Animation state
        const isAnimating = animState !== null;
        const animPhase = animState?.phase;
        const animLayer = animState?.layer;
        
        // Layout calculations - input/output gaps are 50% of hidden layer spacing
        const marginLeft = 50;   // Increased for weight labels
        const marginRight = 80;  // Larger to fit y-hat node and weight labels
        const usableWidth = w - marginLeft - marginRight;
        
        // Calculate spacing: input-to-hidden and hidden-to-output are 0.5x the hidden-to-hidden spacing
        // Total segments: 0.5 + (numLayers-1) + 0.5 = numLayers for numLayers >= 1
        // For 1 hidden layer: 0.5 + 0.5 = 1 segment
        // For 2 hidden layers: 0.5 + 1 + 0.5 = 2 segments
        // For 3 hidden layers: 0.5 + 2 + 0.5 = 3 segments
        const totalSegments = numLayers;
        const hiddenLayerSpacing = usableWidth / totalSegments;
        const inputOutputGap = hiddenLayerSpacing * 0.5;  // 50% of hidden layer spacing
        
        const nodeRadius = 20;
        const fontSize = 13;
        const smallFont = 10;
        const weightFont = 9;  // Smaller font for weights
        
        // Calculate positions for each layer
        const layers = [];
        
        // Input layer - at left margin
        layers.push({x: marginLeft, nodes: [{y: h/2}]});
        
        // Hidden layers - spread across the middle
        const hiddenStartX = marginLeft + inputOutputGap;
        for (let l = 0; l < numLayers; l++) {
            const x = hiddenStartX + hiddenLayerSpacing * l;
            const nodes = [];
            const spacing = Math.min(70, (h - 80) / (hiddenSize - 1 || 1));
            const startY = h/2 - (hiddenSize - 1) * spacing / 2;
            for (let i = 0; i < hiddenSize; i++) {
                nodes.push({y: startY + i * spacing});
            }
            layers.push({x, nodes});
        }
        
        // Output layer - at right margin
        layers.push({x: w - marginRight, nodes: [{y: h/2}]});
        
        // Draw connections with weights
        ctx.font = `${weightFont}px sans-serif`;
        ctx.textAlign = 'center';
        
        // Helper to compute flat weight index for loss landscape highlighting
        function getWeightFlatIndex(layerIdx, fromIdx, toIdx) {
            let idx = 0;
            const H = hiddenSize;
            // Input to first hidden
            if (layerIdx === 0) return toIdx;
            idx += H;
            // Hidden to hidden
            for (let l = 1; l < layerIdx; l++) {
                idx += H * H;
            }
            if (layerIdx < numLayers) {
                return idx + fromIdx * H + toIdx;
            }
            idx += (numLayers - 1) * H * H;
            // Output layer
            return idx + fromIdx;
        }
        
        for (let l = 0; l < layers.length - 1; l++) {
            const fromLayer = layers[l];
            const toLayer = layers[l + 1];
            
            // Highlight during forward animation
            const shouldHighlight = isAnimating && animPhase === 'forward' && animLayer === l + 1;
            
            // Count total connections for offset calculation
            const totalConnections = fromLayer.nodes.length * toLayer.nodes.length;
            let connectionIdx = 0;
            
            // Check for backward pass highlighting
            const shouldHighlightBack = isAnimating && animPhase === 'backward' && animLayer === l + 1;
            
            fromLayer.nodes.forEach((fromNode, fromIdx) => {
                toLayer.nodes.forEach((toNode, toIdx) => {
                    // Check if this weight is selected for loss landscape
                    const flatIdx = getWeightFlatIndex(l, fromIdx, toIdx);
                    const isLossLandscapeWeight = (flatIdx === lossSurfaceWeightIndices[0] || flatIdx === lossSurfaceWeightIndices[1]);
                    
                    // Use green for forward pass, red for backward pass (matches Ops/Step table)
                    if (shouldHighlight) {
                        ctx.strokeStyle = '#28a745';  // Green for forward
                        ctx.lineWidth = 3;
                    } else if (shouldHighlightBack) {
                        ctx.strokeStyle = '#dc3545';  // Red for backward
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#007bff';
                        ctx.lineWidth = 1;
                    }
                    ctx.beginPath();
                    ctx.moveTo(fromLayer.x, fromNode.y);
                    ctx.lineTo(toLayer.x, toNode.y);
                    ctx.stroke();
                    
                    // Draw weight value on connection with horizontal offset to prevent overlap
                    // Offset based on connection index, spreading weights along the line
                    // Use narrower range (0.35-0.65) to keep weights away from edges
                    const t = totalConnections > 1 ? 0.35 + 0.3 * (connectionIdx / (totalConnections - 1)) : 0.5;
                    let labelX = fromLayer.x + (toLayer.x - fromLayer.x) * t;
                    let labelY = fromNode.y + (toNode.y - fromNode.y) * t;
                    
                    // Clamp to canvas bounds with padding
                    const textPadding = 20;
                    labelX = Math.max(textPadding, Math.min(w - textPadding, labelX));
                    labelY = Math.max(12, Math.min(h - 12, labelY));
                    
                    let weight;
                    if (l === 0) {
                        weight = network.weights[0][toIdx];
                    } else if (l < numLayers) {
                        weight = network.weights[l][fromIdx] ? network.weights[l][fromIdx][toIdx] : network.weights[l][toIdx];
                    } else {
                        weight = network.weights[network.weights.length - 1][fromIdx];
                    }
                    
                    if (weight !== undefined) {
                        // Draw small background for readability
                        const textWidth = ctx.measureText(weight.toFixed(2)).width;
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillRect(labelX - textWidth/2 - 2, labelY - 8, textWidth + 4, 11);
                        ctx.fillStyle = '#007bff';
                        ctx.fillText(weight.toFixed(2), labelX, labelY);
                        
                        // Subtle blue box for loss landscape weights
                        if (isLossLandscapeWeight) {
                            ctx.strokeStyle = '#007bff';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(labelX - textWidth/2 - 3, labelY - 9, textWidth + 6, 13);
                        }
                    }
                    connectionIdx++;
                });
            });
        }
        
        // Draw nodes
        const actSymbol = config.activation === 'relu' ? 'ReLU' : 'œÉ';
        
        // Determine if we can show full equations (small networks only)
        const canShowFullEq = numLayers <= 2 && hiddenSize <= 4;
        const wideRadius = canShowFullEq ? nodeRadius * 2.2 : nodeRadius * 1.15;
        
        // Helper to format weight with sign
        const fmtW = (w) => {
            if (w === undefined || w === null) return '?';
            const val = w.toFixed(2);
            return w >= 0 ? `+${val}` : val;
        };
        const fmtWFirst = (w) => {
            if (w === undefined || w === null) return '?';
            return w.toFixed(2);
        };
        
        layers.forEach((layer, layerIdx) => {
            layer.nodes.forEach((node, nodeIdx) => {
                const nodeHighlight = isAnimating && animPhase === 'forward' && animLayer === layerIdx;
                const showGradients = isAnimating && animPhase === 'backward' && animLayer === layerIdx;
                
                if (layerIdx === 0) {
                    // Input node - small dot
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#333';
                    ctx.beginPath();
                    ctx.arc(layer.x, node.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (layerIdx === layers.length - 1) {
                    // Output node - wider oval
                    const outRadius = canShowFullEq ? wideRadius : nodeRadius * 1.3;
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#f0f8ff';
                    ctx.strokeStyle = '#6f42c1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, outRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    if (canShowFullEq) {
                        // Full equation: ≈∑ = v1*h1 + v2*h2 + ... + b
                        const outputWeights = network.weights[network.weights.length - 1];
                        const outputBias = network.biases[network.biases.length - 1][0];
                        let eqParts = [];
                        for (let i = 0; i < hiddenSize && i < 4; i++) {
                            const w = outputWeights[i];
                            if (i === 0) {
                                eqParts.push(`${fmtWFirst(w)}¬∑h${numLayers}${i+1}`);
                            } else {
                                eqParts.push(`${fmtW(w)}¬∑h${numLayers}${i+1}`);
                            }
                        }
                        if (hiddenSize > 4) eqParts.push('...');
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('≈∑', layer.x, node.y - 8);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Show equation on two lines if needed
                        const eq1 = eqParts.slice(0, 2).join('');
                        const eq2 = eqParts.slice(2).join('') + fmtW(outputBias);
                        ctx.fillText(eq1, layer.x, node.y + 4);
                        if (eq2.length > 3) {
                            ctx.fillText(eq2, layer.x, node.y + 13);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('≈∑', layer.x, node.y - 6);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText('Œ£v¬∑h+b', layer.x, node.y + 8);
                    }
                } else {
                    // Hidden node - oval with equation
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#e3f2fd';
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, wideRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    if (canShowFullEq) {
                        // Full equation: ReLU(w1*x + b) for first layer
                        // or ReLU(w1*h1 + w2*h2 + ... + b) for subsequent layers
                        let eqStr = '';
                        if (layerIdx === 1) {
                            // First hidden layer: input is x
                            const w = network.weights[0][nodeIdx];
                            const b = network.biases[0][nodeIdx];
                            eqStr = `${actSymbol}(${fmtWFirst(w)}¬∑x${fmtW(b)})`;
                        } else {
                            // Subsequent hidden layers
                            const prevLayerSize = hiddenSize;
                            const layerWeights = network.weights[layerIdx - 1];
                            const bias = network.biases[layerIdx - 1][nodeIdx];
                            let terms = [];
                            for (let i = 0; i < prevLayerSize && i < 3; i++) {
                                const w = layerWeights[i] ? layerWeights[i][nodeIdx] : layerWeights[nodeIdx];
                                if (i === 0) {
                                    terms.push(`${fmtWFirst(w)}¬∑h${layerIdx-1}${i+1}`);
                                } else {
                                    terms.push(`${fmtW(w)}¬∑h${layerIdx-1}${i+1}`);
                                }
                            }
                            if (prevLayerSize > 3) terms.push('...');
                            eqStr = `${actSymbol}(${terms.join('')}${fmtW(bias)})`;
                        }
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize - 1}px sans-serif`;
                        ctx.fillText(`h${layerIdx}${nodeIdx+1}`, layer.x, node.y - 6);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Truncate if too long
                        if (eqStr.length > 20) {
                            ctx.fillText(eqStr.substring(0, 20), layer.x, node.y + 5);
                            ctx.fillText(eqStr.substring(20), layer.x, node.y + 14);
                        } else {
                            ctx.fillText(eqStr, layer.x, node.y + 6);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize}px sans-serif`;
                        ctx.fillText(`h${layerIdx}${nodeIdx+1}`, layer.x, node.y - 4);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText(`${actSymbol}(z)`, layer.x, node.y + 8);
                    }
                }
            });
        });
        
        // Draw bias values for all non-input nodes
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        layers.forEach((layer, layerIdx) => {
            if (layerIdx === 0) return;  // Skip input layer
            
            layer.nodes.forEach((node, nodeIdx) => {
                let bias = 0;
                if (layerIdx < layers.length - 1) {
                    // Hidden layer bias
                    bias = network.biases[layerIdx - 1] ? network.biases[layerIdx - 1][nodeIdx] : 0;
                } else {
                    // Output layer bias
                    bias = network.biases[network.biases.length - 1] ? network.biases[network.biases.length - 1][0] : 0;
                }
                
                // Draw bias value below node (closer to bubble)
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                const biasText = `b=${bias.toFixed(1)}`;
                const textW = ctx.measureText(biasText).width;
                ctx.fillRect(layer.x - textW/2 - 1, node.y + nodeRadius - 1, textW + 2, 10);
                ctx.fillStyle = '#e67e22';
                ctx.fillText(biasText, layer.x, node.y + nodeRadius + 7);
            });
        });
        
        // Input label - larger and bolder
        ctx.fillStyle = '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('x', layers[0].x, layers[0].nodes[0].y - 12);
        
        // Show current values: x, y, ≈∑, and loss
        if (trainingState.recentSamples.length > 0) {
            const lastSample = trainingState.recentSamples[trainingState.recentSamples.length - 1];
            const lastLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : null;
            
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            
            // Left side: input and target
            ctx.fillText(`x = ${lastSample.x.toFixed(3)}`, 8, 18);
            ctx.fillText(`y = ${lastSample.y.toFixed(3)}`, 8, 32);
            
            // Right side: prediction and loss
            ctx.textAlign = 'right';
            if (history.loss.length > 0) {
                const fwd = forward(lastSample.x);
                ctx.fillText(`≈∑ = ${fwd.yhat.toFixed(3)}`, w - 8, 18);
                ctx.fillStyle = lastLoss < 0.01 ? '#28a745' : '#dc3545';
                ctx.fillText(`L = ¬Ω(≈∑-y)¬≤ = ${lastLoss.toFixed(4)}`, w - 8, 32);
            }
        }
        
        // Bottom: architecture info - larger font for readability
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        const optName = config.optimizer === 'sgd' ? 'Simple' : 'Adam';
        // Count total weights: first layer (H) + hidden layers ((L-1)*H*H) + output layer (H)
        const totalWeights = hiddenSize + (numLayers - 1) * hiddenSize * hiddenSize + hiddenSize;
        const totalBiases = numLayers * hiddenSize + 1;
        const totalParams = totalWeights + totalBiases;
        ctx.fillText(`${numLayers} hidden layer${numLayers > 1 ? 's' : ''} √ó ${hiddenSize} neurons  ‚Ä¢  ${totalParams} params  ‚Ä¢  ${actSymbol}  ‚Ä¢  ${optName}`, w/2, h - 6);
        
        // Update HTML Ops/Step table (check elements exist first)
        const ops = computeOpsPerStep();
        const opsFwdAdds = document.getElementById('opsFwdAdds');
        const opsFwdMuls = document.getElementById('opsFwdMuls');
        const opsBackAdds = document.getElementById('opsBackAdds');
        const opsBackMuls = document.getElementById('opsBackMuls');
        const opsTotAdds = document.getElementById('opsTotAdds');
        const opsTotMuls = document.getElementById('opsTotMuls');
        
        if (opsFwdAdds) opsFwdAdds.textContent = ops.fwdAdds;
        if (opsFwdMuls) opsFwdMuls.textContent = ops.fwdMuls;
        if (opsBackAdds) opsBackAdds.textContent = ops.backAdds;
        if (opsBackMuls) opsBackMuls.textContent = ops.backMuls;
        if (opsTotAdds) opsTotAdds.textContent = ops.fwdAdds + ops.backAdds;
        if (opsTotMuls) opsTotMuls.textContent = ops.fwdMuls + ops.backMuls;
    }
    
    // Animated step function
    async function animatedStep() {
        if (trainingState.animating) return;
        trainingState.animating = true;
        
        // Sample data
        const sample = sampleTrainingPoint();
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > 500) {
            trainingState.recentSamples.shift();
        }
        
        const numLayers = network.numLayers;
        const delayPerLayer = 300; // 0.3 seconds per layer
        
        // Animate forward pass
        drawNetwork({phase: 'forward', layer: 0});
        await sleep(delayPerLayer);
        
        for (let i = 1; i <= numLayers; i++) {
            drawNetwork({phase: 'forward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'forward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        // Compute forward and backward
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);
        
        // Animate backward pass
        drawNetwork({phase: 'backward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        for (let i = numLayers; i >= 1; i--) {
            drawNetwork({phase: 'backward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'backward', layer: 0});
        await sleep(delayPerLayer);
        
        // Update parameters
        updateParameters();
        
        // Update history
        trainingState.step++;
        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);
        
        const windowSize = config.avgWindow;
        let sum = 0, count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < windowSize; i--, count++) {
            sum += history.loss[i];
        }
        history.avgLoss.push(sum / Math.max(1, count));
        
        // Update ops
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        trainingState.animating = false;
        updateUI();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function updateEquations() {
        const L = network.numLayers;
        const H = network.hiddenSize;
        const act = config.activation;
        const actName = act === 'relu' ? 'ReLU' : 'Sigmoid';
        
        // Subscript numbers for cleaner notation
        const sub = (n) => ['‚ÇÄ','‚ÇÅ','‚ÇÇ','‚ÇÉ','‚ÇÑ'][n] || n;
        
        // Activation derivative in calculus terms
        const actDeriv = {
            'relu': "f'(z) = 1 if z > 0, else 0  <em style='color:#888'>(no saturation!)</em>",
            'sigmoid': "f'(z) = f(z) ¬∑ (1 ‚àí f(z))  <em style='color:#888'>(can vanish near 0 or 1)</em>"
        };
        
        let forwardHtml = `
            <strong>Setup:</strong> ${L} hidden layer${L>1?'s':''}, ${H} neurons each<br>
            <strong>Activation:</strong> f = ${actName}<br><br>
        `;
        
        // Layer-by-layer forward with subscripts
        forwardHtml += `<span style="color:#2E86AB">h${sub(0)}</span> = x  <em style="color:#888">(input)</em><br>`;
        for (let l = 1; l <= L; l++) {
            const prevH = l === 1 ? 'x' : `h${sub(l-1)}`;
            forwardHtml += `<span style="color:#F18F01">z${sub(l)}</span> = W${sub(l)} ¬∑ ${prevH} + b${sub(l)}  <em style="color:#888">(weighted sum)</em><br>`;
            forwardHtml += `<span style="color:#28a745">h${sub(l)}</span> = f(z${sub(l)})  <em style="color:#888">(apply activation)</em><br>`;
        }
        forwardHtml += `<br><span style="color:#6f42c1">≈∑</span> = v ¬∑ h${sub(L)} + c  <em style="color:#888">(output layer)</em>`;
        
        // Backward pass with calculus notation
        let backwardHtml = `
            <strong>Loss function:</strong> L = ¬Ω(≈∑ ‚àí y)¬≤<br><br>
            <strong>Chain rule from output:</strong><br>
            <span style="color:#dc3545">‚àÇL/‚àÇ≈∑</span> = ≈∑ ‚àí y  <em style="color:#888">(prediction error)</em><br>
            ‚àÇL/‚àÇv = (‚àÇL/‚àÇ≈∑) ¬∑ h${sub(L)}<br>
            ‚àÇL/‚àÇc = ‚àÇL/‚àÇ≈∑<br><br>
            <strong>Chain rule through layers:</strong><br>
        `;
        
        for (let l = L; l >= 1; l--) {
            const upstream = l === L ? '(‚àÇL/‚àÇ≈∑) ¬∑ v' : `(‚àÇL/‚àÇh${sub(l+1)}) ¬∑ W${sub(l+1)}`;
            const prevH = l === 1 ? 'x' : `h${sub(l-1)}`;
            backwardHtml += `<span style="color:#dc3545">‚àÇL/‚àÇh${sub(l)}</span> = ${upstream} ¬∑ f'(z${sub(l)})<br>`;
            backwardHtml += `‚àÇL/‚àÇW${sub(l)} = (‚àÇL/‚àÇh${sub(l)}) ¬∑ ${prevH},  ‚àÇL/‚àÇb${sub(l)} = ‚àÇL/‚àÇh${sub(l)}<br>`;
        }
        
        backwardHtml += `<br><strong>Activation derivative:</strong><br>${actDeriv[act]}`;
        
        // Optimizer explanation
        const optName = config.optimizer === 'sgd' ? 'Simple (SGD)' : 'Adam';
        const optExplain = config.optimizer === 'sgd' 
            ? `<strong>Weight Update:</strong><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇL/‚àÇw<br>
               <em style="color:#888">Each weight changes proportionally to its gradient.</em>`
            : `<strong>Weight Update:</strong><br>
               m ‚Üê 0.9¬∑m + 0.1¬∑‚àáL <em style="color:#888">(momentum)</em><br>
               v ‚Üê 0.999¬∑v + 0.001¬∑(‚àáL)¬≤ <em style="color:#888">(adapt)</em><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ m / ‚àöv<br>
               <em style="color:#888">Momentum smooths updates; adaptive rates help rare gradients.</em>`;
        
        const html = `
            <div class="equation-block">
                <div class="equation-title">Forward</div>
                <div class="math">${forwardHtml}</div>
            </div>
            <div class="equation-block">
                <div class="equation-title">Backward (Gradients)</div>
                <div class="math">${backwardHtml}</div>
                <br>
                <div class="equation-title" style="margin-top:8px;">Update: ${optName}</div>
                <div class="math">${optExplain}</div>
            </div>
        `;
        
        document.getElementById('equationsDiv').innerHTML = html;
    }


    function drawFitPlot() {
        const canvas = document.getElementById('fitCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 50;
        const paddingRight = 50;
        const paddingTop = 30;
        const paddingBottom = 38;

        ctx.clearRect(0, 0, w, h);

        const xMin = config.xMin;
        const xMax = config.xMax;
        const xRange = xMax - xMin;

        const hasRunA = !!savedRuns.A;
        const hasRunB = !!savedRuns.B;
        const comparisonMode = hasRunA && hasRunB;

        // Generate model prediction curve
        const numPoints = 200;
        const modelPoints = [];
        let modelPointsA = null;
        let modelPointsB = null;

        for (let i = 0; i <= numPoints; i++) {
            const x = xMin + (i / numPoints) * xRange;
            if (comparisonMode) {
                if (!modelPointsA) modelPointsA = [];
                if (!modelPointsB) modelPointsB = [];
                const netA = savedRuns.A.network;
                const cfgA = savedRuns.A.config;
                const netB = savedRuns.B.network;
                const cfgB = savedRuns.B.config;
                modelPointsA.push({ x, y: forwardWithNetwork(x, netA, cfgA.activation) });
                modelPointsB.push({ x, y: forwardWithNetwork(x, netB, cfgB.activation) });
            } else {
                modelPoints.push({ x, y: forward(x).yhat });
            }
        }

        // Collect all Y values for axis range calculation
        let allY = [];
        
        // Always include target function range for consistent axis
        for (let i = 0; i <= 50; i++) {
            const x = xMin + (i / 50) * xRange;
            try { allY.push(config.targetFunc(x)); } catch { /* ignore */ }
        }
        
        // Include training and test data points in range
        if (dataset.generated) {
            dataset.train.forEach(p => allY.push(p.y));
            dataset.test.forEach(p => allY.push(p.y));
        }
        
        // Include model predictions if they're not too extreme
        const modelYs = comparisonMode 
            ? [...modelPointsA.map(p => p.y), ...modelPointsB.map(p => p.y)]
            : modelPoints.map(p => p.y);
        const dataYMin = allY.length > 0 ? Math.min(...allY) : -1;
        const dataYMax = allY.length > 0 ? Math.max(...allY) : 1;
        const dataYRange = dataYMax - dataYMin || 1;
        
        // Only include model Y values if they're within reasonable range (5x data range)
        modelYs.forEach(y => {
            if (Number.isFinite(y) && y >= dataYMin - dataYRange * 2 && y <= dataYMax + dataYRange * 2) {
                allY.push(y);
            }
        });

        let yMin = Math.min(...allY);
        let yMax = Math.max(...allY);
        if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
            yMin = -1;
            yMax = 1;
        }
        // Add 10% padding
        const yPad = (yMax - yMin) * 0.1 || 0.5;
        yMin -= yPad;
        yMax += yPad;
        const yRange = yMax - yMin || 1;

        const plotWidth = w - paddingLeft - paddingRight;
        const plotHeight = h - paddingTop - paddingBottom;
        const toCanvasX = (x) => paddingLeft + (x - xMin) / xRange * plotWidth;
        const toCanvasY = (y) => h - paddingBottom - (y - yMin) / yRange * plotHeight;

        // Draw plot border
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotWidth, plotHeight);

        // Draw X axis tick marks and labels
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const numXTicks = 5;
        for (let i = 0; i <= numXTicks; i++) {
            const xVal = xMin + (i / numXTicks) * xRange;
            const cx = toCanvasX(xVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(cx, h - paddingBottom);
            ctx.lineTo(cx, h - paddingBottom + 5);
            ctx.stroke();
            ctx.fillText(xVal.toFixed(1), cx, h - paddingBottom + 16);
        }

        // Draw Y axis tick marks and labels
        ctx.textAlign = 'right';
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            const yVal = yMin + (i / numYTicks) * yRange;
            const cy = toCanvasY(yVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(paddingLeft - 5, cy);
            ctx.lineTo(paddingLeft, cy);
            ctx.stroke();
            ctx.fillText(yVal.toFixed(2), paddingLeft - 8, cy + 3);
        }

        // Draw data recipe curve (only if revealing or no data yet)
        if (!dataset.generated || revealOptions.showRecipe) {
            const recipeAlpha = dataset.generated ? 0.4 : 0.3;
            ctx.strokeStyle = `rgba(40, 167, 69, ${recipeAlpha})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = xMin + (i / 100) * xRange;
                let y;
                try { y = config.targetFunc(x); } catch { y = 0; }
                const cx = toCanvasX(x);
                const cy = toCanvasY(y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw training examples (filled circles) - always shown when data exists
        if (dataset.generated && dataset.train.length > 0) {
            ctx.fillStyle = '#007bff';
            dataset.train.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Draw training range indicator (vertical bands showing where model was trained)
        if (dataset.generated && (config.trainXMin > config.dataXMin || config.trainXMax < config.dataXMax)) {
            ctx.fillStyle = 'rgba(0, 123, 255, 0.05)';
            const trainLeft = toCanvasX(config.trainXMin);
            const trainRight = toCanvasX(config.trainXMax);
            ctx.fillRect(trainLeft, paddingTop, trainRight - trainLeft, plotHeight);
            
            // Draw dashed vertical lines at training boundaries
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(trainLeft, paddingTop);
            ctx.lineTo(trainLeft, h - paddingBottom);
            ctx.moveTo(trainRight, paddingTop);
            ctx.lineTo(trainRight, h - paddingBottom);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw held-out examples - only if revealed
        if (dataset.generated && dataset.test.length > 0 && revealOptions.showHeldOut) {
            dataset.test.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                
                if (p.inTrainRange) {
                    // In-range test points: orange diamonds (interpolation test)
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                } else {
                    // Out-of-range test points: red diamonds (extrapolation test)
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                }
                
                // Draw diamond shape
                ctx.beginPath();
                ctx.moveTo(cx, cy - 5);
                ctx.lineTo(cx + 4, cy);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 4, cy);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
        }

        // Draw model prediction curve
        if (comparisonMode) {
            // Model A - blue
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsA.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Model B - orange
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsB.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        } else {
            // Single model - purple
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            modelPoints.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        }

        // Axis labels
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('x', w / 2, h - 8);
        ctx.save();
        ctx.translate(10, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('y', 0, 0);
        ctx.restore();

        // Legend
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'left';
        const legendY = 14;
        let legendX = w - 350;

        if (dataset.generated) {
            // Training examples - blue circle
            ctx.fillStyle = '#007bff';
            ctx.beginPath();
            ctx.arc(legendX + 4, legendY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillText(`Training (${dataset.train.length})`, legendX + 12, legendY + 3);
            legendX += 75;

            // Held-out examples (only if revealed)
            if (revealOptions.showHeldOut) {
                // In-range test points (interpolation)
                const inRangeCount = dataset.test.filter(p => p.inTrainRange).length;
                const outRangeCount = dataset.test.length - inRangeCount;
                
                if (inRangeCount > 0) {
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 1.5;
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(legendX + 4, legendY - 4);
                    ctx.lineTo(legendX + 8, legendY);
                    ctx.lineTo(legendX + 4, legendY + 4);
                    ctx.lineTo(legendX, legendY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillText(`Held (${inRangeCount})`, legendX + 12, legendY + 3);
                    legendX += 55;
                }
                
                // Out-of-range test points (extrapolation)
                if (outRangeCount > 0) {
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 1.5;
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(legendX + 4, legendY - 4);
                    ctx.lineTo(legendX + 8, legendY);
                    ctx.lineTo(legendX + 4, legendY + 4);
                    ctx.lineTo(legendX, legendY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillText(`Extrap (${outRangeCount})`, legendX + 12, legendY + 3);
                    legendX += 60;
                }
            }
            
            // Data recipe - green dashed (only if revealed)
            if (revealOptions.showRecipe) {
                ctx.strokeStyle = 'rgba(40, 167, 69, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 2]);
                ctx.beginPath();
                ctx.moveTo(legendX, legendY);
                ctx.lineTo(legendX + 16, legendY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#333';
                ctx.fillText('Recipe', legendX + 20, legendY + 3);
                legendX += 55;
            }
        } else {
            // No data yet - show recipe preview
            ctx.strokeStyle = 'rgba(40, 167, 69, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#333';
            ctx.fillText('Recipe preview', legendX + 20, legendY + 3);
            legendX += 95;
        }

        // Model prediction - purple line
        if (dataset.generated) {
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model', legendX + 20, legendY + 3);
        }

        if (comparisonMode) {
            legendX += 55;
            ctx.strokeStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model B', legendX + 20, legendY + 3);
        }
    }

    function drawTrainingTraceComparison(ctx, w, h,
                                     paddingLeft, paddingRight,
                                     paddingTop, paddingBottom,
                                     runA, runB,
                                     showLoss, showAvgLoss, useLogScale = false,
                                     viewEndStep = null) {
    if (!runA || !runB) return;

    // Apply view filtering if specified
    let filteredRunA = runA;
    let filteredRunB = runB;
    if (viewEndStep !== null) {
        // Find index where step exceeds viewEndStep
        const idxA = runA.steps.findIndex(s => s > viewEndStep);
        const endIdxA = idxA === -1 ? runA.steps.length : idxA;
        filteredRunA = {
            steps: runA.steps.slice(0, endIdxA),
            loss: runA.loss.slice(0, endIdxA),
            avgLoss: runA.avgLoss.slice(0, endIdxA)
        };
        
        const idxB = runB.steps.findIndex(s => s > viewEndStep);
        const endIdxB = idxB === -1 ? runB.steps.length : idxB;
        filteredRunB = {
            steps: runB.steps.slice(0, endIdxB),
            loss: runB.loss.slice(0, endIdxB),
            avgLoss: runB.avgLoss.slice(0, endIdxB)
        };
    }

    const series = [];

    if (showLoss) {
        series.push({
            name: 'Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.loss,
            color: '#dc3545',
            lineWidth: 2
        });
        series.push({
            name: 'Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.loss,
            color: '#ff9800',
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.avgLoss,
            color: '#007bff',
            lineWidth: 3
        });
        series.push({
            name: 'Avg Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.avgLoss,
            color: '#00bcd4',
            lineWidth: 3
        });
    }

    if (series.length === 0) return;

    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X (steps)
    let stepMin = Infinity;
    let stepMax = -Infinity;
    series.forEach(s => {
        if (s.steps.length > 0) {
            stepMin = Math.min(stepMin, s.steps[0]);
            stepMax = Math.max(stepMax, s.steps[s.steps.length - 1]);
        }
    });
    if (!Number.isFinite(stepMin) || !Number.isFinite(stepMax)) return;
    const stepRange = stepMax - stepMin || 1;

    // Y (loss, linear)
    let yMin = Infinity;
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v)) return;
            yMin = Math.min(yMin, v);
            yMax = Math.max(yMax, v);
        });
    });
    if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
        yMin = 0;
        yMax = 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(1e-6, Math.abs(yMin) * 0.1);
        yMin -= eps;
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMin -= pad;
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) =>
        h - paddingBottom - ((val - yMin) / yRange) * plotHeight;

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicksComp = getNiceTicks(stepMin, stepMax, 5);
    xTicksComp.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values
    ctx.textAlign = 'right';
    const yTicksComp = getNiceTicks(yMin, yMax, 5);
    yTicksComp.forEach(val => {
        if (val < yMin || val > yMax) return;
        const y = toY(val);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        ctx.fillText(val.toPrecision(3), paddingLeft - 4, y + 3);
    });

    // Axis labels - moved further left to avoid overlap with tick labels
    ctx.save();
    ctx.translate(10, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText(useLogScale ? 'Loss (log‚ÇÅ‚ÇÄ)' : 'Loss (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        for (let i = 0; i < s.data.length; i++) {
            const x = toX(s.steps[i]);
            const y = toY(s.data[i]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    });

    // Legend - 2 columns to avoid overlap
    const legendStartX = w / 2 - 120;
    const legendColWidth = 110;
    const legendStartY = 12;
    const legendRowHeight = 14;
    
    series.forEach((s, i) => {
        const col = i % 2;  // 0 or 1
        const row = Math.floor(i / 2);  // 0, 1, ...
        const x = legendStartX + col * legendColWidth;
        const y = legendStartY + row * legendRowHeight;
        
        ctx.fillStyle = s.color;
        ctx.fillRect(x, y, 20, s.lineWidth);
        ctx.fillStyle = '#333';
        ctx.font = s.lineWidth === 3 ? 'bold 10px sans-serif' : '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(s.name, x + 24, y + 4);
    });
}

function drawTrainingTrace() {
    const canvas = document.getElementById('traceCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const paddingLeft = 60;
    const paddingRight = 60;
    const paddingTop = 40;
    const paddingBottom = 40;

    ctx.clearRect(0, 0, w, h);

    const showLoss = document.getElementById('traceLoss').checked;
    const showAvgLoss = document.getElementById('traceAvgLoss').checked;
    const showWeights = document.getElementById('traceWeights').checked;
    const useLogScale = document.getElementById('traceLogScale').checked;

    const hasRunA = !!savedRuns.A;
    const hasRunB = !!savedRuns.B;
    const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

    // Determine max steps for zoom handle (works for both normal and comparison modes)
    let maxSteps;
    if (comparisonMode) {
        maxSteps = Math.max(
            savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
            savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
        );
    } else {
        maxSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
    }
    
    // Show view handle when we have enough data to zoom
    const viewHandle = document.getElementById('traceViewHandle');
    const hasEnoughData = comparisonMode ? maxSteps > 50 : history.steps.length > 50;
    if (viewHandle) {
        if (hasEnoughData) {
            viewHandle.style.display = 'flex';
            viewHandle.style.opacity = '0.9';
        } else {
            viewHandle.style.display = 'none';
        }
        
        // Reset view when running
        if (trainingState.running) {
            traceViewEndStep = null;
        }
    }

    if (comparisonMode) {
        drawTrainingTraceComparison(
            ctx, w, h,
            paddingLeft, paddingRight,
            paddingTop, paddingBottom,
            savedRuns.A, savedRuns.B,
            showLoss, showAvgLoss, useLogScale,
            traceViewEndStep  // Pass the view end step
        );
        return;
    }

    // Draw axes even when no data yet
    const hasData = history.steps.length > 0;
    
    // Calculate view window: always start from 0, end based on traceViewEndStep (when paused)
    let viewStartIdx = 0;
    let viewEndIdx = history.steps.length;
    
    // If we have a view end step set, use it
    if (traceViewEndStep !== null && traceViewEndStep < history.steps.length) {
        viewEndIdx = Math.max(10, traceViewEndStep);
    }
    
    // Get sliced data for the view
    const viewSteps = hasData ? history.steps.slice(viewStartIdx, viewEndIdx) : [];
    const viewLoss = hasData ? history.loss.slice(viewStartIdx, viewEndIdx) : [];
    const viewAvgLoss = hasData ? history.avgLoss.slice(viewStartIdx, viewEndIdx) : [];
    
    const series = [];

    if (showLoss) {
        series.push({
            name: 'Train Loss',
            steps: viewSteps,
            data: viewLoss,
            color: '#28a745',  // Green for training (matches train points)
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss',
            steps: viewSteps,
            data: viewAvgLoss,
            color: '#007bff',
            lineWidth: 3
        });
    }
    
    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X axis range (use defaults if no data) - declare early so test loss filter can use it
    const stepMin = viewSteps.length > 0 ? viewSteps[0] : 0;
    const stepMax = viewSteps.length > 0 ? viewSteps[viewSteps.length - 1] : 100;
    const stepRange = stepMax - stepMin || 100;

    // Add test loss series if evaluated (only show after clicking Evaluate button)
    if (showLoss && history.testLoss.length > 0 && revealOptions.evaluated) {
        // Filter test loss to view window
        const viewTestLoss = history.testLoss.filter(t => 
            t.step >= stepMin && (traceViewEndStep === null || t.step <= traceViewEndStep)
        );
        if (viewTestLoss.length > 0) {
            series.push({
                name: 'Test Loss',
                steps: viewTestLoss.map(t => t.step),
                data: viewTestLoss.map(t => t.loss),
                color: '#ff9800',  // Orange for test (matches test points)
                lineWidth: 2,
                dashed: true  // Dashed line to distinguish from train
            });
        }
    }

    // Y axis range for loss (supports log scale) - ALWAYS starts from 0 in linear mode
    let yMin = 0;  // Loss always starts from 0
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v) || (useLogScale && v <= 0)) return;
            const val = useLogScale ? Math.log10(v) : v;
            yMax = Math.max(yMax, val);
        });
    });
    if (useLogScale) {
        // For log scale, find the minimum non-zero value
        yMin = Infinity;
        series.forEach(s => {
            s.data.forEach(v => {
                if (v > 0) yMin = Math.min(yMin, Math.log10(v));
            });
        });
        if (!Number.isFinite(yMin)) yMin = -4;
    }
    if (!Number.isFinite(yMax)) {
        yMax = useLogScale ? 0 : 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(0.1, Math.abs(yMin) * 0.1);
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;
    
    // Get sliced weights for the view
    const viewWeights = hasData ? history.weights.slice(viewStartIdx, viewEndIdx) : [];
    
    // Y axis range for weights (separate right axis)
    let wMin = Infinity;
    let wMax = -Infinity;
    if (showWeights && viewWeights.length > 0) {
        viewWeights.forEach(wArr => {
            wArr.forEach(v => {
                if (Number.isFinite(v)) {
                    wMin = Math.min(wMin, v);
                    wMax = Math.max(wMax, v);
                }
            });
        });
    }
    if (!Number.isFinite(wMin) || !Number.isFinite(wMax)) {
        wMin = -2;
        wMax = 2;
    }
    if (wMin === wMax) {
        wMin -= 1;
        wMax += 1;
    } else {
        const wPad = 0.1 * (wMax - wMin);
        wMin -= wPad;
        wMax += wPad;
    }
    const wRange = wMax - wMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) => {
        const v = useLogScale ? Math.log10(Math.max(val, 1e-10)) : val;
        return h - paddingBottom - ((v - yMin) / yRange) * plotHeight;
    };

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicks = getNiceTicks(stepMin, stepMax, 5);
    xTicks.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values (log scale uses powers of 10)
    ctx.textAlign = 'right';
    const yTicks = useLogScale ? getLogTicks(yMin, yMax) : getNiceTicks(yMin, yMax, 5);
    yTicks.forEach(yVal => {
        if (yVal < yMin || yVal > yMax) return;
        const y = h - paddingBottom - ((yVal - yMin) / yRange) * plotHeight;
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        if (useLogScale) {
            const realVal = Math.pow(10, yVal);
            // Format as power of 10: 10^-2 shows as "0.01", 10^-3 as "0.001" etc.
            if (Number.isInteger(yVal)) {
                ctx.fillText(realVal.toExponential(0), paddingLeft - 4, y + 3);
            } else {
                ctx.fillText(realVal.toPrecision(2), paddingLeft - 4, y + 3);
            }
        } else {
            ctx.fillText(yVal.toPrecision(3), paddingLeft - 4, y + 3);
        }
    });

    // Axis labels
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(useLogScale ? 'Loss (log‚ÇÅ‚ÇÄ)' : 'Loss (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Draw loss series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        if (s.dashed) {
            ctx.setLineDash([5, 3]);
        } else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < s.data.length; i++) {
            const val = s.data[i];
            if (!Number.isFinite(val) || (useLogScale && val <= 0)) continue;
            const x = toX(s.steps[i]);
            const y = toY(val);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    });

    // Draw weight traces (on right Y axis)
    if (showWeights && viewWeights && viewWeights.length > 0) {
        const numWeights = viewWeights[0].length;
        const weightColors = ['#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#ff7f0e', '#2ca02c'];
        
        // Use pre-calculated weight range from earlier
        const toWY = (val) => h - paddingBottom - ((val - wMin) / wRange) * plotHeight;
        
        // Draw right axis tick marks and labels for weights - use nice values
        ctx.textAlign = 'left';
        ctx.font = '9px sans-serif';
        const wTicks = getNiceTicks(wMin, wMax, 5);
        wTicks.forEach(wVal => {
            if (wVal < wMin || wVal > wMax) return;
            const y = h - paddingBottom - ((wVal - wMin) / wRange) * plotHeight;
            // Tick mark
            ctx.strokeStyle = '#9467bd';
            ctx.beginPath();
            ctx.moveTo(w - paddingRight, y);
            ctx.lineTo(w - paddingRight + 5, y);
            ctx.stroke();
            // Label
            ctx.fillStyle = '#9467bd';
            ctx.fillText(wVal.toFixed(1), w - paddingRight + 8, y + 3);
        });
        
        // Draw weight lines
        for (let wi = 0; wi < Math.min(numWeights, 8); wi++) {
            ctx.strokeStyle = weightColors[wi % weightColors.length];
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < viewWeights.length; i++) {
                const x = toX(viewSteps[i]);
                const y = toWY(viewWeights[i][wi]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        
        // Right axis label
        ctx.save();
        ctx.translate(w - 5, h / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#9467bd';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Weights', 0, 0);
        ctx.restore();
    }
}

    // Loss surface visualization
    let lossSurfaceCache = null;
    let lossSurfaceWeightIndices = [0, 1];
    let lossSurfaceTrail = [];  // Trail of weight positions during training
    let lossSurfaceStartPosition = null;  // Store starting position separately
    let lossSurfaceAutoUpdate = true;  // Auto-update every N steps
    let lossSurfaceUpdateInterval = 50;  // Update every 50 steps
    let lossLandscapeAutoMode = true;  // Auto-select weights by default
    
    function populateWeightSelectors() {
        const selectX = document.getElementById('weightXSelect');
        const selectY = document.getElementById('weightYSelect');
        if (!selectX || !selectY) return;
        
        // Build list of all weights with descriptive names and categories
        const weightNames = [];
        let idx = 0;
        
        // First layer: input -> hidden (category: 'input')
        for (let i = 0; i < network.hiddenSize; i++) {
            weightNames.push({ idx: idx++, name: `w(x‚Üíh‚ÇÅ${i+1})`, category: 'input', neuron: i });
        }
        
        // Hidden -> hidden layers (category: 'hidden')
        for (let l = 1; l < network.numLayers; l++) {
            for (let i = 0; i < network.hiddenSize; i++) {
                for (let j = 0; j < network.hiddenSize; j++) {
                    weightNames.push({ idx: idx++, name: `w(h${l}${j+1}‚Üíh${l+1}${i+1})`, category: 'hidden', layer: l });
                }
            }
        }
        
        // Output layer (category: 'output')
        for (let i = 0; i < network.hiddenSize; i++) {
            weightNames.push({ idx: idx++, name: `v(h${network.numLayers}${i+1}‚Üí≈∑)`, category: 'output', neuron: i });
        }
        
        // Populate selectors
        selectX.innerHTML = '';
        selectY.innerHTML = '';
        
        weightNames.forEach(w => {
            const optX = document.createElement('option');
            optX.value = w.idx;
            optX.textContent = w.name;
            selectX.appendChild(optX);
            
            const optY = document.createElement('option');
            optY.value = w.idx;
            optY.textContent = w.name;
            selectY.appendChild(optY);
        });
        
        // Auto-select interesting weights:
        // Pick one from input layer and one from output layer for maximum independence
        const inputWeights = weightNames.filter(w => w.category === 'input');
        const outputWeights = weightNames.filter(w => w.category === 'output');
        
        let bestPair = [0, 1];
        
        if (inputWeights.length > 0 && outputWeights.length > 0) {
            // Pick first input weight and first output weight (different layers = more interesting)
            bestPair = [inputWeights[0].idx, outputWeights[0].idx];
        } else if (weightNames.length >= 2) {
            // Fallback: pick weights from different neurons
            bestPair = [0, Math.min(1, weightNames.length - 1)];
        }
        
        selectX.value = bestPair[0].toString();
        selectY.value = bestPair[1].toString();
        lossSurfaceWeightIndices = bestPair;
    }
    
    // Find the most "interesting" pair of weights by sampling loss variance
    function autoSelectInterestingWeights() {
        try {
            const selectX = document.getElementById('weightXSelect');
            const selectY = document.getElementById('weightYSelect');
            if (!selectX || !selectY) {
                console.log('Weight selectors not found');
                return;
            }
            
            const numWeights = selectX.options.length;
            if (numWeights < 2) {
                console.log('Not enough weights:', numWeights);
                // Just use first two weights as default
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
                return;
            }
            
            // Simple approach: just pick first input weight and first output weight
            // This is more robust for different network sizes
            const H = network.hiddenSize;
            const L = network.numLayers;
            
            // First weight (input to first hidden)
            const idx1 = 0;
            // Last weight (last hidden to output) - approximate
            const idx2 = Math.min(numWeights - 1, H);
            
            if (idx1 !== idx2 && idx2 < numWeights) {
                lossSurfaceWeightIndices = [idx1, idx2];
            } else {
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
            }
            
            selectX.value = lossSurfaceWeightIndices[0].toString();
            selectY.value = lossSurfaceWeightIndices[1].toString();
            lossSurfaceCache = null;
            lossSurfaceTrail = [];
            console.log('Auto-selected weights:', lossSurfaceWeightIndices);
        } catch(e) {
            console.error('autoSelectInterestingWeights error:', e);
            // Fallback to default
            lossSurfaceWeightIndices = [0, 1];
        }
    }
    
    function getWeightByIndex(idx) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            return network.weights[0][idx];
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                return network.weights[l][i][j];
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            return network.weights[network.weights.length - 1][outIdx];
        }
        
        return 0;
    }
    
    function setWeightByIndex(idx, value) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            network.weights[0][idx] = value;
            return;
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                network.weights[l][i][j] = value;
                return;
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            network.weights[network.weights.length - 1][outIdx] = value;
        }
    }
    
    function computeLossSurface() {
        const resolution = 60;  // 60x60 grid for finer detail
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Save current weights
        const savedWX = getWeightByIndex(idxX);
        const savedWY = getWeightByIndex(idxY);
        
        // Determine range - include all trail points plus current position with padding
        let minX = savedWX, maxX = savedWX;
        let minY = savedWY, maxY = savedWY;
        
        // Include start position
        if (lossSurfaceStartPosition) {
            minX = Math.min(minX, lossSurfaceStartPosition.x);
            maxX = Math.max(maxX, lossSurfaceStartPosition.x);
            minY = Math.min(minY, lossSurfaceStartPosition.y);
            maxY = Math.max(maxY, lossSurfaceStartPosition.y);
        }
        
        // Include all trail points
        for (const pt of lossSurfaceTrail) {
            minX = Math.min(minX, pt.x);
            maxX = Math.max(maxX, pt.x);
            minY = Math.min(minY, pt.y);
            maxY = Math.max(maxY, pt.y);
        }
        
        // Add padding (20% on each side, minimum ¬±2 range)
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;
        const padX = Math.max(2, rangeX * 0.2);
        const padY = Math.max(2, rangeY * 0.2);
        minX -= padX;
        maxX += padX;
        minY -= padY;
        maxY += padY;
        
        // Sample training points for loss calculation
        const numSamples = 20;
        const samples = [];
        for (let i = 0; i < numSamples; i++) {
            const x = config.xMin + Math.random() * (config.xMax - config.xMin);
            let y;
            try { y = config.targetFunc(x); } catch { y = 0; }
            samples.push({ x, y });
        }
        
        // Compute loss grid
        const grid = [];
        let minLoss = Infinity, maxLoss = -Infinity;
        
        for (let iy = 0; iy < resolution; iy++) {
            const row = [];
            const wy = minY + (iy / (resolution - 1)) * (maxY - minY);
            
            for (let ix = 0; ix < resolution; ix++) {
                const wx = minX + (ix / (resolution - 1)) * (maxX - minX);
                
                // Set weights
                setWeightByIndex(idxX, wx);
                setWeightByIndex(idxY, wy);
                
                // Compute average loss over samples
                let totalLoss = 0;
                for (const sample of samples) {
                    const fwd = forward(sample.x);
                    const error = fwd.yhat - sample.y;
                    totalLoss += 0.5 * error * error;
                }
                const avgLoss = totalLoss / numSamples;
                
                row.push(avgLoss);
                if (avgLoss < minLoss) minLoss = avgLoss;
                if (avgLoss > maxLoss) maxLoss = avgLoss;
            }
            grid.push(row);
        }
        
        // Restore weights
        setWeightByIndex(idxX, savedWX);
        setWeightByIndex(idxY, savedWY);
        
        lossSurfaceCache = {
            grid, minLoss, maxLoss, minX, maxX, minY, maxY, resolution,
            currentX: savedWX, currentY: savedWY
        };
    }
    
    function drawLossSurface() {
        const canvas = document.getElementById('lossCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 45;
        const paddingRight = 35;
        const paddingTop = 20;
        const paddingBottom = 25;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const plotW = w - paddingLeft - paddingRight;
        const plotH = h - paddingTop - paddingBottom;
        
        if (!lossSurfaceCache) {
            // Draw placeholder axes and message
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, h - paddingBottom);
            ctx.lineTo(w - paddingRight, h - paddingBottom);
            ctx.stroke();
            
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Computing...', w/2, h/2);
            return;
        }
        
        const { grid, minLoss, maxLoss, minX, maxX, minY, maxY, resolution } = lossSurfaceCache;
        const cellW = plotW / resolution;
        const cellH = plotH / resolution;
        
        // Fixed logarithmic color scale for consistent comparisons
        // Maps loss 0.001 (deep blue) to 10.0 (deep red)
        const fixedMinLog = Math.log10(0.001);  // -3
        const fixedMaxLog = Math.log10(10);      // 1
        const fixedLogRange = fixedMaxLog - fixedMinLog;  // 4 decades
        
        for (let iy = 0; iy < resolution; iy++) {
            for (let ix = 0; ix < resolution; ix++) {
                const loss = grid[iy][ix];
                
                // Fixed log scale normalization (0 = loss 0.001, 1 = loss 10)
                const clampedLoss = Math.max(0.001, Math.min(10, loss));
                const logLoss = Math.log10(clampedLoss);
                const normLoss = (logLoss - fixedMinLog) / fixedLogRange;
                
                // Smooth HSL-based gradient with more color resolution
                // Hue: 240 (blue) ‚Üí 180 (cyan) ‚Üí 120 (green) ‚Üí 60 (yellow) ‚Üí 0 (red)
                const hue = 240 * (1 - normLoss);  // Blue to red
                const sat = 85 + 15 * Math.sin(normLoss * Math.PI);  // Slight saturation boost in middle
                const light = 35 + 25 * (1 - Math.abs(normLoss - 0.5) * 2);  // Brighter in middle
                
                ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                const px = paddingLeft + ix * cellW;
                const py = paddingTop + (resolution - 1 - iy) * cellH;
                ctx.fillRect(px, py, cellW + 1, cellH + 1);
            }
        }
        
        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotW, plotH);
        
        // Helper to convert weight values to canvas coordinates
        const toCanvasX = (wx) => paddingLeft + ((wx - minX) / (maxX - minX)) * plotW;
        const toCanvasY = (wy) => paddingTop + (1 - (wy - minY) / (maxY - minY)) * plotH;
        
        // Check for comparison mode - only valid if network architecture, activation, and target are the same
        // (comparing optimizer or learning rate differences makes sense, but different architectures don't share a loss landscape)
        function canCompareLossLandscapes() {
            if (!comparisonModeActive || !savedRuns.A || !savedRuns.B) return false;
            const cfgA = savedRuns.A.config;
            const cfgB = savedRuns.B.config;
            
            // Must have same architecture
            if (cfgA.numLayers !== cfgB.numLayers) return false;
            if (cfgA.hiddenSize !== cfgB.hiddenSize) return false;
            
            // Must have same activation (changes landscape shape)
            if (cfgA.activation !== cfgB.activation) return false;
            
            // Must have same target function
            if (cfgA.targetFuncStr !== cfgB.targetFuncStr) return false;
            
            // Must have saved trails with same weight indices
            if (!savedRuns.A.lossSurfaceTrail || !savedRuns.B.lossSurfaceTrail) return false;
            if (!savedRuns.A.lossSurfaceWeightIndices || !savedRuns.B.lossSurfaceWeightIndices) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[0] !== savedRuns.B.lossSurfaceWeightIndices[0]) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[1] !== savedRuns.B.lossSurfaceWeightIndices[1]) return false;
            
            return true;
        }
        
        const inComparisonMode = canCompareLossLandscapes();
        
        // Helper to draw a trail
        function drawTrail(trail, color, alpha = 0.85) {
            if (!trail || trail.length < 2) return;
            ctx.strokeStyle = color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trail[0].x), toCanvasY(trail[0].y));
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(toCanvasX(trail[i].x), toCanvasY(trail[i].y));
            }
            ctx.stroke();
        }
        
        if (inComparisonMode) {
            // Draw Run A trail (red/orange)
            if (savedRuns.A.lossSurfaceTrail) {
                drawTrail(savedRuns.A.lossSurfaceTrail, 'rgb(220, 53, 69)', 0.9);
                // Start marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const startA = savedRuns.A.lossSurfaceTrail[0];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startA.x), toCanvasY(startA.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const endA = savedRuns.A.lossSurfaceTrail[savedRuns.A.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endA.x), toCanvasY(endA.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw Run B trail (cyan/teal)
            if (savedRuns.B.lossSurfaceTrail) {
                drawTrail(savedRuns.B.lossSurfaceTrail, 'rgb(0, 188, 212)', 0.9);
                // Start marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const startB = savedRuns.B.lossSurfaceTrail[0];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startB.x), toCanvasY(startB.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const endB = savedRuns.B.lossSurfaceTrail[savedRuns.B.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endB.x), toCanvasY(endB.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        } else {
            // Normal mode - single trail
            if (lossSurfaceTrail.length > 1) {
                // Draw white trail with slight transparency
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                const first = lossSurfaceTrail[0];
                ctx.moveTo(toCanvasX(first.x), toCanvasY(first.y));
                for (let i = 1; i < lossSurfaceTrail.length; i++) {
                    const pt = lossSurfaceTrail[i];
                    ctx.lineTo(toCanvasX(pt.x), toCanvasY(pt.y));
                }
                ctx.stroke();
            }
            
            // Always draw start point if we have a starting position
            if (lossSurfaceStartPosition) {
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(toCanvasX(lossSurfaceStartPosition.x), toCanvasY(lossSurfaceStartPosition.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            // Draw current position
            const currentWX = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const currentWY = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const posX = toCanvasX(currentWX);
            const posY = toCanvasY(currentWY);
            
            // Draw current marker
            ctx.fillStyle = '#dc3545';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(posX, posY, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
        
        // Axis labels
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        
        // X axis labels - just below the plot area
        const xLabelY = h - paddingBottom + 15;
        ctx.fillText(minX.toFixed(1), paddingLeft, xLabelY);
        ctx.fillText(maxX.toFixed(1), w - paddingRight, xLabelY);
        ctx.fillText('w‚ÇÅ', (paddingLeft + w - paddingRight) / 2, xLabelY);
        
        // Y axis labels - just left of the plot area
        ctx.textAlign = 'right';
        ctx.fillText(minY.toFixed(1), paddingLeft - 4, h - paddingBottom + 3);
        ctx.fillText(maxY.toFixed(1), paddingLeft - 4, paddingTop + 3);
        
        // Y axis title
        ctx.save();
        ctx.translate(12, (paddingTop + h - paddingBottom) / 2);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = 'center';
        ctx.fillText('w‚ÇÇ', 0, 0);
        ctx.restore();
    }
   
    function updateUI() {
        try {
            document.getElementById('stepCount').textContent = trainingState.step;
            const lastLoss = history.loss[history.loss.length - 1];
            const lossValue = document.getElementById('lossValue');
            if (lossValue) {
                lossValue.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }

            document.getElementById('totalAdds').textContent = trainingState.totalAdds.toLocaleString();
            document.getElementById('totalMuls').textContent = trainingState.totalMuls.toLocaleString();
            
            // Update total ops display
            const totalOps = trainingState.totalAdds + trainingState.totalMuls;
            const totalOpsDisplay = document.getElementById('totalOpsDisplay');
            if (totalOpsDisplay) {
                if (totalOps >= 1e9) {
                    totalOpsDisplay.textContent = (totalOps / 1e9).toFixed(1) + 'B';
                } else if (totalOps >= 1e6) {
                    totalOpsDisplay.textContent = (totalOps / 1e6).toFixed(1) + 'M';
                } else if (totalOps >= 1e3) {
                    totalOpsDisplay.textContent = (totalOps / 1e3).toFixed(1) + 'K';
                } else {
                    totalOpsDisplay.textContent = totalOps.toString();
                }
            }
            
            // Update epoch and step counters
            const epochCountEl = document.getElementById('epochCount');
            if (epochCountEl) {
                epochCountEl.textContent = dataset.epoch;
            }
            
            // Update train/test loss displays
            const trainLossEl = document.getElementById('trainLossValue');
            const testLossEl = document.getElementById('testLossValue');
            
            if (trainLossEl) {
                trainLossEl.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }
            
            // Only show test loss after evaluation button is clicked
            if (testLossEl && history.testLoss.length > 0 && revealOptions.evaluated) {
                const lastTestLoss = history.testLoss[history.testLoss.length - 1].loss;
                testLossEl.textContent = Number.isFinite(lastTestLoss) ? lastTestLoss.toExponential(2) : '‚Äî';
                
                // Highlight overfitting: test loss > train loss significantly
                if (lastTestLoss > lastLoss * 1.5) {
                    testLossEl.style.color = '#dc3545';  // Red warning
                } else {
                    testLossEl.style.color = '#ff9800';  // Normal orange
                }
            } else if (testLossEl) {
                testLossEl.textContent = '‚Äî';
                testLossEl.style.color = '#888';
            }
            
            // Update epoch status display
            if (dataset.generated) {
                const epochStatus = document.getElementById('epochStatus');
                if (epochStatus) {
                    epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
                }
            }
            
            // Calculate delta-loss (change in rolling average over last window)
            const deltaLossEl = document.getElementById('deltaLossValue');
            if (deltaLossEl && history.avgLoss.length >= 2) {
                const windowSize = Math.min(config.avgWindow, history.avgLoss.length);
                const currentAvg = history.avgLoss[history.avgLoss.length - 1];
                const prevAvg = history.avgLoss[Math.max(0, history.avgLoss.length - windowSize)];
                const deltaLoss = currentAvg - prevAvg;
                
                if (Number.isFinite(deltaLoss)) {
                    const sign = deltaLoss > 0 ? '+' : '';
                    deltaLossEl.textContent = sign + deltaLoss.toExponential(2);
                    // Green if decreasing (good), red if increasing (bad)
                    deltaLossEl.style.color = deltaLoss <= 0 ? '#28a745' : '#dc3545';
                } else {
                    deltaLossEl.textContent = '‚Äî';
                    deltaLossEl.style.color = '#666';
                }
            }

            try { drawNetwork(); } catch(e) { console.error('drawNetwork error:', e); }
            try { drawFitPlot(); } catch(e) { console.error('drawFitPlot error:', e); }
            try { drawTrainingTrace(); } catch(e) { console.error('drawTrainingTrace error:', e); }
            try { drawLossSurface(); } catch(e) { console.error('drawLossSurface error:', e); }
            try { updateEquations(); } catch(e) { console.error('updateEquations error:', e); }
        } catch(e) {
            console.error('updateUI error:', e);
        }
    }
    
    // Track when we last auto-paused to allow continued training
    let lastAutoPauseStep = -2000;
    
    // Check if training should auto-pause (no improvement in last 1000 steps)
    function shouldAutoPause() {
        // Need at least 2000 steps before first check
        if (history.loss.length < 2000) return false;
        
        // Must run at least 1000 steps since last auto-pause before checking again
        if (trainingState.step - lastAutoPauseStep < 1000) return false;
        
        // Compute 1000-step rolling average for current window
        const windowSize = 1000;
        const currentWindow = history.loss.slice(-windowSize);
        const currentAvg = currentWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Compute 1000-step rolling average for previous window (1000 steps ago)
        const prevWindow = history.loss.slice(-2000, -1000);
        const prevAvg = prevWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Pause if current 1000-step average hasn't improved over previous 1000-step average
        if (currentAvg >= prevAvg) {
            lastAutoPauseStep = trainingState.step;
            return true;
        }
        return false;
    }

    // --------------- Wiring Controls ----------------

    function setupControls() {
        const lrSlider = document.getElementById('learningRate');
        const lrValue = document.getElementById('learningRateValue');
        lrSlider.addEventListener('input', () => {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        });
        (function initLR() {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        })();

        const noiseSlider = document.getElementById('noise');
        const noiseLabel = document.getElementById('noiseValue');
        noiseSlider.addEventListener('input', () => {
            config.noise = parseFloat(noiseSlider.value);
            noiseLabel.textContent = config.noise.toFixed(2);
        });
        config.noise = parseFloat(noiseSlider.value);
        noiseLabel.textContent = config.noise.toFixed(2);

        const numLayersSlider = document.getElementById('numLayers');
        const numLayersDisplay = document.getElementById('numLayersDisplay');
        const networkLayersDisplay = document.getElementById('networkLayersDisplay');
        numLayersSlider.addEventListener('input', () => {
            network.numLayers = parseInt(numLayersSlider.value, 10);
            if (numLayersDisplay) numLayersDisplay.textContent = network.numLayers.toString();
            if (networkLayersDisplay) networkLayersDisplay.textContent = network.numLayers.toString();
            resetModel();
            updateUI();
        });
        network.numLayers = parseInt(numLayersSlider.value, 10);
        if (numLayersDisplay) numLayersDisplay.textContent = network.numLayers.toString();

        const hiddenSizeSlider = document.getElementById('hiddenSize');
        const hiddenSizeDisplay = document.getElementById('hiddenSizeDisplay');
        const networkSizeDisplay = document.getElementById('networkSizeDisplay');
        hiddenSizeSlider.addEventListener('input', () => {
            network.hiddenSize = parseInt(hiddenSizeSlider.value, 10);
            if (hiddenSizeDisplay) hiddenSizeDisplay.textContent = network.hiddenSize.toString();
            if (networkSizeDisplay) networkSizeDisplay.textContent = network.hiddenSize.toString();
            resetModel();
            updateUI();
        });
        network.hiddenSize = parseInt(hiddenSizeSlider.value, 10);
        if (hiddenSizeDisplay) hiddenSizeDisplay.textContent = network.hiddenSize.toString();
        
        // Mobile training range controls
        const trainXMinMobile = document.getElementById('trainXMinMobile');
        const trainXMaxMobile = document.getElementById('trainXMaxMobile');
        const applyTrainRangeMobile = document.getElementById('applyTrainRangeMobile');
        if (applyTrainRangeMobile) {
            applyTrainRangeMobile.addEventListener('click', () => {
                if (!dataset.generated) return;
                const newMin = parseFloat(trainXMinMobile.value);
                const newMax = parseFloat(trainXMaxMobile.value);
                if (!isNaN(newMin) && !isNaN(newMax) && newMin < newMax) {
                    config.trainXMin = Math.max(config.dataXMin, newMin);
                    config.trainXMax = Math.min(config.dataXMax, newMax);
                    updateTrainingRangeFromConfig();
                    updateTrainingHandlePositions();
                    drawFitPlot();
                    updateUI();
                }
            });
        }
        
        // Mobile zoom control
        const zoomSliderMobile = document.getElementById('zoomSliderMobile');
        const zoomValueMobile = document.getElementById('zoomValueMobile');
        if (zoomSliderMobile) {
            zoomSliderMobile.addEventListener('input', () => {
                const maxSteps = history.steps.length;
                const zoomVal = parseInt(zoomSliderMobile.value, 10);
                if (zoomVal >= maxSteps) {
                    traceViewState.maxStep = Infinity;
                    zoomValueMobile.textContent = 'All';
                } else {
                    traceViewState.maxStep = zoomVal;
                    zoomValueMobile.textContent = zoomVal.toString();
                }
                drawTrainingTrace();
            });
        }

        const xMinSlider = document.getElementById('xMin');
        const xMaxSlider = document.getElementById('xMax');
        const xMinLabel = document.getElementById('xMinLabel');
        const xMaxLabel = document.getElementById('xMaxLabel');
        function syncXRange() {
            let minVal = parseFloat(xMinSlider.value);
            let maxVal = parseFloat(xMaxSlider.value);
            if (minVal >= maxVal) {
                if (this === xMinSlider) {
                    minVal = maxVal - 0.1;
                    xMinSlider.value = minVal.toString();
                } else {
                    maxVal = minVal + 0.1;
                    xMaxSlider.value = maxVal.toString();
                }
            }
            config.xMin = minVal;
            config.xMax = maxVal;
            xMinLabel.textContent = minVal.toFixed(1);
            xMaxLabel.textContent = maxVal.toFixed(1);
        }
        xMinSlider.addEventListener('input', syncXRange);
        xMaxSlider.addEventListener('input', syncXRange);
        config.xMin = parseFloat(xMinSlider.value);
        config.xMax = parseFloat(xMaxSlider.value);

        // Mobile x-range sliders
        const xMinMobile = document.getElementById('xMinMobile');
        const xMaxMobile = document.getElementById('xMaxMobile');
        const xMinMobileVal = document.getElementById('xMinMobileVal');
        const xMaxMobileVal = document.getElementById('xMaxMobileVal');
        if (xMinMobile && xMaxMobile) {
            xMinMobile.addEventListener('input', () => {
                config.xMin = parseFloat(xMinMobile.value);
                xMinMobileVal.textContent = config.xMin.toFixed(1);
                xMinSlider.value = config.xMin;
                drawFitPlot();
            });
            xMaxMobile.addEventListener('input', () => {
                config.xMax = parseFloat(xMaxMobile.value);
                xMaxMobileVal.textContent = config.xMax.toFixed(1);
                xMaxSlider.value = config.xMax;
                drawFitPlot();
            });
        }

        const targetFuncInput = document.getElementById('targetFuncInput');
        targetFuncInput.addEventListener('change', () => {
            compileTargetFunc();
            drawFitPlot();  // Update preview
        });
        targetFuncInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                compileTargetFunc();
                drawFitPlot();
            }
        });
        
        // Phase 1: Data generation controls
        const totalSamplesSlider = document.getElementById('totalSamples');
        const totalSamplesValue = document.getElementById('totalSamplesValue');
        if (totalSamplesSlider && totalSamplesValue) {
            totalSamplesSlider.addEventListener('input', () => {
                config.totalSamples = parseInt(totalSamplesSlider.value);
                totalSamplesValue.textContent = config.totalSamples;
            });
            config.totalSamples = parseInt(totalSamplesSlider.value);
        }
        
        // Data Range inputs for Phase 1
        const dataXMinInput = document.getElementById('dataXMinInput');
        const dataXMaxInput = document.getElementById('dataXMaxInput');
        const trainXMinInput = document.getElementById('trainXMinInput');
        const trainXMaxInput = document.getElementById('trainXMaxInput');
        
        if (dataXMinInput && dataXMaxInput) {
            dataXMinInput.addEventListener('change', () => {
                config.dataXMin = parseFloat(dataXMinInput.value);
                config.xMin = config.dataXMin;
                // Ensure train range is within data range
                if (config.trainXMin < config.dataXMin) {
                    config.trainXMin = config.dataXMin;
                    trainXMinInput.value = config.trainXMin;
                }
                drawFitPlot();
            });
            dataXMaxInput.addEventListener('change', () => {
                config.dataXMax = parseFloat(dataXMaxInput.value);
                config.xMax = config.dataXMax;
                // Ensure train range is within data range
                if (config.trainXMax > config.dataXMax) {
                    config.trainXMax = config.dataXMax;
                    trainXMaxInput.value = config.trainXMax;
                }
                drawFitPlot();
            });
            config.dataXMin = parseFloat(dataXMinInput.value);
            config.dataXMax = parseFloat(dataXMaxInput.value);
            config.xMin = config.dataXMin;
            config.xMax = config.dataXMax;
        }
        
        if (trainXMinInput && trainXMaxInput) {
            trainXMinInput.addEventListener('change', () => {
                config.trainXMin = parseFloat(trainXMinInput.value);
                // Clamp to data range
                config.trainXMin = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMin));
                trainXMinInput.value = config.trainXMin;
                drawFitPlot();
            });
            trainXMaxInput.addEventListener('change', () => {
                config.trainXMax = parseFloat(trainXMaxInput.value);
                // Clamp to data range
                config.trainXMax = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMax));
                trainXMaxInput.value = config.trainXMax;
                drawFitPlot();
            });
            config.trainXMin = parseFloat(trainXMinInput.value);
            config.trainXMax = parseFloat(trainXMaxInput.value);
        }
        
        // Evaluate button
        const evaluateBtn = document.getElementById('evaluateBtn');
        const evalResults = document.getElementById('evalResults');
        if (evaluateBtn) {
            evaluateBtn.addEventListener('click', () => {
                if (!dataset.generated) {
                    alert('Generate training data first!');
                    return;
                }
                
                const results = runEvaluation();
                
                if (results && evalResults) {
                    let resultText = `Total: ${results.testLossTotal.toFixed(4)}`;
                    if (results.pointsInRange > 0) {
                        resultText += ` | In-range: ${results.testLossInRange.toFixed(4)}`;
                    }
                    if (results.pointsOutRange > 0) {
                        resultText += ` | Out-range: ${results.testLossOutRange.toFixed(4)}`;
                        // Highlight if extrapolation is much worse
                        if (results.testLossOutRange > results.testLossInRange * 2) {
                            resultText += ' ‚ö†Ô∏è';
                        }
                    }
                    evalResults.textContent = resultText;
                    evalResults.style.display = 'inline';
                    evalResults.style.color = '#ff9800';
                }
                
                updateUI();
            });
        }
        
        // Generate Data button
        const generateDataBtn = document.getElementById('generateDataBtn');
        if (generateDataBtn) {
            generateDataBtn.addEventListener('click', () => {
                compileTargetFunc();
                
                // Set training range to 95% of data range (hints at restriction possibility)
                const dataRange = config.dataXMax - config.dataXMin;
                const margin = dataRange * 0.025;  // 2.5% margin on each side
                config.trainXMin = Math.round((config.dataXMin + margin) * 100) / 100;
                config.trainXMax = Math.round((config.dataXMax - margin) * 100) / 100;
                document.getElementById('trainXMinInput').value = config.trainXMin;
                document.getElementById('trainXMaxInput').value = config.trainXMax;
                
                generateDataset();
                resetModel();  // Initialize model for new data
                updateUI();
            });
        }
        
        // New Data button (returns to Phase 1)
        const newDataBtn = document.getElementById('newDataBtn');
        if (newDataBtn) {
            newDataBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger header toggle
                clearDataset();
                updateUI();
            });
        }
        
        // Data summary accordion toggle
        const dataSummaryHeader = document.getElementById('dataSummaryHeader');
        if (dataSummaryHeader) {
            dataSummaryHeader.addEventListener('click', (e) => {
                // Don't toggle if clicking the New button
                if (e.target.id === 'newDataBtn') return;
                
                const content = document.getElementById('dataSummaryContent');
                const toggle = document.getElementById('dataSummaryToggle');
                if (content && toggle) {
                    const isHidden = content.style.display === 'none';
                    content.style.display = isHidden ? 'block' : 'none';
                    toggle.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                }
            });
        }
        
        // Learning Guide sidebar toggle (sidebar is visible by default)
        const guideToggle = document.getElementById('guideToggle');
        const guideSidebar = document.getElementById('guideSidebar');
        
        if (guideToggle && guideSidebar) {
            guideToggle.addEventListener('click', () => {
                const isHidden = guideSidebar.style.display === 'none';
                guideSidebar.style.display = isHidden ? '' : 'none';  // Use '' to restore default flex behavior
                guideToggle.style.background = isHidden ? '#138496' : '#17a2b8';
                guideToggle.textContent = isHidden ? 'Hide Guide ‚óÄ' : 'üìñ Show Guide';
            });
        }
        
        // Reset Model button (keeps data, reinitializes weights)
        const resetModelBtn = document.getElementById('resetModelBtn');
        if (resetModelBtn) {
            resetModelBtn.addEventListener('click', () => {
                resetModel();
                document.getElementById('runBtn').textContent = 'Run';
                updateUI();
            });
        }
        
        // Run Epoch button
        const runEpochBtn = document.getElementById('runEpochBtn');
        if (runEpochBtn) {
            runEpochBtn.addEventListener('click', async () => {
                if (!dataset.generated) {
                    alert('Generate examples first!');
                    return;
                }
                
                exitComparisonMode();
                runEpochBtn.disabled = true;
                runEpochBtn.textContent = 'Running...';
                
                // Run one complete epoch
                const stepsPerEpoch = dataset.train.length;
                const startStep = dataset.stepInEpoch;
                const stepsRemaining = stepsPerEpoch - startStep;
                
                for (let i = 0; i < stepsRemaining; i++) {
                    trainStep();
                    
                    // Update UI periodically
                    if (i % 10 === 0) {
                        updateUI();
                        await new Promise(r => setTimeout(r, 0));  // Allow UI to update
                    }
                }
                
                runEpochBtn.disabled = false;
                runEpochBtn.textContent = 'Run Epoch';
                updateUI();
            });
        }
        
        // Reveal controls (Assessment phase)
        const showHeldOutCheckbox = document.getElementById('showHeldOut');
        const showRecipeCheckbox = document.getElementById('showRecipe');
        
        if (showHeldOutCheckbox) {
            showHeldOutCheckbox.addEventListener('change', () => {
                revealOptions.showHeldOut = showHeldOutCheckbox.checked;
                drawFitPlot();
                // Also evaluate test loss when revealing held-out
                if (revealOptions.showHeldOut && dataset.generated) {
                    const testLoss = computeTestLoss();
                    if (history.testLoss.length === 0 || 
                        history.testLoss[history.testLoss.length - 1].step !== trainingState.step) {
                        history.testLoss.push({ step: trainingState.step, loss: testLoss });
                    }
                    updateUI();
                }
            });
        }
        
        if (showRecipeCheckbox) {
            showRecipeCheckbox.addEventListener('change', () => {
                revealOptions.showRecipe = showRecipeCheckbox.checked;
                drawFitPlot();
            });
        }
        
        // Recipe accordion toggle
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        const recipeControls = document.getElementById('recipeControls');
        if (toggleRecipeBtn && recipeControls) {
            toggleRecipeBtn.addEventListener('click', () => {
                const isHidden = recipeControls.style.display === 'none';
                recipeControls.style.display = isHidden ? 'flex' : 'none';
                recipeControls.style.opacity = isHidden ? '1' : '0.6';  // Bright when editing
                toggleRecipeBtn.textContent = isHidden ? '‚ñº Hide Recipe' : '‚úèÔ∏è Edit Recipe';
            });
        }
        
        // View full data button
        const viewFullDataBtn = document.getElementById('viewFullDataBtn');
        if (viewFullDataBtn) {
            viewFullDataBtn.addEventListener('click', showFullDataView);
        }
        
        // Equations accordion toggle
        const toggleEquationsBtn = document.getElementById('toggleEquationsBtn');
        const equationsDiv = document.getElementById('equationsDiv');
        const equationsHeader = document.getElementById('equationsHeader');
        
        if (toggleEquationsBtn && equationsDiv) {
            const toggleEquations = () => {
                const isHidden = equationsDiv.style.display === 'none';
                equationsDiv.style.display = isHidden ? 'grid' : 'none';
                toggleEquationsBtn.textContent = isHidden ? '‚ñº Collapse' : '‚ñ∂ Expand';
            };
            
            toggleEquationsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleEquations();
            });
            
            // Also allow clicking on the header
            if (equationsHeader) {
                equationsHeader.addEventListener('click', toggleEquations);
            }
            
            // Start collapsed on mobile/tablet (sidebar is at bottom, want it visible)
            if (window.innerWidth <= 768) {
                equationsDiv.style.display = 'none';
                toggleEquationsBtn.textContent = '‚ñ∂ Expand';
            }
        }

        const activationSelector = document.getElementById('activationSelector');
        activationSelector.addEventListener('click', (e) => {
            if (!e.target.classList.contains('activation-option')) return;
            const options = activationSelector.querySelectorAll('.activation-option');
            options.forEach(opt => opt.classList.remove('selected'));
            e.target.classList.add('selected');
            config.activation = e.target.dataset.act;
            updateUI();
        });

        // Optimizer buttons
        document.querySelectorAll('#optimizerButtons .opt-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#optimizerButtons .opt-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                
                // Update config
                config.optimizer = btn.dataset.opt;
                
                // Auto-adjust learning rate for optimizer
                // Adam works best with lower learning rates (0.001-0.01)
                // Simple SGD works with higher rates (0.01-0.1)
                const lrSlider = document.getElementById('learningRate');
                const lrValue = document.getElementById('learningRateValue');
                if (btn.dataset.opt === 'adam' && config.learningRate > 0.02) {
                    // Lower the learning rate for Adam
                    config.learningRate = 0.01;
                    lrSlider.value = Math.log10(0.01);
                    lrValue.textContent = '0.010';
                } else if (btn.dataset.opt === 'sgd' && config.learningRate < 0.05) {
                    // Raise the learning rate for SGD
                    config.learningRate = 0.1;
                    lrSlider.value = Math.log10(0.1);
                    lrValue.textContent = '0.100';
                }
                
                initializeOptimizerState();
                updateUI();
            });
        });

        const gifBtnEl = document.getElementById('gifBtn');
        // Set button label based on whether GIF capture is available
        gifBtnEl.textContent = canUseGifWorkers() ? 'Capture GIF' : 'Screenshot';
        gifBtnEl.title = canUseGifWorkers() 
            ? 'Record an animated GIF of training convergence' 
            : 'Save a PNG screenshot (run from web server for animated GIF)';
        gifBtnEl.addEventListener('click', () => {
            startGifCapture();
        });

        const saveRunABtn = document.getElementById('saveRunA');
        const saveRunBBtn = document.getElementById('saveRunB');
        const compareBtn = document.getElementById('compareBtn');
        
        saveRunABtn.addEventListener('click', () => saveRun('A'));
        saveRunBBtn.addEventListener('click', () => saveRun('B'));
        
        compareBtn.addEventListener('click', () => {
            if (savedRuns.A && savedRuns.B) {
                comparisonModeActive = !comparisonModeActive;
                // Toggle button appearance
                if (comparisonModeActive) {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#0056b3; color:white; border:1px solid #0056b3; cursor:pointer;';
                    compareBtn.textContent = '‚úì Comparing A vs B';
                } else {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
                    compareBtn.textContent = 'Compare A vs B';
                }
                updateUI();
            }
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            exitComparisonMode();  // Exit comparison when stepping
            animatedStep();
        });

        document.getElementById('runBtn').addEventListener('click', () => {
            trainingState.running = !trainingState.running;
            const btn = document.getElementById('runBtn');
            btn.textContent = trainingState.running ? 'Pause' : 'Run';
            trainingState.lastUpdateTime = performance.now();
            if (trainingState.running) {
                exitComparisonMode();  // Exit comparison when running
                requestAnimationFrame(runLoop);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('runBtn').textContent = 'Run';
            reset();
        });

        document.getElementById('traceLoss').addEventListener('change', updateUI);
        document.getElementById('traceAvgLoss').addEventListener('change', updateUI);
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        document.getElementById('traceLogScale').addEventListener('change', updateUI);
        
        // Loss surface controls
        const weightXSelect = document.getElementById('weightXSelect');
        const weightYSelect = document.getElementById('weightYSelect');
        
        // Auto mode for loss landscape (uses global lossLandscapeAutoMode)
        const weightSelectContainer = document.getElementById('weightSelectContainer');
        
        function setAutoMode(enabled) {
            lossLandscapeAutoMode = enabled;
            if (weightSelectContainer) weightSelectContainer.style.opacity = enabled ? '0.5' : '1';
            if (autoSelectBtn) {
                autoSelectBtn.style.background = enabled ? '#007bff' : '#6c757d';
                autoSelectBtn.style.borderColor = enabled ? '#007bff' : '#6c757d';
            }
        }
        
        if (weightXSelect && weightYSelect) {
            weightXSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[0] = parseInt(weightXSelect.value);
                lossSurfaceCache = null;  // Invalidate cache
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
            weightYSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[1] = parseInt(weightYSelect.value);
                lossSurfaceCache = null;
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
        }
        
        const autoSelectBtn = document.getElementById('autoSelectBtn');
        if (autoSelectBtn) {
            autoSelectBtn.addEventListener('click', () => {
                setAutoMode(true);  // Re-enter auto mode
                autoSelectBtn.textContent = '...';
                setTimeout(() => {
                    autoSelectInterestingWeights();
                    computeLossSurface();
                    drawLossSurface();
                    drawNetwork();  // Update highlight boxes
                    autoSelectBtn.textContent = 'Auto';
                }, 10);
            });
        }
        
        // Rolling average window slider
        const avgWindowSlider = document.getElementById('avgWindowSlider');
        const avgWindowValue = document.getElementById('avgWindowValue');
        avgWindowSlider.addEventListener('input', () => {
            config.avgWindow = parseInt(avgWindowSlider.value);
            avgWindowValue.textContent = config.avgWindow;
            // Recalculate all rolling averages with new window size
            history.avgLoss = [];
            const minPointsForAvg = 10;
            for (let i = 0; i < history.loss.length; i++) {
                if (i + 1 < minPointsForAvg) {
                    history.avgLoss.push(null);  // Not enough points yet
                } else {
                    let sum = 0, count = 0;
                    for (let j = i; j >= 0 && count < config.avgWindow; j--, count++) {
                        sum += history.loss[j];
                    }
                    history.avgLoss.push(sum / Math.max(1, count));
                }
            }
            updateUI();
        });
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        
        // Activation buttons in header
        document.querySelectorAll('#activationButtons .act-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#activationButtons .act-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                    b.style.fontWeight = '500';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
                
                // Update config
                config.activation = btn.dataset.act;
                
                // Also update hidden selector for compatibility
                const options = document.querySelectorAll('#activationSelector .activation-option');
                options.forEach(opt => opt.classList.remove('selected'));
                document.querySelector(`#activationSelector .activation-option[data-act="${btn.dataset.act}"]`)?.classList.add('selected');
                
                updateUI();
            });
        });
        
        // Drag handles for layers (horizontal) and size (vertical)
        // Time-based: each tick changes value by 1
        // getLimits returns { canDecrease, canIncrease } to block movement at extremes
        setupDragHandle('layersHandle', 'horizontal', (delta) => {
            const change = delta > 0 ? 1 : -1;
            const newVal = Math.max(1, Math.min(4, network.numLayers + change));
            if (newVal !== network.numLayers) {
                network.numLayers = newVal;
                document.getElementById('numLayers').value = newVal;
                document.getElementById('numLayersValue').textContent = newVal;
                document.getElementById('networkLayersDisplay').textContent = newVal;
                resetModel();
                updateUI();
            }
        }, () => ({
            canDecrease: network.numLayers > 1,  // Can't go below 1 layer
            canIncrease: network.numLayers < 4   // Can't go above 4 layers
        }));
        
        setupDragHandle('sizeHandle', 'vertical', (delta) => {
            // Vertical: negative delta (drag up) = increase size
            const change = delta > 0 ? -1 : 1;
            const newVal = Math.max(2, Math.min(16, network.hiddenSize + change));
            if (newVal !== network.hiddenSize) {
                network.hiddenSize = newVal;
                document.getElementById('hiddenSize').value = newVal;
                document.getElementById('hiddenSizeValue').textContent = newVal;
                document.getElementById('networkSizeDisplay').textContent = newVal;
                resetModel();
                updateUI();
            }
        }, () => ({
            canDecrease: network.hiddenSize > 2,   // Can't go below 2 neurons
            canIncrease: network.hiddenSize < 16   // Can't go above 16 neurons
        }));
        
        // Training range handles - restrict training to subset of data range
        // These handles position relative to the data range boundaries
        // Handles can slide inward to restrict training, or back outward to the full data range
        setupDragHandle('trainMinHandle', 'horizontal', (delta) => {
            if (!dataset.generated) return;
            const change = delta > 0 ? 0.2 : -0.2;
            const newVal = config.trainXMin + change;
            // Can slide from data min to (trainXMax - 0.5)
            const clampedVal = Math.max(config.dataXMin, Math.min(config.trainXMax - 0.5, newVal));
            config.trainXMin = Math.round(clampedVal * 10) / 10;
            updateTrainingRangeFromConfig();
            updateTrainingHandlePositions();
            drawFitPlot();
        }, () => ({
            canDecrease: config.trainXMin > config.dataXMin,           // Can move back toward data min
            canIncrease: config.trainXMin < config.trainXMax - 0.5     // Can't overlap with trainMax
        }));
        
        setupDragHandle('trainMaxHandle', 'horizontal', (delta) => {
            if (!dataset.generated) return;
            const change = delta > 0 ? 0.2 : -0.2;
            const newVal = config.trainXMax + change;
            // Can slide from (trainXMin + 0.5) to data max
            const clampedVal = Math.max(config.trainXMin + 0.5, Math.min(config.dataXMax, newVal));
            config.trainXMax = Math.round(clampedVal * 10) / 10;
            updateTrainingRangeFromConfig();
            updateTrainingHandlePositions();
            drawFitPlot();
        }, () => ({
            canDecrease: config.trainXMax > config.trainXMin + 0.5,    // Can't overlap with trainMin
            canIncrease: config.trainXMax < config.dataXMax            // Can move back toward data max
        }));
        
        // Training Trace view handle - controls how much of the history to show
        setupDragHandle('traceViewHandle', 'horizontal', (delta) => {
            // Get total steps - works for both normal and comparison modes
            let totalSteps;
            const inCompMode = comparisonModeActive && savedRuns.A && savedRuns.B;
            if (inCompMode) {
                totalSteps = Math.max(
                    savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
                    savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
                );
            } else {
                totalSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
            }
            if (totalSteps < 10) return;
            
            // Each tick changes by ~5% of total steps
            const stepChange = Math.max(10, Math.floor(totalSteps * 0.05));
            const change = delta > 0 ? stepChange : -stepChange;
            
            if (traceViewEndStep === null) {
                traceViewEndStep = totalSteps;
            }
            
            traceViewEndStep = Math.max(100, Math.min(totalSteps, traceViewEndStep + change));
            drawTrainingTrace();
        }, () => {
            // Get total steps for bounds check
            let totalSteps;
            const inCompMode = comparisonModeActive && savedRuns.A && savedRuns.B;
            if (inCompMode) {
                totalSteps = Math.max(
                    savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
                    savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
                );
            } else {
                totalSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
            }
            return {
                canDecrease: traceViewEndStep === null || traceViewEndStep > 100,
                canIncrease: traceViewEndStep === null || traceViewEndStep < totalSteps
            };
        });
        
        // Update displays on init
        document.getElementById('networkLayersDisplay').textContent = network.numLayers;
        document.getElementById('networkSizeDisplay').textContent = network.hiddenSize;
        document.getElementById('xMinDisplay').textContent = config.xMin.toFixed(1);
        document.getElementById('xMaxDisplay').textContent = config.xMax.toFixed(1);
    }
    
    function setupDragHandle(elementId, direction, onDrag, getLimits) {
        const handle = document.getElementById(elementId);
        if (!handle) return;
        
        let startX, startY;
        let currentOffset = 0;
        let intervalId = null;
        const DEAD_ZONE = 10;  // pixels before triggering
        const INTERVAL_MS = 200;  // slower rate - 5 changes per second max
        const INCREMENT_PER_TICK = 15;  // pixels worth of change per tick
        
        const startInterval = () => {
            if (intervalId) return;
            intervalId = setInterval(() => {
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    // Check if we can move in this direction
                    const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                    const wantsIncrease = currentOffset > 0;
                    
                    // For vertical handles, up (negative offset) = increase
                    const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                    
                    if ((effectiveIncrease && limits.canIncrease) || (!effectiveIncrease && limits.canDecrease)) {
                        const sign = currentOffset > 0 ? 1 : -1;
                        onDrag(sign * INCREMENT_PER_TICK);
                    }
                }
            }, INTERVAL_MS);
        };
        
        const stopInterval = () => {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        };
        
        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            currentOffset = 0;
            
            // Disable transition during drag for immediate feedback
            handle.style.transition = 'none';
            
            const onMouseMove = (e) => {
                const rawOffset = direction === 'horizontal' ? (e.clientX - startX) : (e.clientY - startY);
                
                // Check limits and prevent visual displacement in blocked direction
                const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                const wantsIncrease = rawOffset > 0;
                const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                
                // Block displacement if at limit
                if (effectiveIncrease && !limits.canIncrease) {
                    currentOffset = direction === 'vertical' ? Math.max(0, rawOffset) : Math.min(0, rawOffset);
                } else if (!effectiveIncrease && !limits.canDecrease) {
                    currentOffset = direction === 'vertical' ? Math.min(0, rawOffset) : Math.max(0, rawOffset);
                } else {
                    currentOffset = rawOffset;
                }
                
                // Clamp visual offset to reasonable range (¬±20px)
                const clampedOffset = Math.max(-20, Math.min(20, currentOffset));
                
                // Visual feedback - move the handle
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = `translateX(calc(-50% + ${clampedOffset}px))`;
                    } else {
                        handle.style.transform = `translateX(${clampedOffset}px)`;
                    }
                } else {
                    handle.style.transform = `translateY(calc(-50% + ${clampedOffset}px))`;
                }
                
                // Start interval if displaced beyond dead zone
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    startInterval();
                } else {
                    stopInterval();
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                stopInterval();
                
                // Re-enable transition for rubberband effect
                handle.style.transition = 'transform 0.15s ease-out';
                
                // Rubberband back to original position
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = 'translateX(-50%)';
                    } else {
                        handle.style.transform = 'translateX(0)';
                    }
                } else {
                    handle.style.transform = 'translateY(-50%)';
                }
                
                currentOffset = 0;
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    // --------------- Init ----------------------------

    function init() {
        try {
            console.log('LearnCurve: initializing...');
            compileTargetFunc();
            initializeNetwork();
            setupControls();
            populateWeightSelectors();
            reset();
            console.log('LearnCurve: reset complete, drawing UI...');
            
            // Force initial draw of all UI components after reset
            requestAnimationFrame(() => {
                try {
                    drawNetwork();
                    drawFitPlot();
                    drawTrainingTrace();
                    updateEquations();
                    console.log('LearnCurve: initial draw complete');
                    
                    // Auto-compute loss surface
                    requestAnimationFrame(() => {
                        try {
                            autoSelectInterestingWeights();
                            computeLossSurface();
                            drawLossSurface();
                            console.log('LearnCurve: loss surface computed');
                        } catch(e) {
                            console.error('Loss surface error:', e);
                        }
                    });
                } catch(e) {
                    console.error('Initial draw error:', e);
                }
            });
        } catch(e) {
            console.error('Init error:', e);
        }
    }

    // Run init immediately since script is at end of body
    console.log('LearnCurve: starting init...');
    init();
</script>
</body>
</html>
