<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Interactive visualization of neural network learning. Watch a network learn to approximate any function in real-time.">
    <meta name="keywords" content="neural network, machine learning, deep learning, education, visualization, gradient descent">
    <title>LearnCurve - Interactive Neural Network Demo</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 16px;
            background: #f5f5f5;
            color: #333;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .container {
            max-width: 1700px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 10px 14px 14px 14px;
            min-height: calc(100vh - 20px);
            display: grid;
            grid-template-columns: 1fr 310px;
            gap: 16px;
            align-items: start;
        }

        #mainContent {
            grid-column: 1;
            grid-row: 1;
            min-width: 0;
        }
        
        #guideSidebar {
            grid-column: 2;
            grid-row: 1;
            position: sticky;
            top: 16px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }

        h1 {
            font-size: 22px;
            margin: 0 0 8px 0;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 10px;
            width: 100%;
            min-width: 0;
        }
        
        .controls-strip {
            grid-column: 1 / -1;
        }
        
        .viz-grid {
            display: contents;
        }

        .panel {
            background: #fafafa;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            min-width: 0;
            overflow: hidden;
        }

        .panel h2 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #444;
            border-bottom: 2px solid #007bff;
            padding-bottom: 3px;
        }

        .panel h3 {
            font-size: 14px;
            margin: 6px 0;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            font-size: 12px;
            min-width: 150px;
        }

        .control-group label {
            margin-bottom: 2px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 160px;
        }

        .control-group select,
        .control-group input[type="text"] {
            font-size: 13px;
            padding: 2px 4px;
        }

        .value {
            font-size: 11px;
            color: #777;
        }

        button {
            padding: 5px 9px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        #networkCanvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
        }

        canvas.chart {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
            touch-action: manipulation;  /* Better touch handling on mobile */
        }
        
        canvas {
            touch-action: manipulation;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
        }

        .stat-value {
            font-size: 13px;
            font-weight: bold;
        }

        .activation-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .activation-option {
            font-size: 11px;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid #ccc;
            cursor: pointer;
            background: #fff;
        }

        .activation-option.selected {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        /* ===== UNIFIED LABELED SLIDERS ===== */
        .labeled-slider {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            min-width: 0;
        }
        
        .labeled-slider .slider-label {
            font-weight: 600;
            color: #000;
            min-width: 38px;
            flex-shrink: 0;
        }
        
        .labeled-slider .slider-min,
        .labeled-slider .slider-max {
            font-size: 10px;
            color: #000;
            min-width: 14px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .labeled-slider .slider-track {
            position: relative;
            flex: 1 1 auto;
            min-width: 40px;
            height: 22px;
            display: flex;
            align-items: center;
        }
        
        .labeled-slider input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, #0d6efd 0%, #0d6efd var(--fill-percent, 50%), #ddd var(--fill-percent, 50%), #ddd 100%);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        .labeled-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 34px;
            height: 18px;
            background: #0d6efd;
            border-radius: 4px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .labeled-slider input[type="range"]::-moz-range-thumb {
            width: 34px;
            height: 18px;
            background: #0d6efd;
            border-radius: 4px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .labeled-slider input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
            background: #0b5ed7;
        }
        
        .labeled-slider .slider-value {
            position: absolute;
            top: 50%;
            left: var(--thumb-position, 50%);
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            pointer-events: none;
            text-shadow: 0 1px 1px rgba(0,0,0,0.4);
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }
        
        /* Two-thumb range slider */
        .range-slider-container {
            position: relative;
            flex: 1;
            min-width: 80px;
            height: 24px;
        }
        
        .range-slider-container .range-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            transform: translateY(-50%);
            background: #ddd;
            border-radius: 3px;
        }
        
        .range-slider-container .range-fill {
            position: absolute;
            top: 50%;
            height: 6px;
            transform: translateY(-50%);
            background: #0d6efd;
            border-radius: 3px;
        }
        
        .range-slider-container input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 24px;
            transform: translateY(-50%);
            background: transparent;
            pointer-events: none;
            z-index: 2;
        }
        
        .range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 34px;
            height: 16px;
            background: #0d6efd;
            border-radius: 3px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .range-slider-container input[type="range"]::-moz-range-thumb {
            width: 34px;
            height: 16px;
            background: #0d6efd;
            border-radius: 3px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .range-slider-container .range-value {
            position: absolute;
            top: calc(50% + 2px);
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            pointer-events: none;
            text-shadow: 0 1px 1px rgba(0,0,0,0.4);
            z-index: 3;
            white-space: nowrap;
            width: 34px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        /* Slider control strip layout */
        .slider-controls-strip {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 24px;
            padding: 4px 10px;
            background: transparent;
            margin-top: 4px;
            align-items: center;
        }
        
        .slider-controls-strip .labeled-slider {
            flex: 1;
            min-width: 140px;
            max-width: none;
        }
        
        /* Network sliders - distribute across panel width */
        #networkSliders {
            justify-content: space-between;
            padding: 2px 0;
            margin-top: 12px;
            flex-wrap: nowrap;
        }
        
        #networkSliders .labeled-slider {
            flex: 1 1 45%;
            min-width: 120px;
            max-width: 49%;
        }
        
        /* Train range slider - centered label below, hide min/max (graph shows scale) */
        #trainRangeSliderStrip {
            flex: 1;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            gap: 0;
            /* Match canvas plot area: ~50px margin on each side of 520px canvas = 9.6% */
            /* Adjust for panel padding (6px) and canvas display scaling */
            padding: 0 calc(9.6% - 2px);
            margin-top: 0;
        }
        
        #trainRangeSliderStrip .labeled-slider {
            max-width: 100%;
            flex-direction: column;
            gap: 0;
        }
        
        #trainRangeSliderStrip .slider-min,
        #trainRangeSliderStrip .slider-max {
            display: none;
        }
        
        #trainRangeSliderStrip .range-slider-container {
            width: 100%;
            order: 1;
        }
        
        #trainRangeSliderStrip .slider-label {
            text-align: center;
            min-width: auto;
            order: 2;
            margin-top: 4px;
            color: #333;
            font-weight: bold;
            font-size: 10px;
        }
        
        /* View slider styling - bright blue like others */
        .labeled-slider.view-slider input[type="range"] {
            background: linear-gradient(to right, #0d6efd 0%, #0d6efd var(--fill-percent, 100%), #ddd var(--fill-percent, 100%), #ddd 100%);
        }
        
        .labeled-slider.view-slider input[type="range"]::-webkit-slider-thumb {
            background: #0d6efd;
        }
        
        .labeled-slider.view-slider input[type="range"]::-moz-range-thumb {
            background: linear-gradient(to bottom, #28a745, #1e7e34);
        }
        
        /* Disabled state */
        .labeled-slider.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Mobile touch targets */
        @media (max-width: 768px) {
            .labeled-slider input[type="range"]::-webkit-slider-thumb {
                width: 36px;
                height: 28px;
            }
            .labeled-slider input[type="range"]::-moz-range-thumb {
                width: 36px;
                height: 28px;
            }
            .range-slider-container input[type="range"]::-webkit-slider-thumb {
                width: 40px;
                height: 24px;
            }
            .range-slider-container input[type="range"]::-moz-range-thumb {
                width: 40px;
                height: 24px;
            }
            .slider-controls-strip {
                gap: 8px 12px;
            }
            .slider-controls-strip .labeled-slider {
                min-width: 120px;
            }
        }
        /* ===== END UNIFIED SLIDERS ===== */

        .equations-panel {
            grid-column: 1 / -1;  /* Span all columns */
            flex: 1;  /* Fill remaining height */
            display: flex;
            flex-direction: column;
        }
        
        .equations-panel h2 {
            margin-bottom: 4px;
            flex-shrink: 0;
        }
        
        .equations {
            font-size: 11px;
            line-height: 1.4;
            flex: 1;
            min-height: 120px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;  /* 3 columns: Forward | Backward | Optimizer */
            gap: 8px;
        }

        .equation-block {
            padding: 6px 8px;
            background: #fafafa;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .equation-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 6px;
            font-size: 12px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 3px;
        }
        
        .equation-block .math {
            font-family: 'Georgia', serif;
            font-size: 11px;
        }

        .math {
            font-family: "Courier New", monospace;
            color: #333;
            font-size: 13px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #777;
            margin-bottom: 2px;
        }

        /* Tablet and smaller - single column layout */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
                max-width: 100%;
                grid-template-columns: 1fr 220px;
            }
            #guideSidebar {
                font-size: 9px;
                width: 220px;
            }
            .grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
            }
            .control-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .control-group {
                flex-wrap: wrap;
            }
            .equations-panel {
                grid-column: 1;  /* Single column on mobile */
            }
            .equations {
                grid-template-columns: 1fr 1fr;  /* 2 columns on tablet */
                font-size: 12px;
                max-height: 220px;
            }
        }
        
        /* Tablet portrait - sidebar moves to bottom */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
            }
            #mainContent {
                grid-row: 1;
            }
            #guideSidebar {
                grid-column: 1;
                grid-row: 2;
                width: 100%;
                max-width: 100%;
                max-height: none;
                position: static;
                margin-top: 16px;
                font-size: 11px;
            }
            #guideSidebar h3 {
                font-size: 15px;
            }
            #guideSidebar h4 {
                font-size: 13px;
            }
            #guideToggle {
                display: none;
            }
            /* Phase panel controls should stack */
            #phase1Panel > div, #phase2Panel > div {
                flex-wrap: wrap;
            }
            /* Smaller fonts for cramped controls */
            #phase1Panel, #phase2Panel, #phase3Panel {
                font-size: 11px;
            }
            #phase1Panel label, #phase2Panel label {
                font-size: 10px;
            }
        }
        
        /* iPhone and small mobile */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                max-width: 100%;
                overflow-x: hidden;
                grid-template-columns: 1fr;
            }
            #guideSidebar {
                font-size: 10px;
                padding: 10px;
                max-height: none;
            }
            #guideSidebar h3 {
                font-size: 14px;
            }
            #guideSidebar h4 {
                font-size: 12px;
            }
            h1 {
                font-size: 18px;
            }
            .subtitle {
                font-size: 11px;
                line-height: 1.4;
            }
            .panel {
                padding: 8px;
                overflow-x: auto;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
                height: auto;
            }
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
            }
            .control-group input[type="range"] {
                width: 100%;
            }
            .control-group select {
                width: 100%;
            }
            .stats {
                flex-direction: column;
                gap: 4px;
                align-items: flex-start;
            }
            button {
                padding: 8px 12px;
                font-size: 13px;
            }
            .chart-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            .checkbox-group {
                font-size: 12px;
            }
            .equations {
                grid-template-columns: 1fr;  /* Single column on small screens */
                font-size: 11px;
                max-height: 250px;
            }
            /* Old drag handles are now hidden everywhere - replaced by unified sliders */
            /* Mobile slider controls now use same unified sliders as desktop */
            /* Make activation buttons stack */
            #networkActivation {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            #networkActivation > div {
                flex-wrap: wrap;
            }
        }
    </style>
    <!-- GIF library for capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body>
<div class="container">
    <!-- Main Content Area -->
    <div id="mainContent" style="display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:6px;">
            <div>
                <h1 style="margin-bottom:2px;">LearnCurve</h1>
                <p style="margin:0; font-size:11px; color:#666;">An interactive tool for understanding how neural networks learn. ¬© 2025 Chris Rowen ‚Äî <a href="https://opensource.org/licenses/MIT" style="color:#007bff; text-decoration:none;">MIT License</a></p>
            </div>
            <button id="guideToggle" style="padding:4px 10px; font-size:11px; background:#138496; border:none; border-radius:4px; color:white; cursor:pointer; white-space:nowrap;" title="Show/hide learning guide">Hide Guide ‚óÄ</button>
        </div>

        <div class="grid">
        <!-- PHASE 1: CREATE TRAINING DATA - spans full width -->
        <div class="panel controls-strip" id="phase1Panel" style="padding:8px 12px; border-left:4px solid #28a745;">
            <div id="phase1Header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div style="display:flex; align-items:center; gap:8px;">
                    <span style="font-size:12px; font-weight:bold; color:#28a745;">‚ë† CREATE TRAINING DATA</span>
                    <button id="toggleRecipeBtn" style="padding:4px 12px; font-size:11px; background:#28a745; font-weight:bold; display:none;" title="Edit data recipe and regenerate">‚úèÔ∏è Edit Recipe</button>
                </div>
                <span id="dataStatus" style="font-size:10px; color:#555;">Define a data recipe, then generate training data</span>
            </div>
            
            <!-- Recipe Controls - single row -->
            <div id="recipeControls" style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:5px 8px; background:#f8f9fa; border-radius:4px;">
                <!-- Data Recipe -->
                <div style="display:flex; align-items:center; gap:4px;">
                    <label style="font-size:11px; font-weight:600;">Recipe:</label>
                    <input type="text" id="targetFuncInput" value="sin(x)" style="width:90px; font-size:11px; padding:3px 5px;" title="Formula for generating data" />
                </div>
                
                <!-- Data Range -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">x:</label>
                    <input type="number" id="dataXMinInput" value="-3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                    <span style="font-size:9px;">to</span>
                    <input type="number" id="dataXMaxInput" value="3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                </div>
                
                <!-- Count -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Total number of data points to generate">Samples:</label>
                    <input type="range" id="totalSamples" min="20" max="500" step="10" value="100" style="width:80px;">
                    <span class="value" id="totalSamplesValue" style="font-size:10px; min-width:24px;">100</span>
                </div>
                
                <!-- Noise -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Noise level - random variation added to y values">Noise:</label>
                    <input type="range" id="noise" min="0" max="1" step="0.01" value="0.02" style="width:80px;">
                    <span class="value" id="noiseValue" style="font-size:10px; min-width:24px;">0.02</span>
                </div>
                
                <!-- Generate Button -->
                <button id="generateDataBtn" style="padding:5px 12px; font-size:11px; background:#28a745; font-weight:bold;">üé≤ Generate</button>
            </div>
            
            <!-- Data Summary (accordion, collapsed by default after generation) -->
            <div id="dataSummary" style="display:none; background:#f0f8f0; border:1px solid #c3e6c3; border-radius:4px;">
                <!-- Summary header (always visible) -->
                <div id="dataSummaryHeader" style="display:flex; align-items:center; gap:8px; padding:4px 10px; cursor:pointer;" title="Click to show/hide data preview">
                    <span id="dataSummaryToggle" style="font-size:10px; color:#28a745;">‚ñ∂</span>
                    <span style="font-size:10px; color:#28a745; font-weight:bold;">‚úì Data Ready:</span>
                    <span style="font-size:10px; color:#333;"><span id="trainCount">80</span> training, <span id="testCount">20</span> held-out</span>
                    <span id="dataSummaryNote" style="flex:1; font-size:10px; color:#444; font-style:italic;"></span>
                    <button id="newDataBtn" style="padding:2px 6px; font-size:9px; background:#6c757d;" title="Generate new random data">‚Üª New</button>
                </div>
                <!-- Expandable data preview -->
                <div id="dataSummaryContent" style="display:none; padding:4px 10px 6px 10px; border-top:1px solid #c3e6c3;">
                    <div style="display:flex; align-items:flex-start; gap:12px;">
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#007bff; margin-bottom:2px;">üìä Training Points</div>
                            <div id="trainDataPreview" style="font-size:9px; font-family:monospace; color:#333; background:#fff; padding:2px 4px; border-radius:2px; border:1px solid #ddd; line-height:1.3;"></div>
                        </div>
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#ff9800; margin-bottom:2px;">üîí Held-Out Points</div>
                            <div id="testDataPreview" style="font-size:9px; font-family:monospace; color:#666; background:#fafafa; padding:2px 4px; border-radius:2px; border:1px solid #eee; line-height:1.3;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Hidden elements for compatibility -->
            <span id="trainRangeLabel" style="display:none;"></span>
            <span id="testRangeInfo" style="display:none;"></span>
        </div>
        
        <!-- PHASE 2: TRAIN THE MODEL - spans full width -->
        <div class="panel controls-strip" id="phase2Panel" style="padding:6px 12px; border-left:4px solid #007bff; opacity:0.5; pointer-events:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <span style="font-size:12px; font-weight:bold; color:#007bff;">‚ë° TRAIN THE MODEL</span>
                <span id="epochStatus" style="font-size:10px; color:#555;">Generate examples first...</span>
            </div>
            <!-- Row 1: Network and training parameters -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:4px;">
                <!-- Learning Rate -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Learning Rate (Œ∑):</label>
                    <input type="range" id="learningRate" min="-3" max="-0.3" step="0.01" value="-1" style="width:50px;">
                    <span class="value" id="learningRateValue" style="font-size:10px; min-width:32px;">0.100</span>
                </div>
                
                <!-- Optimizer -->
                <div id="optimizerButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Optimizer:</label>
                    <button class="opt-btn" data-opt="sgd" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer;" title="Simple Gradient Descent&#10;&#10;w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw&#10;&#10;Each weight moves opposite to its gradient, proportional to learning rate Œ∑.&#10;&#10;Recommended learning rate: 0.05-0.2&#10;Simple but can be slow or oscillate.">Simple</button>
                    <button class="opt-btn" data-opt="adam" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer;" title="Adam Optimizer&#10;&#10;Combines two ideas:&#10;‚Ä¢ Momentum: smooth out noisy gradients&#10;‚Ä¢ Adaptive rates: bigger steps for rare gradients&#10;&#10;Recommended learning rate: 0.001-0.02&#10;(Lower than Simple because Adam amplifies updates)&#10;&#10;Usually learns faster and more reliably.">Adam</button>
                </div>
                
                <!-- Activation œÉ -->
                <div id="activationButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Activation (œÉ):</label>
                    <button class="act-btn" data-act="relu" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="14" height="10" viewBox="0 0 20 14"><path d="M1 10 L10 10 L19 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>ReLU
                    </button>
                    <button class="act-btn" data-act="sigmoid" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="16" height="10" viewBox="0 0 24 14"><path d="M1 12 L4 12 Q8 12 12 7 Q16 2 20 2 L23 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>Sigmoid
                    </button>
                </div>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Stats -->
                <span style="font-size:11px; color:#28a745;">Train Error: <strong id="trainLossValue">‚Äî</strong></span>
                <span style="font-size:11px; color:#007bff;"><span id="stepsPerSec">‚Äî</span> steps/sec</span>
                <span style="color:#ddd;">|</span>
                <span style="font-size:10px; color:#555;" title="Arithmetic operations this training run">
                    Ops: <span style="color:#28a745;" id="totalAddsDisplay">0</span>+ <span style="color:#dc3545;" id="totalMulsDisplay">0</span>√ó = <strong id="totalOpsDisplay" style="color:#6f42c1;">0</strong>
                </span>
            </div>
            <!-- Hidden elements for backwards compatibility -->
            <span id="epochCount" style="display:none;">0</span>
            <span id="stepCount" style="display:none;">0</span>
            <span id="stepsPerEpoch" style="display:none;">80</span>
            
            <!-- Row 2: Training action buttons -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <!-- Training buttons -->
                <button id="stepBtn" style="padding:4px 10px; font-size:11px;" title="Train one step (process one training example)">Step</button>
                <button id="runEpochBtn" style="padding:4px 10px; font-size:11px; background:#17a2b8;" title="Run one epoch = process ALL training examples once">Run Epoch</button>
                <button id="runBtn" style="padding:4px 10px; font-size:11px;" title="Run continuous training until stopped">Run</button>
                <button id="resetModelBtn" style="padding:4px 10px; font-size:11px; background:#ffc107; color:#333;" title="Re-initialize weights randomly (keeps data)">Reset Model</button>
                <button id="gifBtn" style="padding:4px 8px; font-size:10px;">Capture</button>
            </div>
            
            <!-- Hidden elements for backwards compatibility -->
            <input type="range" id="xMin" min="-5" max="0" step="0.1" value="-2" style="display:none;">
            <input type="range" id="xMax" min="0" max="5" step="0.1" value="2" style="display:none;">
            <span id="xMinLabel" style="display:none;">-2</span>
            <span id="xMaxLabel" style="display:none;">2</span>
            <span id="runALabel" style="display:none;"></span>
            <span id="runBLabel" style="display:none;"></span>
            <span id="totalAdds" style="display:none;">0</span>
            <span id="totalMuls" style="display:none;">0</span>
            <span id="opsLossAdd" style="display:none">0</span>
            <span id="opsLossMul" style="display:none">0</span>
            <span id="lossValue" style="display:none;">‚Äî</span>
            <button id="resetBtn" style="display:none;">Reset</button>
            <div class="activation-selector" id="activationSelector" style="display:none;">
                <span class="activation-option selected" data-act="relu">ReLU</span>
                <span class="activation-option" data-act="sigmoid">sigmoid</span>
            </div>
            <span id="numLayersValue" style="display:none;">1</span>
            <span id="hiddenSizeValue" style="display:none;">3</span>
        </div>

        <!-- 2x2 VISUALIZATION GRID -->
        <!-- Top Left: Network Design -->
        <div class="panel" style="padding:6px 6px 24px 6px; overflow:visible !important;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Network Design</h2>
                <div id="opsTableHtml" style="font-size:10px; background:#f8f9ff; border:1px solid #007bff; border-radius:3px; padding:2px 6px;">
                    <span style="color:#28a745;">Fwd:</span><span id="opsFwdAdds">0</span>+ <span id="opsFwdMuls">0</span>√ó
                    <span style="color:#dc3545; margin-left:4px;">Back:</span><span id="opsBackAdds">0</span>+ <span id="opsBackMuls">0</span>√ó
                </div>
            </div>
            <div>
                <canvas id="networkCanvas" width="520" height="280" style="width:100%;"></canvas>
            </div>
            <!-- Unified Network Sliders -->
            <div class="slider-controls-strip" id="networkSliders">
                <div class="labeled-slider" title="Number of hidden layers">
                    <span class="slider-label">Layers</span>
                    <span class="slider-min">1</span>
                    <div class="slider-track">
                        <input type="range" id="layersSlider" min="1" max="5" step="1" value="1">
                        <span class="slider-value" id="layersValue">1</span>
                    </div>
                    <span class="slider-max">5</span>
                </div>
                <div class="labeled-slider" title="Neurons per hidden layer">
                    <span class="slider-label">Width</span>
                    <span class="slider-min">1</span>
                    <div class="slider-track">
                        <input type="range" id="widthSlider" min="1" max="32" step="1" value="3">
                        <span class="slider-value" id="widthValue">3</span>
                    </div>
                    <span class="slider-max">32</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="sizeHandle" style="display:none;"></div>
            <div id="layersHandle" style="display:none;"></div>
            <div id="networkMobileControls" style="display:none;"></div>
            <span id="networkLayersDisplay" style="display:none;">1</span>
            <span id="networkSizeDisplay" style="display:none;">3</span>
            <div id="networkActivation" style="display:none;"></div>
        </div>

        <!-- Top Right: Fit Plot -->
        <div class="panel" style="padding:6px; display:flex; flex-direction:column;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Examples vs Model</h2>
                <div id="revealControls" style="display:flex; gap:6px; font-size:10px; opacity:0.5; pointer-events:none;">
                    <!-- Hidden checkbox for backwards compatibility -->
                    <input type="checkbox" id="showHeldOut" style="display:none;" checked>
                    <label style="display:flex; align-items:center; gap:2px; cursor:pointer;" title="Show original recipe curve">
                        <input type="checkbox" id="showRecipe"> Recipe
                    </label>
                </div>
            </div>
            <div>
                <canvas id="fitCanvas" class="chart" width="520" height="280" style="width:100%;"></canvas>
            </div>
            <!-- Unified Train Range Slider -->
            <div class="slider-controls-strip" id="trainRangeSliderStrip" style="opacity:0.5; pointer-events:none;">
                <div class="labeled-slider" style="flex:1; max-width:100%;" title="Restrict training data to this x-range. Points outside test extrapolation.">
                    <span class="slider-label">Training Range</span>
                    <span class="slider-min" id="trainRangeMinLabel">-3</span>
                    <div class="range-slider-container" id="trainRangeContainer">
                        <div class="range-track"></div>
                        <div class="range-fill" id="trainRangeFill"></div>
                        <input type="range" id="trainMinSlider" min="-3" max="3" step="0.1" value="-2.8">
                        <input type="range" id="trainMaxSlider" min="-3" max="3" step="0.1" value="2.8">
                        <span class="range-value" id="trainMinValue" style="left:25%;">-2</span>
                        <span class="range-value" id="trainMaxValue" style="left:75%;">2</span>
                    </div>
                    <span class="slider-max" id="trainRangeMaxLabel">3</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="trainMinHandle" style="display:none;"></div>
            <div id="trainMaxHandle" style="display:none;"></div>
            <div id="trainRangeControls" style="display:none;"></div>
            <div id="trainRangeMobileControls" style="display:none;"></div>
            <input type="number" id="trainXMinInput" value="-2.8" style="display:none;">
            <input type="number" id="trainXMaxInput" value="2.8" style="display:none;">
            <span id="xMinDisplay" style="display:none;">-2.0</span>
            <span id="xMaxDisplay" style="display:none;">2.0</span>
            <span id="trainPointCount" style="display:none;">‚Äî</span>
        </div>

        <!-- Bottom Left: Training Trace -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:3px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Training Trace</h2>
                <div style="display:flex; gap:5px; font-size:10px; align-items:center; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:1px;" title="Show error curve"><input type="checkbox" id="traceLoss" checked>Error</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Show weight trajectories"><input type="checkbox" id="traceWeights" checked>Weights</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Logarithmic scale"><input type="checkbox" id="traceLogScale">Log</label>
                    <span style="color:#ddd;">|</span>
                    <label style="display:flex; align-items:center; gap:1px;" title="Rolling average error"><input type="checkbox" id="traceAvgLoss" checked>Average</label>
                    <input type="range" id="avgWindowSlider" min="10" max="1000" step="10" value="100" style="width:35px;" title="Averaging window size"><span id="avgWindowValue" style="color:#007bff; min-width:22px;">100</span>
                    <span style="color:#ddd;">|</span>
                    <span style="white-space:nowrap;" title="Error change from start to now">ŒîError:<strong id="deltaLossValue" style="color:#28a745; min-width:45px;">‚Äî</strong></span>
                </div>
            </div>
            <div>
                <canvas id="traceCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
            </div>
            <!-- Unified View Slider -->
            <div class="slider-controls-strip" id="viewSliderStrip" style="opacity:0.5; pointer-events:none;">
                <div class="labeled-slider view-slider" style="flex:1; max-width:300px;" title="Show training steps from 0 to this value. Slide left to focus on initial convergence.">
                    <span class="slider-label" style="min-width:35px;">View</span>
                    <span class="slider-min">10</span>
                    <div class="slider-track">
                        <input type="range" id="viewSlider" min="10" max="1000" step="10" value="1000">
                        <span class="slider-value" id="viewValue">All</span>
                    </div>
                    <span class="slider-max">All</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="traceViewHandle" style="display:none;"></div>
            <div id="zoomMobileControls" style="display:none;"></div>
        </div>

        <!-- Bottom Right: Error Landscape -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Error Landscape</h2>
                <div style="display:flex; gap:3px; font-size:10px; align-items:center;">
                    <span id="weightSelectContainer" style="display:flex; gap:2px; align-items:center; opacity:0.5;" title="Click to manually select weights">
                        <select id="weightXSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="0">w‚ÇÅ</option></select>
                        <span style="font-size:9px;">vs</span>
                        <select id="weightYSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="1">w‚ÇÇ</option></select>
                    </span>
                    <button id="autoSelectBtn" style="font-size:10px; padding:1px 4px; background:#007bff; border:2px solid #007bff; color:white;" title="Auto-select interesting weights">Auto</button>
                </div>
            </div>
            <div>
                <canvas id="lossCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
            </div>
            <div id="lossLegend" style="font-size:9px; color:#333; font-weight:500; text-align:center; margin-top:2px;">üü¢ Start üî¥ Current ‚Ä¢ <span style="background:linear-gradient(to right, #00f, #0aa, #0a0, #aa0, #f00); padding:1px 20px; border-radius:2px; margin-right:8px;"></span>Error: <span id="lossScaleMin">low</span> ‚Üí <span id="lossScaleMax">high</span></div>
        </div>
    </div>
    
    <!-- STEP 3: EVALUATE - spans full width -->
    <div class="panel controls-strip" id="phase3Panel" style="padding:6px 12px; border-left:4px solid #ff9800; opacity:0.5; pointer-events:none; margin-top:10px;">
        <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
            <span style="font-size:12px; font-weight:bold; color:#ff9800;">‚ë¢ EVALUATE & COMPARE</span>
            
            <button id="evaluateBtn" style="padding:5px 14px; font-size:11px; background:#ff9800; font-weight:bold;" title="Test model on held-out data to measure generalization">üîç Evaluate on Held-Out</button>
            
            <span id="evalResults" style="font-size:10px; color:#555; display:none;"></span>
            
            <span style="color:#ddd;">|</span>
            
            <button id="saveRunA" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run A</button>
            <button id="saveRunB" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run B</button>
            <button id="compareBtn" style="padding:4px 10px; font-size:10px; background:#6c757d;" disabled>Compare A vs B</button>
        </div>
    </div>
    
    <!-- THE MATH - spans full width, collapsible -->
    <div class="panel equations-panel" style="padding:6px 10px; margin-top:10px;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="equationsHeader">
            <h2 style="margin:0; font-size:13px; border:none; padding:0;">üìê Equations</h2>
            <button id="toggleEquationsBtn" style="padding:2px 8px; font-size:10px; background:#6c757d;">‚ñº Collapse</button>
        </div>
        <div class="equations" id="equationsDiv" style="margin-top:6px;"></div>
    </div>
    </div><!-- end main content -->
    
    <!-- Learning Guide Sidebar -->
    <div id="guideSidebar" style="background:#f8f9fa; border:1px solid #dee2e6; border-radius:6px; padding:12px 14px;">
        <div style="margin-bottom:8px; border-bottom:2px solid #17a2b8; padding-bottom:4px;">
            <span style="font-size:16px; font-weight:bold; color:#17a2b8;">üìñ How Neural Networks Learn</span>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Big Picture</h4>
        <p style="margin:0 0 6px 0;">We use <strong>machine learning</strong> to build equations that serve as <strong>predictive models</strong>‚Äîestimating the next word in a composition or identifying objects in a picture. You have <strong>data</strong> representing typical inputs and desired outputs, but don't know the <strong>pattern</strong>. A <strong>neural network</strong> finds a <strong>function that fits</strong> the data‚Äîlike recreating a curve from scattered dots, but for arbitrarily complex functions.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Three Phases</h4>
        <p style="margin:0 0 3px 0;"><span style="color:#28a745; font-weight:bold;">‚ë†</span> <strong>Create Data</strong> ‚Äî Generate examples from a hidden "recipe."</p>
        <p style="margin:0 0 3px 0;"><span style="color:#007bff; font-weight:bold;">‚ë°</span> <strong>Train</strong> ‚Äî Measure error, adjust parameters, repeat.</p>
        <p style="margin:0 0 6px 0;"><span style="color:#6f42c1; font-weight:bold;">‚ë¢</span> <strong>Evaluate</strong> ‚Äî Test on held-out data to verify learning.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Key Terms</h4>
        <div style="font-size:12px; line-height:1.4;">
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Data Recipe</strong> ‚Äî Function that generates data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Training Data</strong> ‚Äî Examples the model learns from</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Held-Out Data</strong> ‚Äî Reserved to test real learning</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Noise</strong> ‚Äî Random variation (real data is messy)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Step</strong> ‚Äî Update from one example</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Epoch</strong> ‚Äî Full pass through training data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Error (E)</strong> ‚Äî Prediction error (lower = better)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Learning Rate (Œ∑)</strong> ‚Äî Step size for updates</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Activation (œÉ)</strong> ‚Äî Nonlinear function (ReLU/Sigmoid)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Weights (w)</strong> ‚Äî Multipliers on connections</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Biases (b<sub>ij</sub>, b)</strong> ‚Äî Offset added at each neuron</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Gradient (‚àÇE/‚àÇw)</strong> ‚Äî Steepest uphill direction</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#dc3545;">Overfitting</strong> ‚Äî Memorizing instead of learning</p>
            <p style="margin:0 0 6px 0;"><strong style="color:#dc3545;">Extrapolation</strong> ‚Äî Predicting outside training range</p>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Math</h4>
        <p style="margin:0 0 3px 0;"><strong>Forward:</strong> z = w¬∑x + b ‚Üí h = œÉ(z) ‚Üí y</p>
        <p style="margin:0 0 3px 0;"><strong>Error:</strong> E = ¬Ω(y ‚àí t)¬≤ where t = target</p>
        <p style="margin:0 0 3px 0;"><strong>Backward:</strong> Chain rule finds ‚àÇE/‚àÇw</p>
        <p style="margin:0 0 3px 0; font-size:11px; color:#666; font-style:italic; padding-left:6px;">‚àÇ[f(g(x))]/‚àÇx = f'(g(x)) ¬∑ g'(x)</p>
        <p style="margin:0 0 6px 0;"><strong>Update:</strong> w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw (downhill step)</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Optimizers</h4>
        <p style="margin:0 0 3px 0;"><strong>Simple (SGD)</strong> ‚Äî w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw</p>
        <p style="margin:0 0 6px 0;"><strong>Adam</strong> ‚Äî Adapts Œ∑ per-weight. Usually faster.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Try These</h4>
        <p style="margin:0 0 2px 0;">üìà <strong>Simple:</strong> <code>x</code>, <code>x^2</code>, <code>x^3-3*x</code></p>
        <p style="margin:0 0 2px 0;">üåä <strong>Waves:</strong> <code>sin(x)</code>, <code>sin(x)+sin(3*x)</code></p>
        <p style="margin:0 0 2px 0;">üìê <strong>Sharp:</strong> <code>abs(x)</code>, <code>sign(x)</code>, <code>floor(x)</code></p>
        <p style="margin:0 0 2px 0;">üî¨ Restrict training range ‚Üí extrapolation fails</p>
        <p style="margin:0 0 2px 0;">‚ö° Compare SGD vs Adam</p>
        <p style="margin:0;">üìä Increase noise ‚Üí learning breaks down</p>
        
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid #ddd; font-size:12px; color:#888; text-align:center;">
            üí° <em>ML = adjusting w to minimize E!</em>
        </div>
    </div>
</div><!-- end container -->

<script>
    // ---------------- Config & State ----------------

    let config = {
        learningRate: 0.1,
        activation: 'relu',
        // Data generation range (full range)
        dataXMin: -3,
        dataXMax: 3,
        // Training range (can be subset of data range) - default to ~95% of data range
        trainXMin: -2.8,
        trainXMax: 2.8,
        // Legacy compatibility
        xMin: -3,
        xMax: 3,
        noise: 0.02,
        targetFunc: null,
        targetFuncStr: 'sin(x)',
        optimizer: 'sgd',
        avgWindow: 100,
        // Dataset configuration
        totalSamples: 100,      // Total number of samples to generate
        trainTestSplit: 0.8,    // 80% train, 20% test
        testEvalInterval: 10    // Legacy - test loss now evaluated at epoch boundaries
    };

    // Training dataset - fixed points generated from target function
    let dataset = {
        generated: false,       // Has data been generated?
        allTrain: [],           // All training points (full data range)
        allTest: [],            // All test points (full data range)
        train: [],              // Training points within trainXMin..trainXMax
        test: [],               // Test points (all held-out, for evaluation)
        epoch: 0,               // Current epoch number
        stepInEpoch: 0,         // Current step within epoch
        shuffleOrder: [],       // Randomized order for current epoch
        totalEpochs: 0          // Total epochs completed
    };
    
    // Cached Y range for fit plot - set once when data is generated, stays fixed during training
    let fitPlotYRange = { min: -1.5, max: 1.5, initialized: false };
    
    // Reveal controls for assessment
    let revealOptions = {
        showHeldOut: true,      // Always show held-out (test) examples
        showRecipe: false,      // Show original data recipe curve
        evaluated: false        // Has evaluation been run?
    };
    
    // Evaluation results
    let evaluationResults = {
        testLossInRange: null,    // MSE for test points within training range
        testLossOutRange: null,   // MSE for test points outside training range
        testLossTotal: null,      // Total test MSE
        pointsInRange: 0,
        pointsOutRange: 0
    };
    
    // Loss landscape color scale - set once during initial surface computation
    // With percentile-based approach, the surface shows "achievable" loss which is stable
    let lossColorScale = {
        calibrated: false,
        minLoss: 0.0001,    // Best expected loss (blue)
        maxLoss: 10,        // Worst expected loss (red)
        noiseFloor: 0.0004  // Theoretical minimum based on noise
    };
    
    // Trace view state - controls which steps are visible
    let traceViewState = {
        maxStep: Infinity   // Show steps 0 to this value, Infinity = show all
    };

    let network = {
        numLayers: 1,
        hiddenSize: 3,
        weights: [],
        biases: []
    };

    let grads = {
        weights: [],
        biases: []
    };

    let history = {
        steps: [],
        loss: [],           // Training loss per step
        testLoss: [],       // Test loss evaluated periodically [{step, loss}, ...]
        avgLoss: [],
        weights: []
    };

    let trainingState = {
        running: false,
        animating: false,
        step: 0,
        totalAdds: 0,
        totalMuls: 0,
        lastUpdateTime: performance.now(),
        stepsSinceLastUpdate: 0,
        recentSamples: []
    };
    
    // Old variable - now replaced by traceViewState.maxStep
    // let traceViewEndStep = null;

    let gifCapture = {
        recording: false,
        gif: null,
        framesRemaining: 0
    };
    
    // Embedded gif.worker.js to avoid CORS issues (from gif.js 0.2.0)
    const gifWorkerCode = `(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);`;
    
    // Create Blob URL for worker (avoids CORS issues)
    const gifWorkerBlob = new Blob([gifWorkerCode], { type: 'application/javascript' });
    const gifWorkerUrl = URL.createObjectURL(gifWorkerBlob);

    let optimizerState = {
        m: [],
        v: [],
        r: [],
        t: 0
    };

    let savedRuns = {
        A: null,
        B: null
    };

    let comparisonModeActive = false;

    function exitComparisonMode() {
        if (!comparisonModeActive) return;
        comparisonModeActive = false;
        const compareBtn = document.getElementById('compareBtn');
        if (compareBtn && savedRuns.A && savedRuns.B) {
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
            compareBtn.textContent = 'Compare A vs B';
        }
    }

    const activationFns = {
        relu: {
            fn: (z) => Math.max(0, z),
            dfn: (z) => z > 0 ? 1 : 0
        },
        tanh: {
            fn: (z) => Math.tanh(z),
            dfn: (z) => {
                const t = Math.tanh(z);
                return 1 - t * t;
            }
        },
        sigmoid: {
            fn: (z) => 1 / (1 + Math.exp(-z)),
            dfn: (z) => {
                const s = 1 / (1 + Math.exp(-z));
                return s * (1 - s);
            }
        }
    };

    // --------------- Utility Functions ---------------
    
    // Fix fuzzy text on HiDPI displays
    function setupHiDPICanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return ctx;
    }

    function gaussianNoise(mean=0, std=1) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const n = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + std * n;
    }
    
    // Generate nice round tick values for axes
    function getNiceTicks(min, max, targetCount = 5) {
        const range = max - min;
        if (range <= 0) return [min];
        
        // Find a nice step size
        const roughStep = range / targetCount;
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const normalized = roughStep / magnitude;
        
        let niceStep;
        if (normalized <= 1) niceStep = magnitude;
        else if (normalized <= 2) niceStep = 2 * magnitude;
        else if (normalized <= 5) niceStep = 5 * magnitude;
        else niceStep = 10 * magnitude;
        
        // Generate ticks
        const ticks = [];
        const start = Math.ceil(min / niceStep) * niceStep;
        for (let tick = start; tick <= max; tick += niceStep) {
            ticks.push(tick);
        }
        
        // Ensure we have at least start and end
        if (ticks.length === 0 || ticks[0] > min) ticks.unshift(Math.floor(min / niceStep) * niceStep);
        if (ticks[ticks.length - 1] < max) ticks.push(Math.ceil(max / niceStep) * niceStep);
        
        return ticks;
    }
    
    // Generate nice tick values for log scale (powers of 10)
    function getLogTicks(logMin, logMax) {
        const ticks = [];
        const startPow = Math.floor(logMin);
        const endPow = Math.ceil(logMax);
        
        for (let p = startPow; p <= endPow; p++) {
            if (p >= logMin && p <= logMax) {
                ticks.push(p);
            }
        }
        
        // If range is very small, add intermediate ticks
        if (ticks.length < 3 && (logMax - logMin) < 2) {
            const midTicks = [];
            for (let p = startPow; p <= endPow; p++) {
                midTicks.push(p);
                // Add 0.5 log step (sqrt(10) ‚âà 3.16x)
                if (p + 0.5 <= logMax && p + 0.5 >= logMin) {
                    midTicks.push(p + 0.5);
                }
            }
            return midTicks.filter(t => t >= logMin && t <= logMax);
        }
        
        return ticks;
    }

    function createCompositeCanvas() {
        // Get all four canvases (2x2 grid)
        const networkCanvas = document.getElementById('networkCanvas');
        const fitCanvas = document.getElementById('fitCanvas');
        const traceCanvas = document.getElementById('traceCanvas');
        const lossCanvas = document.getElementById('lossCanvas');
        
        // Create composite canvas: 2x2 grid layout
        // Top row: Network Design | Examples vs Model
        // Bottom row: Training Trace | Error Landscape
        const padding = 10;
        const titleHeight = 18;
        const leftWidth = Math.max(networkCanvas.width, traceCanvas.width);
        const rightWidth = Math.max(fitCanvas.width, lossCanvas.width);
        const topHeight = Math.max(networkCanvas.height, fitCanvas.height);
        const bottomHeight = Math.max(traceCanvas.height, lossCanvas.height);
        
        const totalWidth = leftWidth + rightWidth + padding * 3;
        const totalHeight = topHeight + bottomHeight + titleHeight * 2 + padding * 4;
        
        const composite = document.createElement('canvas');
        composite.width = totalWidth;
        composite.height = totalHeight;
        const ctx = composite.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, totalWidth, totalHeight);
        
        // Add titles
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        
        // Top-left: Network Design
        ctx.fillText('Network Design', padding, padding + 12);
        ctx.drawImage(networkCanvas, padding, padding + titleHeight);
        
        // Top-right: Examples vs Model
        ctx.fillText('Examples vs Model', leftWidth + padding * 2, padding + 12);
        ctx.drawImage(fitCanvas, leftWidth + padding * 2, padding + titleHeight);
        
        // Bottom-left: Training Trace
        const bottomY = padding + titleHeight + topHeight + padding;
        ctx.fillText('Training Trace', padding, bottomY + 12);
        ctx.drawImage(traceCanvas, padding, bottomY + titleHeight);
        
        // Bottom-right: Error Landscape
        ctx.fillText('Error Landscape', leftWidth + padding * 2, bottomY + 12);
        ctx.drawImage(lossCanvas, leftWidth + padding * 2, bottomY + titleHeight);
        
        return composite;
    }
    
    // Check if GIF capture with workers is available
    function canUseGifWorkers() {
        // With embedded worker blob, GIF capture works everywhere except file:// 
        // (file:// still has issues with blob workers in some browsers)
        return window.location.protocol !== 'file:';
    }
    
    // Fallback: capture a single screenshot as PNG
    function captureScreenshot() {
        const composite = createCompositeCanvas();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        
        composite.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `learncurve_${timestamp}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }
    
    // Adaptive GIF capture - scans training to find interesting convergence region
    function startGifCapture() {
        if (gifCapture.recording) return;
        
        // Check if training data exists
        if (!dataset.generated || dataset.train.length === 0) {
            alert('Please generate training data first before capturing a GIF.');
            return;
        }
        
        // Check if we can use web workers (required for GIF.js)
        if (!canUseGifWorkers()) {
            const useScreenshot = confirm(
                'Animated GIF capture requires running from a web server.\n\n' +
                'Options:\n' +
                '‚Ä¢ Click OK to download a PNG screenshot instead\n' +
                '‚Ä¢ Click Cancel, then run: python3 -m http.server 8000\n' +
                '  and open http://localhost:8000/index.html for GIF capture'
            );
            if (useScreenshot) {
                captureScreenshot();
            }
            return;
        }
        
        
        trainingState.running = false;
        document.getElementById('runBtn').textContent = 'Run';
        
        // Show status
        const gifBtn = document.getElementById('gifBtn');
        const originalText = gifBtn.textContent;
        gifBtn.textContent = 'Scanning...';
        gifBtn.disabled = true;
        
        // Phase 1: Scan training to find convergence
        setTimeout(() => {
            const scanResult = scanForConvergence();
            gifBtn.textContent = 'Recording...';
            
            // Phase 2: Reset model and record with adaptive keyframes
            // (scanResult already restored state, startAdaptiveCapture will reset model)
            setTimeout(() => {
                startAdaptiveCapture(scanResult, () => {
                    gifBtn.textContent = originalText;
                    gifBtn.disabled = false;
                });
            }, 100);
        }, 50);
    }
    
    function scanForConvergence() {
        // Save current state
        const savedNetwork = JSON.parse(JSON.stringify(network));
        const savedHistory = JSON.parse(JSON.stringify(history));
        const savedTrainingState = JSON.parse(JSON.stringify(trainingState));
        const savedDataset = JSON.parse(JSON.stringify(dataset));
        
        // Reset model only (preserve dataset)
        resetModel();
        
        const losses = [];
        const maxScanSteps = 500;
        const targetFrames = 80;
        
        // Run silent training to collect loss data
        for (let i = 0; i < maxScanSteps; i++) {
            trainStep();
            losses.push(history.loss[history.loss.length - 1]);
            
            // Check for early convergence
            if (losses.length > 50) {
                const recent = losses.slice(-30);
                const variance = computeVariance(recent);
                const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                if (variance < 0.0001 * mean * mean) {
                    break; // Converged early
                }
            }
        }
        
        // Analyze loss curve to find interesting region
        const L0 = losses[0];
        const Lmin = Math.min(...losses);
        const totalDrop = L0 - Lmin;
        
        // Find key milestones
        let start5pct = 0, start50pct = 0, end90pct = losses.length - 1, convergencePoint = losses.length - 1;
        
        for (let i = 0; i < losses.length; i++) {
            const drop = L0 - losses[i];
            if (start5pct === 0 && drop >= 0.05 * totalDrop) start5pct = i;
            if (start50pct === 0 && drop >= 0.50 * totalDrop) start50pct = i;
            if (drop >= 0.90 * totalDrop) { end90pct = i; break; }
        }
        
        // Detect convergence (low variance)
        for (let i = 50; i < losses.length; i++) {
            const window = losses.slice(i - 30, i);
            const variance = computeVariance(window);
            const mean = window.reduce((a, b) => a + b, 0) / window.length;
            if (variance < 0.0001 * mean * mean) {
                convergencePoint = i;
                break;
            }
        }
        
        // Compute |dL/dt| for each step
        const derivatives = losses.map((L, i) => 
            i === 0 ? 0 : Math.abs(losses[i-1] - L)
        );
        
        // Select keyframes adaptively
        const keyframes = selectKeyframes(losses, derivatives, {
            start5pct, start50pct, end90pct, convergencePoint
        }, targetFrames);
        
        // Restore original state
        network = savedNetwork;
        history = savedHistory;
        trainingState = savedTrainingState;
        dataset = savedDataset;
        
        return { losses, keyframes, convergencePoint };
    }
    
    function computeVariance(arr) {
        if (arr.length === 0) return 0;
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
    }
    
    function selectKeyframes(losses, derivatives, milestones, targetFrames) {
        const frames = new Set([0]); // Always include first
        
        // Always include milestone frames
        frames.add(milestones.start5pct);
        frames.add(milestones.start50pct);
        frames.add(milestones.end90pct);
        frames.add(Math.min(milestones.convergencePoint, losses.length - 1));
        frames.add(losses.length - 1); // Always include last
        
        // Score each step by "interestingness" (derivative magnitude)
        const maxDeriv = Math.max(...derivatives.slice(1)) || 1;
        const scores = derivatives.map(d => d / maxDeriv);
        
        // Add frames based on derivative (more change = more frames)
        const numSegments = 20;
        const segmentSize = Math.ceil(losses.length / numSegments);
        
        for (let seg = 0; seg < numSegments; seg++) {
            const segStart = seg * segmentSize;
            const segEnd = Math.min((seg + 1) * segmentSize, losses.length);
            
            // Find max derivative in this segment
            let maxIdx = segStart;
            let maxScore = 0;
            for (let i = segStart; i < segEnd; i++) {
                if (scores[i] > maxScore) {
                    maxScore = scores[i];
                    maxIdx = i;
                }
            }
            
            // Add more frames for high-derivative segments
            if (maxScore > 0.1) {
                frames.add(maxIdx);
                // Add extra frames around high-action areas
                if (maxScore > 0.3 && seg < numSegments - 1) {
                    frames.add(Math.min(maxIdx + 2, losses.length - 1));
                }
            } else {
                // Low derivative - just sample the segment sparsely
                frames.add(Math.floor((segStart + segEnd) / 2));
            }
        }
        
        // Convert to sorted array and limit to targetFrames
        let result = [...frames].sort((a, b) => a - b);
        
        // If we have too many, subsample evenly
        while (result.length > targetFrames) {
            // Remove every other frame except first/last
            const newResult = [result[0]];
            for (let i = 2; i < result.length - 1; i += 2) {
                newResult.push(result[i]);
            }
            newResult.push(result[result.length - 1]);
            result = newResult;
        }
        
        return result;
    }
    
    function startAdaptiveCapture(scanResult, onComplete) {
        const { keyframes } = scanResult;
        
        // Reset model to fresh state (preserve dataset)
        resetModel();
        
        const composite = createCompositeCanvas();
        
        try {
            gifCapture.gif = new GIF({
                workers: 2,
                quality: 10,
                width: composite.width,
                height: composite.height,
                workerScript: gifWorkerUrl  // Embedded worker to avoid CORS issues
            });
        } catch (e) {
            console.error('Failed to create GIF:', e);
            alert('GIF capture failed: ' + e.message);
            if (onComplete) onComplete();
            return;
        }
        
        gifCapture.recording = true;
        gifCapture.keyframes = keyframes;
        gifCapture.keyframeIndex = 0;
        gifCapture.currentStep = 0;
        
        gifCapture.gif.on('finished', function (blob) {
            // Clear timeout since we finished normally
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `convergence_${timestamp}.gif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            gifCapture.recording = false;
            if (onComplete) onComplete();
        });
        
        // Timeout safety - force complete after 30 seconds
        gifCapture.timeout = setTimeout(() => {
            if (gifCapture.recording) {
                console.warn('GIF capture timeout - forcing completion');
                gifCapture.recording = false;
                gifCapture.gif = null;
                if (onComplete) onComplete();
            }
        }, 30000);
        
        adaptiveCaptureLoop();
    }
    
    function adaptiveCaptureLoop() {
        if (!gifCapture.recording || gifCapture.keyframeIndex >= gifCapture.keyframes.length) {
            if (gifCapture.gif) {
                gifCapture.gif.render();
            }
            return;
        }
        
        const targetStep = gifCapture.keyframes[gifCapture.keyframeIndex];
        
        // Train until we reach the target step (with safety limit)
        let safetyCounter = 0;
        const maxIterations = 10000;
        while (gifCapture.currentStep < targetStep && safetyCounter < maxIterations) {
            const prevStep = trainingState.step;
            trainStep();
            gifCapture.currentStep++;
            safetyCounter++;
            
            // If trainStep didn't actually train (NaN or other issue), break out
            if (trainingState.step === prevStep || !Number.isFinite(history.loss[history.loss.length - 1])) {
                console.warn('GIF capture: training issue detected, finishing early');
                gifCapture.keyframeIndex = gifCapture.keyframes.length; // Force finish
                break;
            }
        }
        
        updateUI();
        
        // Calculate delay based on next keyframe distance (variable speed)
        let delay = 100;
        if (gifCapture.keyframeIndex < gifCapture.keyframes.length - 1) {
            const gap = gifCapture.keyframes[gifCapture.keyframeIndex + 1] - targetStep;
            // Bigger gaps = less action = shorter delay (faster playback)
            delay = gap > 20 ? 50 : gap > 5 ? 100 : 150;
        } else {
            delay = 200; // Pause at end
        }
        
        // Capture frame
        const composite = createCompositeCanvas();
        gifCapture.gif.addFrame(composite, {copy: true, delay});
        
        gifCapture.keyframeIndex++;
        setTimeout(adaptiveCaptureLoop, 30);
    }

    function initializeOptimizerState() {
        optimizerState.m = [];
        optimizerState.v = [];
        optimizerState.r = [];
        optimizerState.t = 0;

        // For each weight matrix/vector
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            if (Array.isArray(w[0])) {
                optimizerState.m.push(w.map(row => row.map(() => 0)));
                optimizerState.v.push(w.map(row => row.map(() => 0)));
                optimizerState.r.push(w.map(row => row.map(() => 0)));
            } else {
                optimizerState.m.push(w.map(() => 0));
                optimizerState.v.push(w.map(() => 0));
                optimizerState.r.push(w.map(() => 0));
            }
        }

        // Biases
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            optimizerState.m.push(b.map(() => 0));
            optimizerState.v.push(b.map(() => 0));
            optimizerState.r.push(b.map(() => 0));
        }
    }
function updateParameters() {
    const lr = config.learningRate;
    const beta1 = 0.9;
    const beta2 = 0.999;
    const epsilon = 1e-8;
    const rho = 0.9;
    const momentumCoeff = 0.9;
    const gradClip = 5.0;  // Gradient clipping threshold

    // Clip gradients to prevent explosion
    function clipGrad(g) {
        if (!Number.isFinite(g)) return 0;
        return Math.max(-gradClip, Math.min(gradClip, g));
    }
    
    // Apply gradient clipping to all gradients
    for (let l = 0; l < grads.weights.length; l++) {
        const gw = grads.weights[l];
        if (Array.isArray(gw[0])) {
            for (let i = 0; i < gw.length; i++) {
                for (let j = 0; j < gw[i].length; j++) {
                    gw[i][j] = clipGrad(gw[i][j]);
                }
            }
        } else {
            for (let i = 0; i < gw.length; i++) {
                gw[i] = clipGrad(gw[i]);
            }
        }
    }
    for (let l = 0; l < grads.biases.length; l++) {
        const gb = grads.biases[l];
        for (let i = 0; i < gb.length; i++) {
            gb[i] = clipGrad(gb[i]);
        }
    }

    let idx = 0;

    // Plain SGD
    if (config.optimizer === 'sgd') {
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            const gw = grads.weights[l];
            if (Array.isArray(w[0])) {
                // matrix
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        w[i][j] -= lr * gw[i][j];
                    }
                }
            } else {
                // vector
                for (let i = 0; i < w.length; i++) {
                    w[i] -= lr * gw[i];
                }
            }
        }
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            const gb = grads.biases[l];
            for (let i = 0; i < b.length; i++) {
                b[i] -= lr * gb[i];
            }
        }
        return;
    }

    // Momentum / RMSProp / Adam
    optimizerState.t += 1;

    // Weights
    for (let l = 0; l < network.weights.length; l++) {
        const w = network.weights[l];
        const gw = grads.weights[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;

            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        v[i][j] = vCoeff * v[i][j] + oneMinus * gw[i][j];
                        w[i][j] -= lr * v[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    v[i] = vCoeff * v[i] + oneMinus * gw[i];
                    w[i] -= lr * v[i];
                }
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        r[i][j] = rho * r[i][j] + oneMinusRho * gw[i][j] * gw[i][j];
                        const step = lr / Math.sqrt(r[i][j] + epsilon);
                        w[i][j] -= step * gw[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    r[i] = rho * r[i] + oneMinusRho * gw[i] * gw[i];
                    const step = lr / Math.sqrt(r[i] + epsilon);
                    w[i] -= step * gw[i];
                }
            }
        } else if (config.optimizer === 'adam') {
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        m[i][j] = beta1 * m[i][j] + (1 - beta1) * gw[i][j];
                        v[i][j] = beta2 * v[i][j] + (1 - beta2) * gw[i][j] * gw[i][j];
                        const mHat = m[i][j] / (1 - Math.pow(beta1, optimizerState.t));
                        const vHat = v[i][j] / (1 - Math.pow(beta2, optimizerState.t));
                        w[i][j] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    m[i] = beta1 * m[i] + (1 - beta1) * gw[i];
                    v[i] = beta2 * v[i] + (1 - beta2) * gw[i] * gw[i];
                    const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                    const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                    w[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                }
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }

    // Biases
    for (let l = 0; l < network.biases.length; l++) {
        const b = network.biases[l];
        const gb = grads.biases[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;
            for (let i = 0; i < b.length; i++) {
                v[i] = vCoeff * v[i] + oneMinus * gb[i];
                b[i] -= lr * v[i];
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            for (let i = 0; i < b.length; i++) {
                r[i] = rho * r[i] + oneMinusRho * gb[i] * gb[i];
                const step = lr / Math.sqrt(r[i] + epsilon);
                b[i] -= step * gb[i];
            }
        } else if (config.optimizer === 'adam') {
            for (let i = 0; i < b.length; i++) {
                m[i] = beta1 * m[i] + (1 - beta1) * gb[i];
                v[i] = beta2 * v[i] + (1 - beta2) * gb[i] * gb[i];
                const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                b[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }
}

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    function makeRunLabel(slot) {
        const optName = config.optimizer === 'sgd' ? 'Simple' : config.optimizer;
        return `${slot}: ${config.activation}, L=${network.numLayers}, H=${network.hiddenSize}, Œ∑=${config.learningRate.toFixed(3)}, ${optName}`;
    }

    function saveRun(slot) {
        if (history.steps.length < 2) {
            alert('Train the network for a few steps before saving a run.');
            return;
        }

        const run = {
            label: makeRunLabel(slot),
            steps: history.steps.slice(),
            loss: history.loss.slice(),
            avgLoss: history.avgLoss.slice(),
            network: deepClone(network),
            config: {
                activation: config.activation,
                learningRate: config.learningRate,
                numLayers: network.numLayers,
                hiddenSize: network.hiddenSize,
                targetFuncStr: config.targetFuncStr,
                optimizer: config.optimizer
            },
            // Save loss landscape trail for comparison visualization
            lossSurfaceTrail: lossSurfaceTrail.slice(),
            lossSurfaceWeightIndices: lossSurfaceWeightIndices.slice()
        };

        savedRuns[slot] = run;

        const labelEl = document.getElementById(slot === 'A' ? 'runALabel' : 'runBLabel');
        if (labelEl) {
            labelEl.textContent = run.label;
        }

        // Style the save button to show it has saved data (subtle indicator - thicker border)
        const saveBtn = document.getElementById(slot === 'A' ? 'saveRunA' : 'saveRunB');
        if (saveBtn) {
            saveBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:8px; border:2px solid #28a745; box-shadow:0 0 3px rgba(40,167,69,0.3);';
        }

        // Enable and style compare button when both A and B are saved
        const compareBtn = document.getElementById('compareBtn');
        if (savedRuns.A && savedRuns.B) {
            compareBtn.disabled = false;
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
        }

        updateUI();
    }

    function forwardWithNetwork(x, net, activationName) {
        const actFn = activationFns[activationName].fn;
        const h = net.hiddenSize;
        const numLayers = net.numLayers;

        let activations = [];
        let zValues = [];

        activations.push([x]);

        // Hidden layer 1
        let z = new Array(h);
        let a = new Array(h);
        const w0 = net.weights[0]; // shape [h, 1] represented as [h]
        const b0 = net.biases[0];  // shape [h]
        for (let i = 0; i < h; i++) {
            let zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = actFn(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let layer = 1; layer < numLayers; layer++) {
            const prev = activations[activations.length - 1];
            const w = net.weights[layer];  // shape [h, h]
            const b = net.biases[layer];   // shape [h]

            z = new Array(h);
            a = new Array(h);

            for (let i = 0; i < h; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < h; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = actFn(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output layer
        const lastLayer = activations[activations.length - 1];
        const wOut = net.weights[net.weights.length - 1];       // shape [h]
        const bOut = net.biases[net.biases.length - 1][0];      // shape [1]
        let yhat = bOut;
        for (let i = 0; i < h; i++) {
            yhat += wOut[i] * lastLayer[i];
        }

        return yhat;
    }

    // -------------- Network, Target & Ops --------------

    function compileTargetFunc() {
        const input = document.getElementById('targetFuncInput');
        let originalStr = input.value.trim() || 'x^2';
        
        // Make case-insensitive by converting to lowercase for function matching
        let fStr = originalStr;
        
        // Allow ^ as power operator (convert to **)
        fStr = fStr.replace(/\^/g, '**');
        
        // Convert shorthand functions to Math.* (case-insensitive)
        // Order matters - longer names first
        fStr = fStr.replace(/\blog10\b/gi, 'Math.log10');  // log base 10
        fStr = fStr.replace(/\bsqrt\b/gi, 'Math.sqrt');
        fStr = fStr.replace(/\babs\b/gi, 'Math.abs');
        fStr = fStr.replace(/\bsin\b/gi, 'Math.sin');
        fStr = fStr.replace(/\bcos\b/gi, 'Math.cos');
        fStr = fStr.replace(/\btan\b/gi, 'Math.tan');
        fStr = fStr.replace(/\bexp\b/gi, 'Math.exp');      // e^x (natural exponential)
        fStr = fStr.replace(/\blog\b/gi, 'Math.log');      // natural log (ln)
        fStr = fStr.replace(/\bfloor\b/gi, 'Math.floor');
        fStr = fStr.replace(/\bceil\b/gi, 'Math.ceil');
        fStr = fStr.replace(/\bround\b/gi, 'Math.round');
        fStr = fStr.replace(/\bsign\b/gi, 'Math.sign');
        fStr = fStr.replace(/\bmin\b/gi, 'Math.min');
        fStr = fStr.replace(/\bmax\b/gi, 'Math.max');
        fStr = fStr.replace(/\bpow\b/gi, 'Math.pow');
        
        // Convert constants (case-insensitive)
        fStr = fStr.replace(/\bPI\b/gi, 'Math.PI');        // œÄ ‚âà 3.14159
        fStr = fStr.replace(/\bE\b/gi, 'Math.E');          // e ‚âà 2.71828
        
        // Make x case-insensitive (X -> x)
        fStr = fStr.replace(/\bX\b/g, 'x');

        // Get or create error display elements
        let errorSpan = document.getElementById('targetFuncError');
        if (!errorSpan) {
            errorSpan = document.createElement('span');
            errorSpan.id = 'targetFuncError';
            errorSpan.style.cssText = 'color:#dc3545; font-size:11px; margin-left:8px; display:block;';
            input.parentNode.appendChild(errorSpan);
        }

        try {
            const fn = new Function('x', 'return ' + fStr + ';');
            // Test it at a few points
            fn(0);
            fn(1);
            fn(-1);
            config.targetFunc = fn;
            config.targetFuncStr = fStr;
            input.style.borderColor = '#28a745';  // Green border for valid
            input.style.backgroundColor = '#fff';
            errorSpan.textContent = '';
            errorSpan.innerHTML = '';
        } catch (e) {
            // Highlight input in red but DON'T revert - let user continue editing
            input.style.borderColor = '#dc3545';
            input.style.backgroundColor = '#fff0f0';
            
            // Try to extract position info from error message
            const errorMsg = e.message;
            let highlightedError = errorMsg;
            
            // Try to find problematic tokens
            const unexpectedMatch = errorMsg.match(/Unexpected token '?([^']*)'?/i);
            const identifierMatch = errorMsg.match(/(\w+) is not defined/i);
            
            if (unexpectedMatch && unexpectedMatch[1]) {
                const badToken = unexpectedMatch[1];
                const pos = originalStr.indexOf(badToken);
                if (pos >= 0) {
                    // Show the input with the bad part highlighted
                    const before = originalStr.substring(0, pos);
                    const bad = originalStr.substring(pos, pos + badToken.length);
                    const after = originalStr.substring(pos + badToken.length);
                    highlightedError = `Error at "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>": ${errorMsg}`;
                }
            } else if (identifierMatch && identifierMatch[1]) {
                const badId = identifierMatch[1];
                // Find case-insensitive match in original
                const regex = new RegExp('\\b' + badId + '\\b', 'i');
                const match = originalStr.match(regex);
                if (match) {
                    const pos = originalStr.search(regex);
                    const before = originalStr.substring(0, pos);
                    const bad = match[0];
                    const after = originalStr.substring(pos + bad.length);
                    highlightedError = `Unknown: "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>" - did you mean a function like sin, cos, exp?`;
                }
            }
            
            errorSpan.innerHTML = '‚ö† ' + highlightedError;
            // Keep the previous valid function running - don't change config.targetFunc
        }
    }

    function initializeNetwork() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        network.weights = [];
        network.biases = [];
        grads.weights = [];
        grads.biases = [];

        function randnScaled(scale) {
            return scale * gaussianNoise(0, 1);
        }

        // Input -> Layer 1: weights shape [H, 1]
        const w0 = new Array(H);
        const b0 = new Array(H);
        const scale0 = 1 / Math.sqrt(1);
        for (let i = 0; i < H; i++) {
            w0[i] = randnScaled(scale0);
            b0[i] = 0;
        }
        network.weights.push(w0);
        network.biases.push(b0);
        grads.weights.push(new Array(H).fill(0));
        grads.biases.push(new Array(H).fill(0));

        // Hidden ‚Üí Hidden
        for (let l = 1; l < L; l++) {
            const w = new Array(H);
            const b = new Array(H);
            const scale = 1 / Math.sqrt(H);
            for (let i = 0; i < H; i++) {
                w[i] = new Array(H);
                for (let j = 0; j < H; j++) {
                    w[i][j] = randnScaled(scale);
                }
                b[i] = 0;
            }
            network.weights.push(w);
            network.biases.push(b);

            const gw = new Array(H);
            for (let i = 0; i < H; i++) {
                gw[i] = new Array(H).fill(0);
            }
            grads.weights.push(gw);
            grads.biases.push(new Array(H).fill(0));
        }

        // Output layer: weights [H], bias [1]
        const wOut = new Array(H);
        const bOut = [0];
        const scaleOut = 1 / Math.sqrt(H);
        for (let i = 0; i < H; i++) {
            wOut[i] = randnScaled(scaleOut);
        }
        network.weights.push(wOut);
        network.biases.push(bOut);

        grads.weights.push(new Array(H).fill(0));
        grads.biases.push([0]);

        initializeOptimizerState();
        computeOpsPerStep();
    }

    function computeOpsPerStep() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        let fwdAdds = 0, fwdMuls = 0;
        let backAdds = 0, backMuls = 0;
        let lossAdds = 0, lossMuls = 0;

        // Forward ops: each neuron does sum of inputs + bias + activation
        // Layer 1: H neurons, each 1 multiply + 1 add + (bias add)
        fwdMuls += H;  // w*x
        fwdAdds += H;  // plus bias

        // Hidden layers
        for (let l = 1; l < L; l++) {
            // each H neuron: H multiplies + H adds + 1 add for bias
            fwdMuls += H * H;
            fwdAdds += H * (H + 1);
        }

        // Output layer: H multiplies + H adds + 1 bias
        fwdMuls += H;
        fwdAdds += H + 1;

        // Loss = 1/2 (yhat - y)^2 -> 1 sub, 1 mul
        lossAdds += 1;
        lossMuls += 1;

        // Backward (rough estimate, symmetrical to forward)
        backMuls += fwdMuls * 2;
        backAdds += fwdAdds * 2;

        // Ops are now drawn on the Network Design canvas
        // Keep these for backwards compatibility if elements exist
        const setIfExists = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
        setIfExists('opsFwdAdd', fwdAdds);
        setIfExists('opsFwdMul', fwdMuls);
        setIfExists('opsLossAdd', lossAdds);
        setIfExists('opsLossMul', lossMuls);
        setIfExists('opsBackAdd', backAdds);
        setIfExists('opsBackMul', backMuls);
        setIfExists('opsTotAdd', fwdAdds + lossAdds + backAdds);
        setIfExists('opsTotMul', fwdMuls + lossMuls + backMuls);

        return { fwdAdds, fwdMuls, lossAdds, lossMuls, backAdds, backMuls };
    }

    // Generate a single point from the target function (used for visualization)
    function sampleTargetPoint() {
        const x = config.xMin + Math.random() * (config.xMax - config.xMin);
        let y;
        try {
            y = config.targetFunc(x);
        } catch {
            y = 0;
        }
        if (config.noise > 0) {
            y += gaussianNoise(0, config.noise);
        }
        return { x, y };
    }
    
    // Legacy function - now gets next point from dataset
    function sampleTrainingPoint() {
        if (!dataset.generated || dataset.train.length === 0) {
            // Fallback to random sampling if no dataset
            return sampleTargetPoint();
        }
        
        // Get the current training sample based on shuffle order
        const idx = dataset.shuffleOrder[dataset.stepInEpoch % dataset.train.length];
        return dataset.train[idx];
    }
    
    // Generate fixed training and test datasets
    function generateDataset() {
        const totalSamples = config.totalSamples;
        const trainRatio = config.trainTestSplit;
        
        // Generate all points across the FULL data range
        const allPoints = [];
        const dataRange = config.dataXMax - config.dataXMin;
        
        for (let i = 0; i < totalSamples; i++) {
            // Use stratified sampling for better coverage
            const x = config.dataXMin + (i + Math.random()) * dataRange / totalSamples;
            let y;
            try {
                y = config.targetFunc(x);
            } catch {
                y = 0;
            }
            if (config.noise > 0) {
                y += gaussianNoise(0, config.noise);
            }
            // Mark if point is within training range
            const inTrainRange = x >= config.trainXMin && x <= config.trainXMax;
            allPoints.push({ x, y, inTrainRange });
        }
        
        // Shuffle all points
        for (let i = allPoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allPoints[i], allPoints[j]] = [allPoints[j], allPoints[i]];
        }
        
        // Split into train candidates and test
        const trainCount = Math.floor(totalSamples * trainRatio);
        const allTrainCandidates = allPoints.slice(0, trainCount);
        const allTestPoints = allPoints.slice(trainCount);
        
        // Store all points
        dataset.allTrain = allTrainCandidates;
        dataset.allTest = allTestPoints;
        
        // Filter training points to only those within training range
        dataset.train = allTrainCandidates.filter(p => p.inTrainRange);
        
        // Test set includes ALL held-out points (both in and out of range)
        dataset.test = allTestPoints;
        
        // Count test points in/out of training range
        const testInRange = allTestPoints.filter(p => p.inTrainRange).length;
        const testOutRange = allTestPoints.length - testInRange;
        
        dataset.generated = true;
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        
        // Reset evaluation
        revealOptions.evaluated = false;
        evaluationResults = {
            testLossInRange: null,
            testLossOutRange: null,
            testLossTotal: null,
            pointsInRange: testInRange,
            pointsOutRange: testOutRange
        };
        
        // Reset color scale when new data is generated
        lossColorScale.calibrated = false;
        
        // Initialize shuffle order for first epoch
        shuffleTrainingOrder();
        
        // Update x range for Fit Plot to show full data range
        config.xMin = config.dataXMin;
        config.xMax = config.dataXMax;
        
        // Calculate and cache Y range for fit plot (stays fixed during training)
        const allDataY = [...allTrainCandidates.map(p => p.y), ...allTestPoints.map(p => p.y)];
        // Also sample the target function across the display range
        const funcYSamples = [];
        for (let i = 0; i <= 50; i++) {
            const x = config.dataXMin + (i / 50) * (config.dataXMax - config.dataXMin);
            try {
                const y = config.targetFunc(x);
                if (Number.isFinite(y)) funcYSamples.push(y);
            } catch {}
        }
        const allY = [...allDataY, ...funcYSamples];
        if (allY.length > 0) {
            const yMin = Math.min(...allY);
            const yMax = Math.max(...allY);
            const yPad = (yMax - yMin) * 0.2 || 0.5;  // 20% padding
            fitPlotYRange.min = yMin - yPad;
            fitPlotYRange.max = yMax + yPad;
            fitPlotYRange.initialized = true;
        }
        
        // Update UI
        updatePhaseUI();
        updateTrainingHandlePositions();
        updateTrainRangeSliderBounds();
        
        const outsideCount = allTrainCandidates.filter(p => !p.inTrainRange).length;
        console.log(`Generated ${totalSamples} total points:`);
        console.log(`  Training: ${dataset.train.length} in range (${outsideCount} excluded outside train range)`);
        console.log(`  Held-out: ${testInRange} in range, ${testOutRange} outside (extrapolation test)`);
        
        return { 
            trainCount: dataset.train.length, 
            testCount: dataset.test.length,
            testInRange,
            testOutRange
        };
    }
    
    // Run evaluation on held-out data
    function runEvaluation() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let lossInRange = 0;
        let lossOutRange = 0;
        let countInRange = 0;
        let countOutRange = 0;
        
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            const loss = 0.5 * error * error;
            
            if (point.inTrainRange) {
                lossInRange += loss;
                countInRange++;
            } else {
                lossOutRange += loss;
                countOutRange++;
            }
        }
        
        evaluationResults = {
            testLossInRange: countInRange > 0 ? lossInRange / countInRange : null,
            testLossOutRange: countOutRange > 0 ? lossOutRange / countOutRange : null,
            testLossTotal: (lossInRange + lossOutRange) / dataset.test.length,
            pointsInRange: countInRange,
            pointsOutRange: countOutRange
        };
        
        revealOptions.evaluated = true;
        // Held-out points are now always visible
        
        // Record in history
        history.testLoss.push({ 
            step: trainingState.step, 
            loss: evaluationResults.testLossTotal,
            inRange: evaluationResults.testLossInRange,
            outRange: evaluationResults.testLossOutRange
        });
        
        return evaluationResults;
    }
    
    // Shuffle the training order for a new epoch
    function shuffleTrainingOrder() {
        dataset.shuffleOrder = [];
        for (let i = 0; i < dataset.train.length; i++) {
            dataset.shuffleOrder.push(i);
        }
        // Fisher-Yates shuffle
        for (let i = dataset.shuffleOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [dataset.shuffleOrder[i], dataset.shuffleOrder[j]] = [dataset.shuffleOrder[j], dataset.shuffleOrder[i]];
        }
    }
    
    // Compute loss over the entire test set
    function computeTestLoss() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.test.length;
    }
    
    // Compute loss over the entire training set
    function computeTrainLoss() {
        if (!dataset.generated || dataset.train.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.train) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.train.length;
    }
    
    // Update training range from config and re-filter dataset
    function updateTrainingRangeFromConfig() {
        if (!dataset.generated) return;
        if (!dataset.allTrain || !dataset.allTest) return;
        
        // Re-filter training points based on new training range
        // (allTrain and allTest are preserved from original generation)
        dataset.train = dataset.allTrain.filter(p => 
            p.x >= config.trainXMin && p.x <= config.trainXMax
        );
        
        // Update test points' inTrainRange status
        dataset.test = dataset.allTest.map(p => ({
            ...p,
            inTrainRange: p.x >= config.trainXMin && p.x <= config.trainXMax
        }));
        
        // Reset training state (new dataset means starting fresh)
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        shuffleTrainingOrder();
        
        updatePhaseUI();
    }
    
    // Update training handle positions based on training range
    function updateTrainingHandlePositions() {
        const fitCanvas = document.getElementById('fitCanvas');
        const trainMinHandle = document.getElementById('trainMinHandle');
        const trainMaxHandle = document.getElementById('trainMaxHandle');
        
        if (!fitCanvas || !trainMinHandle || !trainMaxHandle) return;
        
        // Calculate plot area (must match drawFitPlot padding)
        const paddingLeft = 50;
        const paddingRight = 50;
        const canvasWidth = fitCanvas.offsetWidth || 520;
        const plotWidth = canvasWidth - paddingLeft - paddingRight;
        
        const dataRange = config.xMax - config.xMin;
        if (dataRange <= 0) return;
        
        // Calculate handle positions based on training range relative to data range
        const minFrac = (config.trainXMin - config.xMin) / dataRange;
        const maxFrac = (config.trainXMax - config.xMin) / dataRange;
        
        // Position handles (12px handle width, so offset by 12 to center)
        const minPx = paddingLeft + (minFrac * plotWidth) - 12;
        const maxPx = paddingLeft + (maxFrac * plotWidth) - 12;
        
        trainMinHandle.style.left = minPx + 'px';
        trainMinHandle.style.right = 'auto';
        trainMaxHandle.style.left = maxPx + 'px';
        trainMaxHandle.style.right = 'auto';
        
        // Enable handles if data is generated
        if (dataset.generated) {
            trainMinHandle.style.opacity = '1';
            trainMinHandle.style.pointerEvents = 'auto';
            trainMaxHandle.style.opacity = '1';
            trainMaxHandle.style.pointerEvents = 'auto';
        } else {
            trainMinHandle.style.opacity = '0.5';
            trainMinHandle.style.pointerEvents = 'none';
            trainMaxHandle.style.opacity = '0.5';
            trainMaxHandle.style.pointerEvents = 'none';
        }
    }
    
    // Update train range slider bounds when data is generated
    function updateTrainRangeSliderBounds() {
        const trainMinSlider = document.getElementById('trainMinSlider');
        const trainMaxSlider = document.getElementById('trainMaxSlider');
        const trainRangeSliderStrip = document.getElementById('trainRangeSliderStrip');
        const trainRangeMinLabel = document.getElementById('trainRangeMinLabel');
        const trainRangeMaxLabel = document.getElementById('trainRangeMaxLabel');
        
        if (!trainMinSlider || !trainMaxSlider) return;
        
        // Set slider bounds to data range
        trainMinSlider.min = config.dataXMin.toString();
        trainMinSlider.max = config.dataXMax.toString();
        trainMaxSlider.min = config.dataXMin.toString();
        trainMaxSlider.max = config.dataXMax.toString();
        
        // Set slider values to current training range
        trainMinSlider.value = config.trainXMin.toString();
        trainMaxSlider.value = config.trainXMax.toString();
        
        // Update labels
        if (trainRangeMinLabel) trainRangeMinLabel.textContent = config.dataXMin.toString();
        if (trainRangeMaxLabel) trainRangeMaxLabel.textContent = config.dataXMax.toString();
        
        // Enable/disable based on data state
        if (trainRangeSliderStrip) {
            if (dataset.generated) {
                trainRangeSliderStrip.style.opacity = '1';
                trainRangeSliderStrip.style.pointerEvents = 'auto';
            } else {
                trainRangeSliderStrip.style.opacity = '0.5';
                trainRangeSliderStrip.style.pointerEvents = 'none';
            }
        }
        
        // Trigger UI update
        const trainMinValue = document.getElementById('trainMinValue');
        const trainMaxValue = document.getElementById('trainMaxValue');
        const trainRangeFill = document.getElementById('trainRangeFill');
        
        if (trainMinValue && trainMaxValue && trainRangeFill) {
            const min = parseFloat(trainMinSlider.min);
            const max = parseFloat(trainMinSlider.max);
            const minVal = parseFloat(trainMinSlider.value);
            const maxVal = parseFloat(trainMaxSlider.value);
            
            trainMinValue.textContent = minVal.toFixed(1);
            trainMaxValue.textContent = maxVal.toFixed(1);
            
            // Use consistent positioning formula accounting for thumb width (34px)
            const minPercent = (minVal - min) / (max - min);
            const maxPercent = (maxVal - min) / (max - min);
            trainMinValue.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            trainMaxValue.style.left = `calc(17px + (100% - 34px) * ${maxPercent})`;
            trainRangeFill.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            trainRangeFill.style.width = `calc((100% - 34px) * ${maxPercent - minPercent})`;
        }
    }
    
    // Update view slider max based on training progress
    function updateViewSliderMax() {
        const viewSlider = document.getElementById('viewSlider');
        const viewValue = document.getElementById('viewValue');
        const viewSliderStrip = document.getElementById('viewSliderStrip');
        
        if (!viewSlider) return;
        
        const totalSteps = history.steps.length;
        
        // Enable slider when we have enough data
        if (viewSliderStrip) {
            if (totalSteps > 50) {
                viewSliderStrip.style.opacity = '1';
                viewSliderStrip.style.pointerEvents = 'auto';
            } else {
                viewSliderStrip.style.opacity = '0.5';
                viewSliderStrip.style.pointerEvents = 'none';
            }
        }
        
        // Update max to current step count (minimum 100 for usability)
        const newMax = Math.max(100, totalSteps);
        viewSlider.max = newMax.toString();
        
        // If slider is at max (showing "All"), keep it at max
        if (traceViewState.maxStep === Infinity || parseInt(viewSlider.value, 10) >= newMax - 10) {
            viewSlider.value = newMax.toString();
            if (viewValue) viewValue.textContent = 'All';
        }
    }
    
    // Color scale is now set once during initial surface computation
    // No blending or recalibration needed with percentile-based approach
    
    // Update loss scale legend based on calibrated values
    function updateLossScaleLegend() {
        const minEl = document.getElementById('lossScaleMin');
        const maxEl = document.getElementById('lossScaleMax');
        
        if (minEl && lossColorScale.calibrated) {
            if (lossColorScale.minLoss < 0.001) {
                minEl.textContent = lossColorScale.minLoss.toExponential(0);
            } else {
                minEl.textContent = lossColorScale.minLoss.toFixed(3);
            }
        }
        
        if (maxEl && lossColorScale.calibrated) {
            if (lossColorScale.maxLoss >= 10) {
                maxEl.textContent = lossColorScale.maxLoss.toFixed(0);
            } else {
                maxEl.textContent = lossColorScale.maxLoss.toFixed(1);
            }
        }
    }
    
    // Update phase UI based on data state
    function updatePhaseUI() {
        const phase1 = document.getElementById('phase1Panel');
        const phase2 = document.getElementById('phase2Panel');
        const dataStatus = document.getElementById('dataStatus');
        const epochStatus = document.getElementById('epochStatus');
        const generateBtn = document.getElementById('generateDataBtn');
        const newDataBtn = document.getElementById('newDataBtn');
        const stepsPerEpoch = document.getElementById('stepsPerEpoch');
        const revealControls = document.getElementById('revealControls');
        const recipeControls = document.getElementById('recipeControls');
        const dataSummary = document.getElementById('dataSummary');
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        
        if (dataset.generated) {
            // Phase 1: Data is ready - keep header bright, show Edit Recipe button
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Hide recipe controls (they get dulled when shown again after collapse)
            recipeControls.style.display = 'none';
            recipeControls.style.opacity = '0.6';
            toggleRecipeBtn.style.display = 'inline-block';
            toggleRecipeBtn.textContent = '‚úèÔ∏è Edit Recipe';
            
            // Show data summary (bright)
            dataSummary.style.display = 'block';
            dataSummary.style.opacity = '1';
            
            // Update data counts
            document.getElementById('trainCount').textContent = dataset.train.length;
            document.getElementById('testCount').textContent = dataset.test.length;
            
            // Show training range info
            const trainRangeLabel = document.getElementById('trainRangeLabel');
            if (trainRangeLabel) {
                trainRangeLabel.textContent = `[${config.trainXMin} to ${config.trainXMax}]`;
            }
            
            // Show test range breakdown
            const testInRange = dataset.test.filter(p => p.inTrainRange).length;
            const testOutRange = dataset.test.length - testInRange;
            const testRangeInfo = document.getElementById('testRangeInfo');
            if (testRangeInfo) {
                if (testOutRange > 0) {
                    testRangeInfo.innerHTML = `<span style="color:#ff9800;">${testInRange} in</span> / <span style="color:#dc3545;">${testOutRange} out</span>`;
                } else {
                    testRangeInfo.textContent = `(all in range)`;
                }
            }
            
            // Update summary note
            const dataSummaryNote = document.getElementById('dataSummaryNote');
            if (dataSummaryNote) {
                if (testOutRange > 0) {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points in range [${config.trainXMin}, ${config.trainXMax}]. ` +
                        `<span style="color:#dc3545;"><strong>${testOutRange}</strong> held-out points are outside this range</span> ‚Äî testing <strong>extrapolation</strong> (can the model generalize beyond its training?).</em>`;
                } else {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points. Held-out data tests if it learned the pattern vs. memorized points.</em>`;
                }
            }
            
            // Populate data previews (show first 4 points each, compact format)
            const formatPoint = (p) => `${p.x.toFixed(1)}‚Üí${p.y.toFixed(2)}`;
            
            const trainPreview = document.getElementById('trainDataPreview');
            const testPreview = document.getElementById('testDataPreview');
            
            // Sort by x for display
            const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
            const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
            
            trainPreview.innerHTML = sortedTrain.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTrain.length > 4 ? `<br><span style="color:#888;">+${sortedTrain.length - 4} more</span>` : '');
            testPreview.innerHTML = sortedTest.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTest.length > 4 ? `<br><span style="color:#888;">+${sortedTest.length - 4} more</span>` : '');
            
            // Update train point count in Fit Plot header
            const trainPointCount = document.getElementById('trainPointCount');
            if (trainPointCount) trainPointCount.textContent = dataset.train.length;
            
            // Enable training range controls
            const trainRangeControls = document.getElementById('trainRangeControls');
            if (trainRangeControls) {
                trainRangeControls.style.opacity = '1';
                trainRangeControls.style.pointerEvents = 'auto';
            }
            
            // Sync mobile training range inputs
            const trainXMinMobile = document.getElementById('trainXMinMobile');
            const trainXMaxMobile = document.getElementById('trainXMaxMobile');
            if (trainXMinMobile) trainXMinMobile.value = config.trainXMin;
            if (trainXMaxMobile) trainXMaxMobile.value = config.trainXMax;
            
            // Enable Phase 3
            const phase3 = document.getElementById('phase3Panel');
            if (phase3) {
                phase3.style.opacity = '1';
                phase3.style.pointerEvents = 'auto';
            }
            
            dataStatus.innerHTML = `‚úì Training data ready`;
            dataStatus.style.color = '#28a745';
            
            // Phase 2: Enable
            phase2.style.opacity = '1';
            phase2.style.pointerEvents = 'auto';
            epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            epochStatus.style.color = '#007bff';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = dataset.train.length;
            
            // Enable reveal controls (Assessment)
            if (revealControls) {
                revealControls.style.opacity = '1';
                revealControls.style.pointerEvents = 'auto';
            }
        } else {
            // Phase 1: Active - show recipe controls (bright)
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Show recipe controls (bright), hide toggle and summary
            recipeControls.style.display = 'flex';
            recipeControls.style.opacity = '1';
            toggleRecipeBtn.style.display = 'none';
            dataSummary.style.display = 'none';
            
            // Enable Phase 1 inputs
            document.getElementById('targetFuncInput').disabled = false;
            document.getElementById('dataXMinInput').disabled = false;
            document.getElementById('dataXMaxInput').disabled = false;
            document.getElementById('trainXMinInput').disabled = false;
            document.getElementById('trainXMaxInput').disabled = false;
            document.getElementById('totalSamples').disabled = false;
            document.getElementById('noise').disabled = false;
            
            dataStatus.textContent = 'Define a data recipe, then generate training data';
            dataStatus.style.color = '#888';
            
            // Phase 2: Disabled
            phase2.style.opacity = '0.5';
            phase2.style.pointerEvents = 'none';
            epochStatus.textContent = 'Generate training data first...';
            epochStatus.style.color = '#888';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = '‚Äî';
            
            // Disable reveal controls
            if (revealControls) {
                revealControls.style.opacity = '0.5';
                revealControls.style.pointerEvents = 'none';
            }
            
            // Reset reveal options (keep showHeldOut always true)
            revealOptions.showHeldOut = true;
            revealOptions.showRecipe = false;
            const showRecipeCheckbox = document.getElementById('showRecipe');
            if (showRecipeCheckbox) showRecipeCheckbox.checked = false;
        }
    }
    
    // Show full data in a popup/modal
    function showFullDataView() {
        if (!dataset.generated) return;
        
        const formatPoint = (p, i) => `${(i+1).toString().padStart(3, ' ')}. x = ${p.x.toFixed(4).padStart(8, ' ')}  ‚Üí  y = ${p.y.toFixed(4)}`;
        
        // Sort by x for display
        const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
        const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
        
        const trainText = sortedTrain.map((p, i) => formatPoint(p, i)).join('\n');
        const testText = sortedTest.map((p, i) => formatPoint(p, i)).join('\n');
        
        const fullText = `TRAINING DATA (${dataset.train.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${trainText}\n\n` +
            `HELD-OUT DATA (${dataset.test.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${testText}`;
        
        // Create a simple modal
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:1000;';
        modal.innerHTML = `
            <div style="background:white; border-radius:8px; padding:16px; max-width:600px; max-height:80vh; overflow:auto; box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <h3 style="margin:0; font-size:16px;">Generated Data (input ‚Üí output)</h3>
                    <button id="closeDataModal" style="padding:4px 12px; font-size:12px;">Close</button>
                </div>
                <pre style="font-size:11px; background:#f5f5f5; padding:12px; border-radius:4px; overflow:auto; max-height:60vh; margin:0;">${fullText}</pre>
                <div style="margin-top:12px; font-size:10px; color:#666;">
                    <strong>Note:</strong> The model only sees the training data. Held-out data is used to test if the model learned the underlying pattern (generalization) vs. just memorizing the training points (overfitting).
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target.id === 'closeDataModal') {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Clear dataset and return to Phase 1
    function clearDataset() {
        dataset.generated = false;
        dataset.train = [];
        dataset.test = [];
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.shuffleOrder = [];
        dataset.totalEpochs = 0;
        
        // Also reset the model
        resetModel();
        updatePhaseUI();
    }
    
    // Reset just the model (keep data)
    function resetModel() {
        const resetStart = performance.now();
        console.log('resetModel: starting...');
        trainingState.running = false;
        trainingState.animating = false;
        trainingState.step = 0;
        trainingState.totalAdds = 0;
        trainingState.totalMuls = 0;
        trainingState.lastUpdateTime = performance.now();
        trainingState.stepsSinceLastUpdate = 0;
        trainingState.recentSamples = [];
        
        // Reset Run button text
        const runBtn = document.getElementById('runBtn');
        if (runBtn) runBtn.textContent = 'Run';
        
        // Reset epoch tracking
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        if (dataset.generated) {
            shuffleTrainingOrder();
        }
        
        history.steps = [];
        history.loss = [];
        history.testLoss = [];
        history.avgLoss = [];
        history.weights = [];
        
        // Reset trace view to show all
        traceViewState.maxStep = Infinity;
        const resetViewSlider = document.getElementById('viewSlider');
        if (resetViewSlider) {
            resetViewSlider.value = resetViewSlider.max;
            const viewValue = document.getElementById('viewValue');
            if (viewValue) viewValue.textContent = 'All';
        }
        
        // Reset evaluation state - must re-evaluate after model reset
        revealOptions.evaluated = false;
        
        exitComparisonMode();
        console.log(`  pre-init: ${(performance.now() - resetStart).toFixed(0)}ms`);
        initializeNetwork();
        console.log(`  initializeNetwork: ${(performance.now() - resetStart).toFixed(0)}ms`);
        
        // Repopulate weight selectors
        populateWeightSelectors();
        console.log(`  populateWeightSelectors: ${(performance.now() - resetStart).toFixed(0)}ms`);
        
        // DON'T clear the loss surface cache on reset - the map is independent of initial position
        // Only clear trail and view bounds for fresh visualization
        lossSurfaceViewBounds = null;  // Reset zoom on fresh start
        lossSurfaceTrail = [];
        
        // Don't reset color scale on model reset - keep it stable
        // Only reset when data is regenerated (handled in generateDataset)
        
        if (lossLandscapeAutoMode) {
            autoSelectInterestingWeights();
        }
        
        // Make w1 and w2 start with LARGER random values for more dramatic visualization
        // This doesn't hurt convergence much but shows more interesting trajectories
        const largeInitScale = 4.0;  // ¬±4 instead of ¬±1
        setWeightByIndex(lossSurfaceWeightIndices[0], (Math.random() - 0.5) * 2 * largeInitScale);
        setWeightByIndex(lossSurfaceWeightIndices[1], (Math.random() - 0.5) * 2 * largeInitScale);
        
        // Record start position
        lossSurfaceStartPosition = {
            x: getWeightByIndex(lossSurfaceWeightIndices[0]),
            y: getWeightByIndex(lossSurfaceWeightIndices[1])
        };
        lossSurfaceTrail = [lossSurfaceStartPosition];
        
        // Only compute loss surface if we don't have one yet
        // The loss map is independent of initial position - it shows "achievable loss" at each (w1,w2)
        if (!lossSurfaceCache) {
            console.log('resetModel: computing loss surface (first time)...');
            const t0 = performance.now();
            computeLossSurface();
            console.log(`  computeLossSurface: ${(performance.now() - t0).toFixed(0)}ms`);
        } else {
            console.log('resetModel: reusing existing loss surface');
        }
        
        drawLossSurface();
        updateLossScaleLegend();
        
        // Compute initial losses if data exists
        if (dataset.generated) {
            const trainLoss = computeTrainLoss();
            const testLoss = computeTestLoss();
            
            history.steps.push(0);
            history.loss.push(trainLoss);
            history.avgLoss.push(null);
            history.testLoss.push({ step: 0, loss: testLoss });
            
            // Record initial weights
            const flatWeights = [];
            network.weights.forEach(layer => {
                if (Array.isArray(layer[0])) {
                    layer.forEach(row => row.forEach(w => flatWeights.push(w)));
                } else {
                    layer.forEach(w => flatWeights.push(w));
                }
            });
            history.weights.push(flatWeights);
        }
        
        const t3 = performance.now();
        updatePhaseUI();
        updateUI();
        console.log(`  updatePhaseUI + updateUI: ${(performance.now() - t3).toFixed(0)}ms`);
        
        // Force redraw all charts to initial state
        const t4 = performance.now();
        drawNetwork();
        drawFitPlot();
        drawTrainingTrace();
        drawLossSurface();
        console.log(`  final draws: ${(performance.now() - t4).toFixed(0)}ms`);
        console.log(`resetModel: TOTAL ${(performance.now() - resetStart).toFixed(0)}ms`);
    }

    function forward(x) {
        const act = activationFns[config.activation].fn;
        const L = network.numLayers;
        const H = network.hiddenSize;

        const activations = [];
        const zValues = [];

        activations.push([x]);

        // Layer 1
        const w0 = network.weights[0];   // [H]
        const b0 = network.biases[0];    // [H]
        let z = new Array(H);
        let a = new Array(H);
        for (let i = 0; i < H; i++) {
            const zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = act(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let l = 1; l < L; l++) {
            const w = network.weights[l];  // [H,H]
            const b = network.biases[l];   // [H]
            const prev = activations[activations.length - 1];

            z = new Array(H);
            a = new Array(H);
            for (let i = 0; i < H; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < H; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = act(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output
        const last = activations[activations.length - 1];
        const wOut = network.weights[network.weights.length - 1]; // [H]
        const bOut = network.biases[network.biases.length - 1][0];
        let yhat = bOut;
        for (let i = 0; i < H; i++) {
            yhat += wOut[i] * last[i];
        }

        return { yhat, activations, zValues };
    }

    function backward(x, y, forwardResult) {
        const { yhat, activations, zValues } = forwardResult;
        const H = network.hiddenSize;
        const L = network.numLayers;
        const actPrime = activationFns[config.activation].dfn;

        const error = yhat - y;
        const loss = 0.5 * error * error;

        // Initialize grads
        for (let l = 0; l < grads.weights.length; l++) {
            if (Array.isArray(grads.weights[l])) {
                if (Array.isArray(grads.weights[l][0])) {
                    for (let i = 0; i < grads.weights[l].length; i++) {
                        grads.weights[l][i].fill(0);
                    }
                } else {
                    grads.weights[l].fill(0);
                }
            }
            grads.biases[l].fill(0);
        }

        // Output layer
        const deltaOut = error;
        const hL = activations[activations.length - 1];

        for (let i = 0; i < H; i++) {
            grads.weights[grads.weights.length - 1][i] = deltaOut * hL[i];
        }
        grads.biases[grads.biases.length - 1][0] = deltaOut;

        let deltaNext = new Array(H);
        for (let i = 0; i < H; i++) {
            deltaNext[i] = network.weights[network.weights.length - 1][i] * deltaOut;
        }

        const deltas = new Array(L);
        for (let l = L - 1; l >= 0; l--) {
            const z = zValues[l];
            const delta = new Array(H);

            for (let i = 0; i < H; i++) {
                delta[i] = deltaNext[i] * actPrime(z[i]);
            }
            deltas[l] = delta;

            // Get input to this layer: for l=0 it's x, otherwise it's activations[l-1]
            const gW = grads.weights[l];
            const gB = grads.biases[l];

            if (l === 0) {
                // First layer: input is x (scalar)
                for (let i = 0; i < H; i++) {
                    gW[i] = delta[i] * x;
                    gB[i] = delta[i];
                }
            } else {
                // Hidden layers: input is previous layer's activations
                const prev = activations[l - 1];
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        gW[i][j] = delta[i] * prev[j];
                    }
                    gB[i] = delta[i];
                }
            }

            if (l > 0) {
                const w = network.weights[l];
                const deltaPrev = new Array(H).fill(0);
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        deltaPrev[j] += w[i][j] * delta[i];
                    }
                }
                deltaNext = deltaPrev;
            }
        }

        return loss;
    }

    // --------------- Training Loop ------------------

    function trainStep() {
        trainingState.stepsSinceLastUpdate++;
        trainingState.step++;
        
        // Advance through the dataset
        if (dataset.generated) {
            dataset.stepInEpoch++;
            
            // Check if we've completed an epoch
            if (dataset.stepInEpoch >= dataset.train.length) {
                dataset.epoch++;
                dataset.totalEpochs++;
                dataset.stepInEpoch = 0;
                shuffleTrainingOrder();  // Reshuffle for next epoch
                
                // Update epoch display
                const epochCount = document.getElementById('epochCount');
                if (epochCount) epochCount.textContent = dataset.epoch;
            }
        }

        const sample = sampleTrainingPoint();
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);

        // Check for NaN - if detected, stop training and warn
        if (!Number.isFinite(loss) || !Number.isFinite(fwd.yhat)) {
            console.warn('NaN detected in training - stopping. Try reducing learning rate or resetting.');
            trainingState.running = false;
            return;
        }

        updateParameters();

        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Evaluate test loss at epoch boundaries (smoother curve)
        if (dataset.generated && dataset.stepInEpoch === 0) {
            const testLoss = computeTestLoss();
            history.testLoss.push({ step: trainingState.step, loss: testLoss, epoch: dataset.epoch });
            
            // Update loss surface periodically during training
            if (dataset.epoch > 0 && dataset.epoch % reprobeInterval === 0 && dataset.epoch !== lastReprobeEpoch) {
                if (lossSurfaceCache) {
                    lastReprobeEpoch = dataset.epoch;
                    
                    if (lossSurfaceCache.usedGreedy) {
                        // Greedy mode: only re-probe blue cells (partial update)
                        const blueThreshold = Math.pow(lossSurfaceCache.maxLoss, 0.3) * Math.pow(lossSurfaceCache.minLoss, 0.7);
                        if (testLoss <= blueThreshold) {
                            reprobeLossSurface();
                        }
                    } else {
                        // Simple slice mode: full recomputation (surface depends on current weights)
                        console.log(`Epoch ${dataset.epoch}: Recomputing loss surface (simple slice mode)`);
                        computeLossSurface();
                        drawLossSurface();
                    }
                }
            }
        }
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);

        const window = config.avgWindow;
        let sum = 0;
        let count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < window; i--, count++) {
            sum += history.loss[i];
        }
        // Only show meaningful average after we have at least 10 data points
        const minPointsForAvg = 10;
        if (history.loss.length >= minPointsForAvg) {
            history.avgLoss.push(sum / count);
        } else {
            history.avgLoss.push(null);  // Will be skipped when drawing
        }

        const maxSamples = 500;
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > maxSamples) {
            trainingState.recentSamples.shift();
        }

        // Accumulate actual ops count
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        // Update loss surface trail - adaptive sampling for full history
        // Record more frequently at start, less frequently as training progresses
        const trailInterval = trainingState.step < 100 ? 2 : 
                             trainingState.step < 1000 ? 5 : 
                             trainingState.step < 5000 ? 10 : 20;
        if (trainingState.step % trailInterval === 0 && lossSurfaceCache) {
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            lossSurfaceTrail.push({ x: wx, y: wy });
            // No limit - keep full history for complete path visualization
            
            // No adaptive zoom - surface is computed once at start
            // Trail may go off-edge, but that's fine for visualization
        }
        
        // Auto-refresh loss surface every N steps (if cache exists)
        if (lossSurfaceAutoUpdate && lossSurfaceCache && trainingState.step % lossSurfaceUpdateInterval === 0) {
            drawLossSurface();
        }
        
        // Update epoch status display
        if (dataset.generated) {
            const epochStatus = document.getElementById('epochStatus');
            if (epochStatus) {
                epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            }
        }
    }

    function runLoop() {
        if (!trainingState.running) return;

        const now = performance.now();
        const stepsPerFrame = 10;
        for (let i = 0; i < stepsPerFrame; i++) {
            trainStep();
        }

        const elapsed = now - trainingState.lastUpdateTime;
        if (elapsed > 0) {
            const stepsPerSec = (stepsPerFrame * 1000) / elapsed;
            document.getElementById('stepsPerSec').textContent = stepsPerSec.toFixed(0);
        }

        trainingState.lastUpdateTime = now;

        updateUI();

        // Auto-pause if no improvement in last 1000 steps
        if (shouldAutoPause()) {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            console.log('Auto-paused: no improvement in last 1000 steps');
            return;
        }

        if (trainingState.running) {
            requestAnimationFrame(runLoop);
        }
    }

    // Full reset - clears data and returns to Phase 1
    function reset() {
        // Stop any ongoing GIF recording
        if (gifCapture.recording || gifCapture.timeout) {
            gifCapture.recording = false;
            gifCapture.gif = null;
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const gifBtn = document.getElementById('gifBtn');
            if (gifBtn) {
                gifBtn.textContent = 'Capture GIF';
                gifBtn.disabled = false;
            }
        }
        
        // Clear dataset and reset model
        clearDataset();
        
        // Compile target function
        compileTargetFunc();
        
        updateUI();
    }

    // --------------- Drawing -----------------------

    function drawNetwork(animState = null) {
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        
        ctx.clearRect(0, 0, w, h);
        
        const numLayers = network.numLayers;
        const hiddenSize = network.hiddenSize;
        
        // Check if weights match current network config (they may not during slider drag)
        // If mismatched, draw structure but skip weight labels
        let weightsValid = false;
        try {
            // Check first layer has correct size
            if (network.weights && network.weights[0] && network.weights[0].length === hiddenSize) {
                // Check output layer has correct size
                const lastLayer = network.weights[network.weights.length - 1];
                if (lastLayer && lastLayer.length === hiddenSize) {
                    weightsValid = true;
                }
            }
        } catch (e) {
            weightsValid = false;
        }
        
        // Animation state
        const isAnimating = animState !== null;
        const animPhase = animState?.phase;
        const animLayer = animState?.layer;
        
        // Layout calculations - input/output gaps are 50% of hidden layer spacing
        const marginLeft = 50;   // Increased for weight labels
        const marginRight = 80;  // Larger to fit y-hat node and weight labels
        const usableWidth = w - marginLeft - marginRight;
        
        // Calculate spacing: input-to-hidden and hidden-to-output are 0.5x the hidden-to-hidden spacing
        // Total segments: 0.5 + (numLayers-1) + 0.5 = numLayers for numLayers >= 1
        // For 1 hidden layer: 0.5 + 0.5 = 1 segment
        // For 2 hidden layers: 0.5 + 1 + 0.5 = 2 segments
        // For 3 hidden layers: 0.5 + 2 + 0.5 = 3 segments
        const totalSegments = numLayers;
        const hiddenLayerSpacing = usableWidth / totalSegments;
        const inputOutputGap = hiddenLayerSpacing * 0.5;  // 50% of hidden layer spacing
        
        const nodeRadius = 20;
        const fontSize = 14;
        const smallFont = 11;
        const weightFont = 9;  // Smaller font for weights
        
        // Calculate positions for each layer
        const layers = [];
        
        // Vertical center offset - move network up slightly to avoid caption overlap
        const yCenter = h/2 - 8;
        
        // Input layer - at left margin
        layers.push({x: marginLeft, nodes: [{y: yCenter}]});
        
        // Hidden layers - spread across the middle
        const hiddenStartX = marginLeft + inputOutputGap;
        for (let l = 0; l < numLayers; l++) {
            const x = hiddenStartX + hiddenLayerSpacing * l;
            const nodes = [];
            const spacing = Math.min(70, (h - 80) / (hiddenSize - 1 || 1));
            const startY = yCenter - (hiddenSize - 1) * spacing / 2;
            for (let i = 0; i < hiddenSize; i++) {
                nodes.push({y: startY + i * spacing});
            }
            layers.push({x, nodes});
        }
        
        // Output layer - at right margin
        layers.push({x: w - marginRight, nodes: [{y: yCenter}]});
        
        // Draw connections with weights
        ctx.font = `${weightFont}px sans-serif`;
        ctx.textAlign = 'center';
        
        // Helper to compute flat weight index for loss landscape highlighting
        function getWeightFlatIndex(layerIdx, fromIdx, toIdx) {
            let idx = 0;
            const H = hiddenSize;
            // Input to first hidden
            if (layerIdx === 0) return toIdx;
            idx += H;
            // Hidden to hidden
            for (let l = 1; l < layerIdx; l++) {
                idx += H * H;
            }
            if (layerIdx < numLayers) {
                return idx + fromIdx * H + toIdx;
            }
            idx += (numLayers - 1) * H * H;
            // Output layer
            return idx + fromIdx;
        }
        
        for (let l = 0; l < layers.length - 1; l++) {
            const fromLayer = layers[l];
            const toLayer = layers[l + 1];
            
            // Highlight during forward animation
            const shouldHighlight = isAnimating && animPhase === 'forward' && animLayer === l + 1;
            
            // Count total connections for offset calculation
            const totalConnections = fromLayer.nodes.length * toLayer.nodes.length;
            let connectionIdx = 0;
            
            // Check for backward pass highlighting
            const shouldHighlightBack = isAnimating && animPhase === 'backward' && animLayer === l + 1;
            
            fromLayer.nodes.forEach((fromNode, fromIdx) => {
                toLayer.nodes.forEach((toNode, toIdx) => {
                    // Check if this weight is selected for loss landscape
                    const flatIdx = getWeightFlatIndex(l, fromIdx, toIdx);
                    const isLossLandscapeWeight = (flatIdx === lossSurfaceWeightIndices[0] || flatIdx === lossSurfaceWeightIndices[1]);
                    
                    // Use green for forward pass, red for backward pass (matches Ops/Step table)
                    if (shouldHighlight) {
                        ctx.strokeStyle = '#28a745';  // Green for forward
                        ctx.lineWidth = 3;
                    } else if (shouldHighlightBack) {
                        ctx.strokeStyle = '#dc3545';  // Red for backward
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#007bff';
                        ctx.lineWidth = 1;
                    }
                    ctx.beginPath();
                    ctx.moveTo(fromLayer.x, fromNode.y);
                    ctx.lineTo(toLayer.x, toNode.y);
                    ctx.stroke();
                    
                    // Draw weight value on connection (only if weights are valid/initialized)
                    if (weightsValid) {
                    // Offset based on connection index, spreading weights along the line
                    // Use narrower range (0.35-0.65) to keep weights away from edges
                    const t = totalConnections > 1 ? 0.35 + 0.3 * (connectionIdx / (totalConnections - 1)) : 0.5;
                    let labelX = fromLayer.x + (toLayer.x - fromLayer.x) * t;
                    let labelY = fromNode.y + (toNode.y - fromNode.y) * t;
                    
                    // Clamp to canvas bounds with padding
                    const textPadding = 20;
                    labelX = Math.max(textPadding, Math.min(w - textPadding, labelX));
                    labelY = Math.max(12, Math.min(h - 12, labelY));
                    
                    let weight;
                    if (l === 0) {
                        weight = network.weights[0][toIdx];
                    } else if (l < numLayers) {
                        weight = network.weights[l][fromIdx] ? network.weights[l][fromIdx][toIdx] : network.weights[l][toIdx];
                    } else {
                        weight = network.weights[network.weights.length - 1][fromIdx];
                    }
                    
                    if (weight !== undefined) {
                        // Draw small background for readability
                        const textWidth = ctx.measureText(weight.toFixed(2)).width;
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillRect(labelX - textWidth/2 - 2, labelY - 8, textWidth + 4, 11);
                        ctx.fillStyle = '#007bff';
                        ctx.fillText(weight.toFixed(2), labelX, labelY);
                        
                        // Subtle blue box for loss landscape weights
                        if (isLossLandscapeWeight) {
                            ctx.strokeStyle = '#007bff';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(labelX - textWidth/2 - 3, labelY - 9, textWidth + 6, 13);
                            }
                        }
                    }
                    connectionIdx++;
                });
            });
        }
        
        // Draw nodes - always use œÉ for activation symbol (standard ML notation)
        const actSymbol = 'œÉ';
        
        // Determine if we can show full equations (small networks only)
        const canShowFullEq = numLayers <= 2 && hiddenSize <= 4;
        const wideRadius = canShowFullEq ? nodeRadius * 2.2 : nodeRadius * 1.15;
        
        // Helper to format weight with sign
        const fmtW = (w) => {
            if (w === undefined || w === null) return '?';
            const val = w.toFixed(2);
            return w >= 0 ? `+${val}` : val;
        };
        const fmtWFirst = (w) => {
            if (w === undefined || w === null) return '?';
            return w.toFixed(2);
        };
        
        layers.forEach((layer, layerIdx) => {
            layer.nodes.forEach((node, nodeIdx) => {
                const nodeHighlight = isAnimating && animPhase === 'forward' && animLayer === layerIdx;
                const showGradients = isAnimating && animPhase === 'backward' && animLayer === layerIdx;
                
                if (layerIdx === 0) {
                    // Input node - small dot
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#333';
                    ctx.beginPath();
                    ctx.arc(layer.x, node.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (layerIdx === layers.length - 1) {
                    // Output node - wider oval
                    const outRadius = canShowFullEq ? wideRadius : nodeRadius * 1.3;
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#f0f8ff';
                    ctx.strokeStyle = '#6f42c1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, outRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Helper for subscript digits in output equation
                    const toSubOut = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
                    
                    if (canShowFullEq) {
                        // Full equation: y = w‚ÇÅ¬∑h‚ÇÅ + w‚ÇÇ¬∑h‚ÇÇ + ... + c (output weights use single subscript w_j)
                        const outputWeights = network.weights[network.weights.length - 1];
                        const outputBias = network.biases[network.biases.length - 1][0];
                        let eqParts = [];
                        for (let i = 0; i < hiddenSize && i < 4; i++) {
                            const wt = outputWeights[i];
                            // For single hidden layer: h_j
                            // For multiple layers: h_ij where i=numLayers (last layer), j=neuron
                            const hRef = numLayers === 1 
                                ? `h${toSubOut(i+1)}`
                                : `h${toSubOut(numLayers)}${toSubOut(i+1)}`;
                            if (i === 0) {
                                eqParts.push(`${fmtWFirst(wt)}¬∑${hRef}`);
                            } else {
                                eqParts.push(`${fmtW(wt)}¬∑${hRef}`);
                            }
                        }
                        if (hiddenSize > 4) eqParts.push('...');
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('y', layer.x, node.y - 8);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Show equation on two lines if needed
                        const eq1 = eqParts.slice(0, 2).join('');
                        const eq2 = eqParts.slice(2).join('') + fmtW(outputBias);
                        ctx.fillText(eq1, layer.x, node.y + 4);
                        if (eq2.length > 3) {
                            ctx.fillText(eq2, layer.x, node.y + 13);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('y', layer.x, node.y - 6);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText('Œ£w‚±º¬∑h‚±º+b', layer.x, node.y + 8);
                    }
                } else {
                    // Hidden node - oval with equation
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#e3f2fd';
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, wideRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Helper for subscript digits
                    const toSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
                    
                    // Notation: h_ij where i=layer, j=neuron (both subscripts)
                    // For single hidden layer, just h_j (neuron position only)
                    const hLabel = numLayers === 1 
                        ? `h${toSub(nodeIdx + 1)}`
                        : `h${toSub(layerIdx)}${toSub(nodeIdx + 1)}`;
                    
                    if (canShowFullEq) {
                        // Full equation: œÉ(w¬∑x + b) for first layer
                        // or œÉ(w‚ÇÅ¬∑h‚ÇÅ‚ÇÅ + w‚ÇÇ¬∑h‚ÇÅ‚ÇÇ + ... + b) for subsequent layers
                        let eqStr = '';
                        if (layerIdx === 1) {
                            // First hidden layer: input is x
                            const w = network.weights[0][nodeIdx];
                            const b = network.biases[0][nodeIdx];
                            eqStr = `${actSymbol}(${fmtWFirst(w)}¬∑x${fmtW(b)})`;
                        } else {
                            // Subsequent hidden layers - reference previous layer's h values (h_ij notation)
                            const prevLayerSize = hiddenSize;
                            const layerWeights = network.weights[layerIdx - 1];
                            const bias = network.biases[layerIdx - 1][nodeIdx];
                            let terms = [];
                            for (let i = 0; i < prevLayerSize && i < 3; i++) {
                                const w = layerWeights[i] ? layerWeights[i][nodeIdx] : layerWeights[nodeIdx];
                                // Previous layer h values: h_ij where i=layerIdx-1, j=neuron
                                const prevH = numLayers === 1 ? `h${toSub(i+1)}` : `h${toSub(layerIdx-1)}${toSub(i+1)}`;
                                if (i === 0) {
                                    terms.push(`${fmtWFirst(w)}¬∑${prevH}`);
                                } else {
                                    terms.push(`${fmtW(w)}¬∑${prevH}`);
                                }
                            }
                            if (prevLayerSize > 3) terms.push('...');
                            eqStr = `${actSymbol}(${terms.join('')}${fmtW(bias)})`;
                        }
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize - 1}px sans-serif`;
                        ctx.fillText(hLabel, layer.x, node.y - 6);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Truncate if too long
                        if (eqStr.length > 20) {
                            ctx.fillText(eqStr.substring(0, 20), layer.x, node.y + 5);
                            ctx.fillText(eqStr.substring(20), layer.x, node.y + 14);
                        } else {
                            ctx.fillText(eqStr, layer.x, node.y + 6);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize}px sans-serif`;
                        ctx.fillText(hLabel, layer.x, node.y - 4);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText(`${actSymbol}(z)`, layer.x, node.y + 8);
                    }
                }
            });
        });
        
        // Draw bias values for all non-input nodes
        // Helper for subscript digits in bias labels
        const toBiasSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
        
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        layers.forEach((layer, layerIdx) => {
            if (layerIdx === 0) return;  // Skip input layer
            
            layer.nodes.forEach((node, nodeIdx) => {
                let bias = 0;
                let biasLabel = 'b';
                
                if (layerIdx < layers.length - 1) {
                    // Hidden layer bias: b_ij (layer, neuron)
                    bias = network.biases[layerIdx - 1] ? network.biases[layerIdx - 1][nodeIdx] : 0;
                    // For single layer: b_j, for multi-layer: b_ij
                    biasLabel = numLayers === 1 
                        ? `b${toBiasSub(nodeIdx + 1)}`
                        : `b${toBiasSub(layerIdx)}${toBiasSub(nodeIdx + 1)}`;
                } else {
                    // Output layer bias: just b (single bias for output)
                    bias = network.biases[network.biases.length - 1] ? network.biases[network.biases.length - 1][0] : 0;
                    biasLabel = 'b';
                }
                
                // Draw bias value below node (closer to bubble)
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                const biasText = `${biasLabel}=${bias.toFixed(1)}`;
                const textW = ctx.measureText(biasText).width;
                ctx.fillRect(layer.x - textW/2 - 1, node.y + nodeRadius - 1, textW + 2, 10);
                ctx.fillStyle = '#e67e22';
                ctx.fillText(biasText, layer.x, node.y + nodeRadius + 7);
            });
        });
        
        // Input label - larger and bolder
        ctx.fillStyle = '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('x', layers[0].x, layers[0].nodes[0].y - 12);
        
        // Show current values: x, t (target), y (prediction), and E (error)
        if (trainingState.recentSamples.length > 0) {
            const lastSample = trainingState.recentSamples[trainingState.recentSamples.length - 1];
            const lastLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : null;
            
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            
            // Left side: input and target (t for target)
            ctx.fillText(`x = ${lastSample.x.toFixed(3)}`, 8, 18);
            ctx.fillText(`t = ${lastSample.y.toFixed(3)}`, 8, 32);
            
            // Right side: prediction (y) and error (E)
            ctx.textAlign = 'right';
            if (history.loss.length > 0) {
                const fwd = forward(lastSample.x);
                ctx.fillText(`y = ${fwd.yhat.toFixed(3)}`, w - 8, 18);
                ctx.fillStyle = lastLoss < 0.01 ? '#28a745' : '#dc3545';
                ctx.fillText(`E = ¬Ω(y‚àít)¬≤ = ${lastLoss.toFixed(4)}`, w - 8, 32);
            }
        }
        
        // Bottom: architecture info - larger font for readability
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        const optName = config.optimizer === 'sgd' ? 'Simple' : 'Adam';
        const actName = config.activation === 'relu' ? 'ReLU' : 'Sigmoid';
        // Count total weights: first layer (H) + hidden layers ((L-1)*H*H) + output layer (H)
        const totalWeights = hiddenSize + (numLayers - 1) * hiddenSize * hiddenSize + hiddenSize;
        const totalBiases = numLayers * hiddenSize + 1;
        const totalParams = totalWeights + totalBiases;
        ctx.fillText(`${numLayers} hidden layer${numLayers > 1 ? 's' : ''} √ó ${hiddenSize} neurons  ‚Ä¢  ${totalParams} params  ‚Ä¢  œÉ = ${actName}  ‚Ä¢  ${optName}`, w/2, h - 6);
        
        // Update HTML Ops/Step table (check elements exist first)
        const ops = computeOpsPerStep();
        const opsFwdAdds = document.getElementById('opsFwdAdds');
        const opsFwdMuls = document.getElementById('opsFwdMuls');
        const opsBackAdds = document.getElementById('opsBackAdds');
        const opsBackMuls = document.getElementById('opsBackMuls');
        const opsTotAdds = document.getElementById('opsTotAdds');
        const opsTotMuls = document.getElementById('opsTotMuls');
        
        if (opsFwdAdds) opsFwdAdds.textContent = ops.fwdAdds;
        if (opsFwdMuls) opsFwdMuls.textContent = ops.fwdMuls;
        if (opsBackAdds) opsBackAdds.textContent = ops.backAdds;
        if (opsBackMuls) opsBackMuls.textContent = ops.backMuls;
        if (opsTotAdds) opsTotAdds.textContent = ops.fwdAdds + ops.backAdds;
        if (opsTotMuls) opsTotMuls.textContent = ops.fwdMuls + ops.backMuls;
    }
    
    // Animated step function
    async function animatedStep() {
        if (trainingState.animating) return;
        trainingState.animating = true;
        
        // Sample data
        const sample = sampleTrainingPoint();
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > 500) {
            trainingState.recentSamples.shift();
        }
        
        const numLayers = network.numLayers;
        const delayPerLayer = 300; // 0.3 seconds per layer
        
        // Animate forward pass
        drawNetwork({phase: 'forward', layer: 0});
        await sleep(delayPerLayer);
        
        for (let i = 1; i <= numLayers; i++) {
            drawNetwork({phase: 'forward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'forward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        // Compute forward and backward
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);
        
        // Animate backward pass
        drawNetwork({phase: 'backward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        for (let i = numLayers; i >= 1; i--) {
            drawNetwork({phase: 'backward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'backward', layer: 0});
        await sleep(delayPerLayer);
        
        // Update parameters
        updateParameters();
        
        // Update history
        trainingState.step++;
        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);
        
        const windowSize = config.avgWindow;
        let sum = 0, count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < windowSize; i--, count++) {
            sum += history.loss[i];
        }
        history.avgLoss.push(sum / Math.max(1, count));
        
        // Update ops
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        trainingState.animating = false;
        updateUI();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function updateEquations() {
        const L = network.numLayers;
        const H = network.hiddenSize;
        const act = config.activation;
        const actName = act === 'relu' ? 'ReLU' : 'Sigmoid';
        const actSymbol = act === 'relu' ? 'ReLU' : 'œÉ';
        
        // Subscript helper
        const sub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[parseInt(d)] || d).join('');
        
        // Count total parameters
        const totalParams = network.weights.reduce((sum, layer) => sum + layer.length, 0) +
                           network.biases.reduce((sum, layer) => sum + layer.length, 0);
        
        // Build architecture string: 1 ‚Üí H ‚Üí H ‚Üí ... ‚Üí 1
        const archParts = ['1'];
        for (let i = 0; i < L; i++) archParts.push(H.toString());
        archParts.push('1');
        const archStr = archParts.join(' ‚Üí ');
        
        // Decide: use explicit layer-by-layer or compact parameterized form
        const useExplicit = (L <= 2 && H <= 4);
        
        // Layer variable names: a, b, c, d, e... for layers 1, 2, 3, 4, 5...
        const layerVars = ['a', 'b', 'c', 'd', 'e', 'f'];
        
        // ====== ARCHITECTURE BLOCK ======
        let archHtml = `
            <div style="background:#f8f9fa; padding:6px 10px; border-radius:4px; margin-bottom:8px; border-left:3px solid #007bff;">
                <strong style="color:#007bff;">Network Architecture</strong><br>
                <span style="font-family:monospace; font-size:13px;">${archStr}</span><br>
                <span style="color:#666; font-size:10px;">
                    ${L} hidden layer${L>1?'s':''} √ó ${H} neurons = <strong>${totalParams} parameters</strong>
                </span>
            </div>
        `;
        
        // ====== FORWARD PASS ======
        let forwardHtml = '';
        
        // Activation function definition
        const actDef = act === 'relu' 
            ? `<span style="color:#28a745">${actSymbol}(z)</span> = max(0, z)`
            : `<span style="color:#28a745">${actSymbol}(z)</span> = 1/(1+e<sup>‚àíz</sup>)`;
        
        forwardHtml += `<strong>Activation:</strong> ${actDef}<br><br>`;
        
        if (useExplicit) {
            // ====== EXPLICIT LAYER-BY-LAYER (small networks) ======
            
            // Layer 1: input ‚Üí first hidden (using variable 'a')
            const v1 = layerVars[0];
            forwardHtml += `<strong style="color:#007bff;">Layer 1</strong> <span style="color:#888">(x ‚Üí ${v1})</span><br>`;
            for (let j = 1; j <= H; j++) {
                forwardHtml += `&nbsp;&nbsp;${v1}${sub(j)} = ${actSymbol}(w${sub(j)}¬∑x + b${sub(j)})<br>`;
            }
            
            // Layer 2 if present
            if (L >= 2) {
                const vPrev = layerVars[0];
                const vCurr = layerVars[1];
                forwardHtml += `<br><strong style="color:#007bff;">Layer 2</strong> <span style="color:#888">(${vPrev} ‚Üí ${vCurr})</span><br>`;
                for (let j = 1; j <= H; j++) {
                    forwardHtml += `&nbsp;&nbsp;${vCurr}${sub(j)} = ${actSymbol}(`;
                    for (let k = 1; k <= H; k++) {
                        forwardHtml += `w${sub(k)}${sub(j)}¬∑${vPrev}${sub(k)}`;
                        if (k < H) forwardHtml += ' + ';
                    }
                    forwardHtml += ` + b${sub(j)})<br>`;
                }
            }
            
            // Output layer
            const vLast = layerVars[L - 1];
            forwardHtml += `<br><strong style="color:#6f42c1;">Output</strong> <span style="color:#888">(${vLast} ‚Üí y)</span><br>`;
            forwardHtml += `&nbsp;&nbsp;<span style="color:#6f42c1">y</span> = `;
            for (let j = 1; j <= H; j++) {
                forwardHtml += `v${sub(j)}¬∑${vLast}${sub(j)}`;
                if (j < H) forwardHtml += ' + ';
            }
            forwardHtml += ` + c<br>`;
            
        } else {
            // ====== PARAMETERIZED FORM (larger networks) ======
            forwardHtml += `<strong style="color:#007bff;">Hidden layers</strong> <span style="color:#888">(‚Ñì = 1 to ${L})</span><br>`;
            forwardHtml += `&nbsp;&nbsp;h<sup>‚Ñì</sup><sub>j</sub> = ${actSymbol}(Œ£<sub>k</sub> w<sup>‚Ñì</sup><sub>kj</sub> ¬∑ h<sup>‚Ñì‚àí1</sup><sub>k</sub> + b<sup>‚Ñì</sup><sub>j</sub>)<br>`;
            forwardHtml += `&nbsp;&nbsp;<em style="color:#888; font-size:10px;">where h<sup>0</sup> = x (input), j = 1..${H}</em><br>`;
            
            forwardHtml += `<br><strong style="color:#6f42c1;">Output</strong><br>`;
            forwardHtml += `&nbsp;&nbsp;<span style="color:#6f42c1">y</span> = Œ£<sub>j</sub> v<sub>j</sub> ¬∑ h<sup>${L}</sup><sub>j</sub> + c<br>`;
        }
        
        // Error (same for both)
        forwardHtml += `<br><strong style="color:#dc3545;">Error:</strong> E = ¬Ω(y ‚àí target)¬≤`;
        
        // ====== BACKWARD PASS ======
        let backwardHtml = '';
        
        // Activation derivative
        const actDerivExplain = act === 'relu' 
            ? `<span style="color:#28a745">${actSymbol}'(z)</span> = 1 if z &gt; 0, else 0`
            : `<span style="color:#28a745">${actSymbol}'(z)</span> = ${actSymbol}¬∑(1 ‚àí ${actSymbol})`;
        
        backwardHtml += `<strong>Activation derivative:</strong><br>${actDerivExplain}<br><br>`;
        
        if (useExplicit) {
            // ====== EXPLICIT BACKWARD (small networks) ======
            const vLast = layerVars[L - 1];
            
            // Output gradients
            backwardHtml += `<strong style="color:#6f42c1;">Output gradients:</strong><br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇy = y ‚àí target<br>`;
            for (let j = 1; j <= H; j++) {
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇv${sub(j)} = (y ‚àí target)¬∑${vLast}${sub(j)}<br>`;
            }
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇc = y ‚àí target<br>`;
            
            // Layer 2 gradients (if present)
            if (L >= 2) {
                const vCurr = layerVars[1];
                backwardHtml += `<br><strong style="color:#007bff;">Layer 2 gradients:</strong><br>`;
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇ${vCurr}<sub>j</sub> = (y ‚àí target)¬∑v<sub>j</sub><br>`;
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇz<sub>j</sub> = (‚àÇE/‚àÇ${vCurr}<sub>j</sub>)¬∑${actSymbol}'(z<sub>j</sub>)<br>`;
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇw<sub>kj</sub> = (‚àÇE/‚àÇz<sub>j</sub>)¬∑a<sub>k</sub><br>`;
            }
            
            // Layer 1 gradients
            const v1 = layerVars[0];
            backwardHtml += `<br><strong style="color:#007bff;">Layer 1 gradients:</strong><br>`;
            if (L >= 2) {
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇ${v1}<sub>j</sub> = Œ£<sub>k</sub>(‚àÇE/‚àÇb<sub>k</sub>)¬∑w<sub>jk</sub><br>`;
            } else {
                backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇ${v1}<sub>j</sub> = (y ‚àí target)¬∑v<sub>j</sub><br>`;
            }
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇz<sub>j</sub> = (‚àÇE/‚àÇ${v1}<sub>j</sub>)¬∑${actSymbol}'(z<sub>j</sub>)<br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇw<sub>j</sub> = (‚àÇE/‚àÇz<sub>j</sub>)¬∑x<br>`;
            
        } else {
            // ====== PARAMETERIZED BACKWARD (larger networks) ======
            backwardHtml += `<strong style="color:#6f42c1;">Output gradients:</strong><br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇy = y ‚àí target<br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇv<sub>j</sub> = (y ‚àí target)¬∑h<sup>${L}</sup><sub>j</sub><br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇc = y ‚àí target<br>`;
            
            backwardHtml += `<br><strong style="color:#007bff;">Hidden layer gradients</strong> <span style="color:#888">(‚Ñì = ${L} down to 1)</span><br>`;
            backwardHtml += `&nbsp;&nbsp;Œ¥<sup>‚Ñì</sup><sub>j</sub> = (Œ£<sub>k</sub> Œ¥<sup>‚Ñì+1</sup><sub>k</sub>¬∑w<sup>‚Ñì+1</sup><sub>jk</sub>) ¬∑ ${actSymbol}'(z<sup>‚Ñì</sup><sub>j</sub>)<br>`;
            backwardHtml += `&nbsp;&nbsp;<em style="color:#888; font-size:10px;">where Œ¥<sup>${L+1}</sup> = y ‚àí target</em><br>`;
            
            backwardHtml += `<br><strong>Weight gradients:</strong><br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇw<sup>‚Ñì</sup><sub>kj</sub> = Œ¥<sup>‚Ñì</sup><sub>j</sub> ¬∑ h<sup>‚Ñì‚àí1</sup><sub>k</sub><br>`;
            backwardHtml += `&nbsp;&nbsp;‚àÇE/‚àÇb<sup>‚Ñì</sup><sub>j</sub> = Œ¥<sup>‚Ñì</sup><sub>j</sub><br>`;
        }
        
        // ====== OPTIMIZER ======
        const optName = config.optimizer === 'sgd' ? 'SGD' : 'Adam';
        const lr = config.learningRate;
        
        let optHtml = '';
        if (config.optimizer === 'sgd') {
            optHtml = `
                <strong>Gradient Descent:</strong><br>
                &nbsp;&nbsp;w ‚Üê w ‚àí Œ∑¬∑‚àÇE/‚àÇw<br>
                &nbsp;&nbsp;b ‚Üê b ‚àí Œ∑¬∑‚àÇE/‚àÇb<br><br>
                <em style="color:#888; font-size:10px;">Learning rate Œ∑ = ${lr}</em><br>
                <em style="color:#888; font-size:10px;">Each step moves downhill on the error surface.</em>
            `;
        } else {
            optHtml = `
                <strong>Adam (Adaptive Moments):</strong><br>
                &nbsp;&nbsp;m ‚Üê 0.9¬∑m + 0.1¬∑‚àáE<br>
                &nbsp;&nbsp;v ‚Üê 0.999¬∑v + 0.001¬∑(‚àáE)¬≤<br>
                &nbsp;&nbsp;w ‚Üê w ‚àí Œ∑¬∑m/‚àö(v + Œµ)<br><br>
                <em style="color:#888; font-size:10px;">Œ∑ = ${lr}, m = momentum, v = adaptive scale</em>
            `;
        }
        
        // ====== ASSEMBLE HTML ======
        const html = `
            <div class="equation-block" style="grid-column: 1 / -1;">
                ${archHtml}
            </div>
            <div class="equation-block">
                <div class="equation-title">Forward Pass</div>
                <div class="math">${forwardHtml}</div>
            </div>
            <div class="equation-block">
                <div class="equation-title">Backward Pass</div>
                <div class="math">${backwardHtml}</div>
            </div>
            <div class="equation-block">
                <div class="equation-title">Optimizer: ${optName}</div>
                <div class="math">${optHtml}</div>
            </div>
        `;
        
        document.getElementById('equationsDiv').innerHTML = html;
    }


    function drawFitPlot() {
        const canvas = document.getElementById('fitCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 60;
        const paddingRight = 60;
        const paddingTop = 40;
        const paddingBottom = 40;

        ctx.clearRect(0, 0, w, h);
        
        // Show placeholder if no training data yet
        if (!dataset.generated || dataset.train.length === 0) {
            ctx.fillStyle = '#888';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Generate training data to see examples', w/2, h/2);
            return;
        }

        const xMin = config.xMin;
        const xMax = config.xMax;
        const xRange = xMax - xMin;

        const hasRunA = !!savedRuns.A;
        const hasRunB = !!savedRuns.B;
        const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

        // Generate model prediction curve
        const numPoints = 200;
        const modelPoints = [];
        let modelPointsA = null;
        let modelPointsB = null;

        for (let i = 0; i <= numPoints; i++) {
            const x = xMin + (i / numPoints) * xRange;
            if (comparisonMode) {
                if (!modelPointsA) modelPointsA = [];
                if (!modelPointsB) modelPointsB = [];
                const netA = savedRuns.A.network;
                const cfgA = savedRuns.A.config;
                const netB = savedRuns.B.network;
                const cfgB = savedRuns.B.config;
                modelPointsA.push({ x, y: forwardWithNetwork(x, netA, cfgA.activation) });
                modelPointsB.push({ x, y: forwardWithNetwork(x, netB, cfgB.activation) });
            } else {
                modelPoints.push({ x, y: forward(x).yhat });
            }
        }

        // Collect all Y values for axis range calculation
        // PRIORITY: Actual data points must always fit in the plot
        let dataY = [];  // Y values from actual data points
        let funcY = [];  // Y values from target function (filtered for sanity)
        
        // Include ALL training and test data points first (these MUST fit)
        if (dataset.generated) {
            dataset.train.forEach(p => dataY.push(p.y));
            dataset.test.forEach(p => dataY.push(p.y));
        }
        
        // Sample target function - but filter out extreme values (asymptotes, etc.)
        const rawFuncY = [];
        for (let i = 0; i <= 50; i++) {
            const x = xMin + (i / 50) * xRange;
            try { 
                const y = config.targetFunc(x);
                if (Number.isFinite(y)) rawFuncY.push(y);
            } catch { /* ignore */ }
        }
        
        // Filter out outliers from target function (use IQR method)
        if (rawFuncY.length > 0) {
            const sorted = [...rawFuncY].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const iqr = q3 - q1;
            const lowerBound = q1 - 3 * iqr;  // 3x IQR for generous bounds
            const upperBound = q3 + 3 * iqr;
            rawFuncY.forEach(y => {
                if (y >= lowerBound && y <= upperBound) {
                    funcY.push(y);
                }
            });
            // If filtering removed everything, use median ¬± reasonable range
            if (funcY.length === 0) {
                const median = sorted[Math.floor(sorted.length / 2)];
                funcY.push(median - 2, median + 2);
            }
        }
        
        // Use cached Y range if available (stable during training)
        // Otherwise calculate from current data
        let yMin, yMax;
        
        if (fitPlotYRange.initialized) {
            // Use stable cached range
            yMin = fitPlotYRange.min;
            yMax = fitPlotYRange.max;
        } else {
            // Fallback: calculate from data (only before data generation)
            const dataYMin = dataY.length > 0 ? Math.min(...dataY) : (funcY.length > 0 ? Math.min(...funcY) : -1);
            const dataYMax = dataY.length > 0 ? Math.max(...dataY) : (funcY.length > 0 ? Math.max(...funcY) : 1);
            
            let allY = [...dataY, ...funcY];
            if (allY.length === 0) allY = [-1, 1];
            
            yMin = Math.min(...allY);
            yMax = Math.max(...allY);
            if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
                yMin = -1;
                yMax = 1;
            }
            
            const yPad = (yMax - yMin) * 0.15 || 0.5;
            yMin -= yPad;
            yMax += yPad;
        }
        
        const yRange = yMax - yMin || 1;

        const plotWidth = w - paddingLeft - paddingRight;
        const plotHeight = h - paddingTop - paddingBottom;
        const toCanvasX = (x) => paddingLeft + (x - xMin) / xRange * plotWidth;
        const toCanvasY = (y) => h - paddingBottom - (y - yMin) / yRange * plotHeight;

        // Draw plot border
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotWidth, plotHeight);

        // Draw X axis tick marks and labels
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const numXTicks = 5;
        for (let i = 0; i <= numXTicks; i++) {
            const xVal = xMin + (i / numXTicks) * xRange;
            const cx = toCanvasX(xVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(cx, h - paddingBottom);
            ctx.lineTo(cx, h - paddingBottom + 5);
            ctx.stroke();
            ctx.fillText(xVal.toFixed(1), cx, h - paddingBottom + 16);
        }

        // Draw Y axis tick marks and labels
        ctx.textAlign = 'right';
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            const yVal = yMin + (i / numYTicks) * yRange;
            const cy = toCanvasY(yVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(paddingLeft - 5, cy);
            ctx.lineTo(paddingLeft, cy);
            ctx.stroke();
            ctx.fillText(yVal.toFixed(2), paddingLeft - 8, cy + 3);
        }

        // Draw data recipe curve (only if revealing or no data yet) - CLIPPED to plot area
        if (!dataset.generated || revealOptions.showRecipe) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(paddingLeft, paddingTop, plotWidth, plotHeight);
            ctx.clip();
            
            const recipeAlpha = dataset.generated ? 0.4 : 0.3;
            ctx.strokeStyle = `rgba(40, 167, 69, ${recipeAlpha})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = xMin + (i / 100) * xRange;
                let y;
                try { y = config.targetFunc(x); } catch { y = 0; }
                const cx = toCanvasX(x);
                const cy = toCanvasY(y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
        }

        // Draw training examples (filled circles) - always shown when data exists
        if (dataset.generated && dataset.train.length > 0) {
            ctx.fillStyle = '#007bff';
            dataset.train.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Draw training range indicator (vertical bands showing where model was trained)
        if (dataset.generated && (config.trainXMin > config.dataXMin || config.trainXMax < config.dataXMax)) {
            ctx.fillStyle = 'rgba(0, 123, 255, 0.05)';
            const trainLeft = toCanvasX(config.trainXMin);
            const trainRight = toCanvasX(config.trainXMax);
            ctx.fillRect(trainLeft, paddingTop, trainRight - trainLeft, plotHeight);
            
            // Draw dashed vertical lines at training boundaries
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(trainLeft, paddingTop);
            ctx.lineTo(trainLeft, h - paddingBottom);
            ctx.moveTo(trainRight, paddingTop);
            ctx.lineTo(trainRight, h - paddingBottom);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw held-out examples - always visible (yellow-orange triangles)
        if (dataset.generated && dataset.test.length > 0) {
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 1.5;
            ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
            
            dataset.test.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                
                // Draw triangle shape (pointing up)
                ctx.beginPath();
                ctx.moveTo(cx, cy - 5);      // top
                ctx.lineTo(cx + 4.5, cy + 4); // bottom right
                ctx.lineTo(cx - 4.5, cy + 4); // bottom left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
        }

        // Draw model prediction curve - clipped to plot area
        ctx.save();
        ctx.beginPath();
        ctx.rect(paddingLeft, paddingTop, plotWidth, plotHeight);
        ctx.clip();
        
        if (comparisonMode) {
            // Model A - blue
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsA.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Model B - orange
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsB.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        } else {
            // Single model - purple
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            modelPoints.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        }
        ctx.restore();  // Remove clipping

        // Axis labels
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('x', w / 2, h - 8);
        ctx.save();
        ctx.translate(10, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('y', 0, 0);
        ctx.restore();

        // Legend
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'left';
        const legendY = 14;
        let legendX = w - 350;

        if (dataset.generated) {
            // Training examples - blue circle
            ctx.fillStyle = '#007bff';
            ctx.beginPath();
            ctx.arc(legendX + 4, legendY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillText(`Training (${dataset.train.length})`, legendX + 12, legendY + 3);
            legendX += 75;

            // Held-out examples - always shown (yellow-orange triangle)
            if (dataset.test.length > 0) {
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 1.5;
                ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
                    ctx.beginPath();
                ctx.moveTo(legendX + 4, legendY - 4);      // top
                ctx.lineTo(legendX + 8.5, legendY + 4);    // bottom right
                ctx.lineTo(legendX - 0.5, legendY + 4);    // bottom left
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                ctx.fillText(`Held-Out (${dataset.test.length})`, legendX + 12, legendY + 3);
                legendX += 80;
            }
            
            // Data recipe - green dashed (only if revealed)
            if (revealOptions.showRecipe) {
                ctx.strokeStyle = 'rgba(40, 167, 69, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 2]);
                ctx.beginPath();
                ctx.moveTo(legendX, legendY);
                ctx.lineTo(legendX + 16, legendY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#333';
                ctx.fillText('Recipe', legendX + 20, legendY + 3);
                legendX += 55;
            }
        } else {
            // No data yet - show recipe preview
            ctx.strokeStyle = 'rgba(40, 167, 69, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#333';
            ctx.fillText('Recipe preview', legendX + 20, legendY + 3);
            legendX += 95;
        }

        // Model prediction - purple line
        if (dataset.generated) {
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model', legendX + 20, legendY + 3);
        }

        if (comparisonMode) {
            legendX += 55;
            ctx.strokeStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model B', legendX + 20, legendY + 3);
        }
    }

    function drawTrainingTraceComparison(ctx, w, h,
                                     paddingLeft, paddingRight,
                                     paddingTop, paddingBottom,
                                     runA, runB,
                                     showLoss, showAvgLoss, useLogScale = false,
                                     viewEndStep = null) {
    if (!runA || !runB) return;

    // Apply view filtering if specified
    let filteredRunA = runA;
    let filteredRunB = runB;
    if (viewEndStep !== null) {
        // Find index where step exceeds viewEndStep
        const idxA = runA.steps.findIndex(s => s > viewEndStep);
        const endIdxA = idxA === -1 ? runA.steps.length : idxA;
        filteredRunA = {
            steps: runA.steps.slice(0, endIdxA),
            loss: runA.loss.slice(0, endIdxA),
            avgLoss: runA.avgLoss.slice(0, endIdxA)
        };
        
        const idxB = runB.steps.findIndex(s => s > viewEndStep);
        const endIdxB = idxB === -1 ? runB.steps.length : idxB;
        filteredRunB = {
            steps: runB.steps.slice(0, endIdxB),
            loss: runB.loss.slice(0, endIdxB),
            avgLoss: runB.avgLoss.slice(0, endIdxB)
        };
    }

    const series = [];

    if (showLoss) {
        series.push({
            name: 'Error A',
            steps: filteredRunA.steps,
            data: filteredRunA.loss,
            color: '#dc3545',
            lineWidth: 2
        });
        series.push({
            name: 'Error B',
            steps: filteredRunB.steps,
            data: filteredRunB.loss,
            color: '#ff9800',
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.avgLoss,
            color: '#007bff',
            lineWidth: 3
        });
        series.push({
            name: 'Avg Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.avgLoss,
            color: '#00bcd4',
            lineWidth: 3
        });
    }

    if (series.length === 0) return;

    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X (steps)
    let stepMin = Infinity;
    let stepMax = -Infinity;
    series.forEach(s => {
        if (s.steps.length > 0) {
            stepMin = Math.min(stepMin, s.steps[0]);
            stepMax = Math.max(stepMax, s.steps[s.steps.length - 1]);
        }
    });
    if (!Number.isFinite(stepMin) || !Number.isFinite(stepMax)) return;
    const stepRange = stepMax - stepMin || 1;

    // Y (loss, linear)
    let yMin = Infinity;
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v)) return;
            yMin = Math.min(yMin, v);
            yMax = Math.max(yMax, v);
        });
    });
    if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
        yMin = 0;
        yMax = 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(1e-6, Math.abs(yMin) * 0.1);
        yMin -= eps;
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMin -= pad;
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) =>
        h - paddingBottom - ((val - yMin) / yRange) * plotHeight;

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicksComp = getNiceTicks(stepMin, stepMax, 5);
    xTicksComp.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values
    ctx.textAlign = 'right';
    const yTicksComp = getNiceTicks(yMin, yMax, 5);
    yTicksComp.forEach(val => {
        if (val < yMin || val > yMax) return;
        const y = toY(val);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        ctx.fillText(val.toPrecision(3), paddingLeft - 4, y + 3);
    });

    // Axis labels - moved further left to avoid overlap with tick labels
    ctx.save();
    ctx.translate(10, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText(useLogScale ? 'Error (log‚ÇÅ‚ÇÄ)' : 'Error (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        for (let i = 0; i < s.data.length; i++) {
            const x = toX(s.steps[i]);
            const y = toY(s.data[i]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    });

    // Legend - 2 columns to avoid overlap
    const legendStartX = w / 2 - 120;
    const legendColWidth = 110;
    const legendStartY = 12;
    const legendRowHeight = 14;
    
    series.forEach((s, i) => {
        const col = i % 2;  // 0 or 1
        const row = Math.floor(i / 2);  // 0, 1, ...
        const x = legendStartX + col * legendColWidth;
        const y = legendStartY + row * legendRowHeight;
        
        ctx.fillStyle = s.color;
        ctx.fillRect(x, y, 20, s.lineWidth);
        ctx.fillStyle = '#333';
        ctx.font = s.lineWidth === 3 ? 'bold 10px sans-serif' : '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(s.name, x + 24, y + 4);
    });
}

function drawTrainingTrace() {
    const canvas = document.getElementById('traceCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const paddingLeft = 60;
    const paddingRight = 60;
    const paddingTop = 40;
    const paddingBottom = 40;

    ctx.clearRect(0, 0, w, h);

    const showLoss = document.getElementById('traceLoss').checked;
    const showAvgLoss = document.getElementById('traceAvgLoss').checked;
    const showWeights = document.getElementById('traceWeights').checked;
    const useLogScale = document.getElementById('traceLogScale').checked;

    const hasRunA = !!savedRuns.A;
    const hasRunB = !!savedRuns.B;
    const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

    // Determine max steps for zoom handle (works for both normal and comparison modes)
    let maxSteps;
    if (comparisonMode) {
        maxSteps = Math.max(
            savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
            savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
        );
    } else {
        maxSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
    }
    
    // Show view handle when we have enough data to zoom
    const viewHandle = document.getElementById('traceViewHandle');
    const hasEnoughData = comparisonMode ? maxSteps > 50 : history.steps.length > 50;
    if (viewHandle) {
        if (hasEnoughData) {
            viewHandle.style.display = 'flex';
            viewHandle.style.opacity = '0.9';
        } else {
            viewHandle.style.display = 'none';
        }
        
        // Reset view when running (show all)
        if (trainingState.running) {
            traceViewState.maxStep = Infinity;
        }
    }

    if (comparisonMode) {
        drawTrainingTraceComparison(
            ctx, w, h,
            paddingLeft, paddingRight,
            paddingTop, paddingBottom,
            savedRuns.A, savedRuns.B,
            showLoss, showAvgLoss, useLogScale,
            traceViewState.maxStep  // Pass the view end step
        );
        return;
    }

    // Draw axes even when no data yet
    const hasData = history.steps.length > 0;
    
    // Calculate view window: always start from 0, end based on traceViewState.maxStep
    let viewStartIdx = 0;
    let viewEndIdx = history.steps.length;
    
    // If we have a view max step set (not Infinity), use it
    if (traceViewState.maxStep !== Infinity && traceViewState.maxStep < history.steps.length) {
        viewEndIdx = Math.max(10, traceViewState.maxStep);
    }
    
    // Get sliced data for the view
    const viewSteps = hasData ? history.steps.slice(viewStartIdx, viewEndIdx) : [];
    const viewLoss = hasData ? history.loss.slice(viewStartIdx, viewEndIdx) : [];
    const viewAvgLoss = hasData ? history.avgLoss.slice(viewStartIdx, viewEndIdx) : [];
    
    const series = [];

    if (showLoss) {
        series.push({
            name: 'Train Error',
            steps: viewSteps,
            data: viewLoss,
            color: '#28a745',  // Green for training (matches train points)
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Error',
            steps: viewSteps,
            data: viewAvgLoss,
            color: '#007bff',
            lineWidth: 3
        });
    }
    
    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X axis range (use defaults if no data) - declare early so test loss filter can use it
    const stepMin = viewSteps.length > 0 ? viewSteps[0] : 0;
    const stepMax = viewSteps.length > 0 ? viewSteps[viewSteps.length - 1] : 100;
    const stepRange = stepMax - stepMin || 100;

    // Add test loss series if evaluated (only show after clicking Evaluate button)
    if (showLoss && history.testLoss.length > 0 && revealOptions.evaluated) {
        // Filter test loss to view window
        const viewTestLoss = history.testLoss.filter(t => 
            t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)
        );
        if (viewTestLoss.length > 0) {
            series.push({
                name: 'Test Error',
                steps: viewTestLoss.map(t => t.step),
                data: viewTestLoss.map(t => t.loss),
                color: '#ff9800',  // Orange for test (matches test points)
                lineWidth: 2,
                dashed: true  // Dashed line to distinguish from train
            });
        }
    }

    // Y axis range for loss (supports log scale) - ALWAYS based on ALL loss data for stable axis
    // Calculate from raw data, not just displayed series, so toggling curves doesn't change axis
    let yMin = 0;  // Loss always starts from 0 in linear mode
    let yMax = -Infinity;
    
    // Always include training loss in axis calculation
    viewLoss.forEach(v => {
        if (!Number.isFinite(v) || (useLogScale && v <= 0)) return;
        const val = useLogScale ? Math.log10(v) : v;
        yMax = Math.max(yMax, val);
    });
    
    // Always include average loss in axis calculation
    viewAvgLoss.forEach(v => {
        if (!Number.isFinite(v) || v === null || (useLogScale && v <= 0)) return;
        const val = useLogScale ? Math.log10(v) : v;
        yMax = Math.max(yMax, val);
    });
    
    // Include test loss if available
    if (history.testLoss.length > 0) {
        history.testLoss.forEach(t => {
            if (t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)) {
                if (!Number.isFinite(t.loss) || (useLogScale && t.loss <= 0)) return;
                const val = useLogScale ? Math.log10(t.loss) : t.loss;
                yMax = Math.max(yMax, val);
            }
        });
    }
    
    if (useLogScale) {
        // For log scale, find the minimum non-zero value
        yMin = Infinity;
        viewLoss.forEach(v => { if (v > 0) yMin = Math.min(yMin, Math.log10(v)); });
        viewAvgLoss.forEach(v => { if (v > 0 && v !== null) yMin = Math.min(yMin, Math.log10(v)); });
        history.testLoss.forEach(t => {
            if (t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)) {
                if (t.loss > 0) yMin = Math.min(yMin, Math.log10(t.loss));
            }
        });
        if (!Number.isFinite(yMin)) yMin = -4;
    }
    if (!Number.isFinite(yMax)) {
        yMax = useLogScale ? 0 : 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(0.1, Math.abs(yMin) * 0.1);
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;
    
    // Get sliced weights for the view
    const viewWeights = hasData ? history.weights.slice(viewStartIdx, viewEndIdx) : [];
    
    // Y axis range for weights (separate right axis)
    let wMin = Infinity;
    let wMax = -Infinity;
    if (showWeights && viewWeights.length > 0) {
        viewWeights.forEach(wArr => {
            wArr.forEach(v => {
                if (Number.isFinite(v)) {
                    wMin = Math.min(wMin, v);
                    wMax = Math.max(wMax, v);
                }
            });
        });
    }
    if (!Number.isFinite(wMin) || !Number.isFinite(wMax)) {
        wMin = -2;
        wMax = 2;
    }
    if (wMin === wMax) {
        wMin -= 1;
        wMax += 1;
    } else {
        const wPad = 0.1 * (wMax - wMin);
        wMin -= wPad;
        wMax += wPad;
    }
    const wRange = wMax - wMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) => {
        const v = useLogScale ? Math.log10(Math.max(val, 1e-10)) : val;
        return h - paddingBottom - ((v - yMin) / yRange) * plotHeight;
    };

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicks = getNiceTicks(stepMin, stepMax, 5);
    xTicks.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values (log scale uses powers of 10)
    ctx.textAlign = 'right';
    const yTicks = useLogScale ? getLogTicks(yMin, yMax) : getNiceTicks(yMin, yMax, 5);
    yTicks.forEach(yVal => {
        if (yVal < yMin || yVal > yMax) return;
        const y = h - paddingBottom - ((yVal - yMin) / yRange) * plotHeight;
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        if (useLogScale) {
            const realVal = Math.pow(10, yVal);
            // Format as power of 10: 10^-2 shows as "0.01", 10^-3 as "0.001" etc.
            if (Number.isInteger(yVal)) {
                ctx.fillText(realVal.toExponential(0), paddingLeft - 4, y + 3);
            } else {
                ctx.fillText(realVal.toPrecision(2), paddingLeft - 4, y + 3);
            }
        } else {
            ctx.fillText(yVal.toPrecision(3), paddingLeft - 4, y + 3);
        }
    });

    // Axis labels
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(useLogScale ? 'Error (log‚ÇÅ‚ÇÄ)' : 'Error (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Draw loss series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        if (s.dashed) {
            ctx.setLineDash([5, 3]);
        } else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < s.data.length; i++) {
            const val = s.data[i];
            if (!Number.isFinite(val) || (useLogScale && val <= 0)) continue;
            const x = toX(s.steps[i]);
            const y = toY(val);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    });

    // Draw weight traces (on right Y axis)
    if (showWeights && viewWeights && viewWeights.length > 0) {
        const numWeights = viewWeights[0].length;
        const weightColors = ['#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#ff7f0e', '#2ca02c'];
        
        // Use pre-calculated weight range from earlier
        const toWY = (val) => h - paddingBottom - ((val - wMin) / wRange) * plotHeight;
        
        // Draw right axis tick marks and labels for weights - use nice values
        ctx.textAlign = 'left';
        ctx.font = '9px sans-serif';
        const wTicks = getNiceTicks(wMin, wMax, 5);
        wTicks.forEach(wVal => {
            if (wVal < wMin || wVal > wMax) return;
            const y = h - paddingBottom - ((wVal - wMin) / wRange) * plotHeight;
            // Tick mark
            ctx.strokeStyle = '#9467bd';
            ctx.beginPath();
            ctx.moveTo(w - paddingRight, y);
            ctx.lineTo(w - paddingRight + 5, y);
            ctx.stroke();
            // Label
            ctx.fillStyle = '#9467bd';
            ctx.fillText(wVal.toFixed(1), w - paddingRight + 8, y + 3);
        });
        
        // Draw weight lines
        for (let wi = 0; wi < Math.min(numWeights, 8); wi++) {
            ctx.strokeStyle = weightColors[wi % weightColors.length];
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < viewWeights.length; i++) {
                const x = toX(viewSteps[i]);
                const y = toWY(viewWeights[i][wi]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        
        // Right axis label
        ctx.save();
        ctx.translate(w - 5, h / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#9467bd';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Weights', 0, 0);
        ctx.restore();
    }
    
    // Draw legend above the plot area (in the top margin)
    const legendY = 20;  // Above the plot, in the margin
    let legendX = paddingLeft;
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    
    // Train Loss (green solid line)
    ctx.strokeStyle = '#28a745';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 14, legendY);
    ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.fillText('Train', legendX + 17, legendY + 4);
    legendX += 52;
    
    // Average Loss (blue solid line)
    ctx.strokeStyle = '#007bff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 14, legendY);
    ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.fillText('Avg', legendX + 17, legendY + 4);
    legendX += 42;
    
    // Test Loss (orange dashed line) - only if evaluated
    if (revealOptions.evaluated && history.testLoss.length > 0) {
        ctx.strokeStyle = '#ff9800';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 14, legendY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#333';
        ctx.fillText('Test', legendX + 17, legendY + 4);
        legendX += 42;
    }
    
    // Weights (purple line) - only if showing weights
    if (showWeights) {
        ctx.strokeStyle = '#9467bd';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 14, legendY);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#333';
        ctx.fillText('Weights (first 8)', legendX + 17, legendY + 4);
    }
}

    // Loss surface visualization
    let lossSurfaceCache = null;
    let lossSurfaceWeightIndices = [0, 1];
    let lossSurfaceTrail = [];  // Trail of weight positions during training
    let lossSurfaceStartPosition = null;  // Store starting position separately
    let lossSurfaceAutoUpdate = true;  // Auto-update drawing every N steps
    let lossSurfaceUpdateInterval = 50;  // Update drawing every 50 steps
    let lossLandscapeAutoMode = true;  // Auto-select weights by default
    
    // Smooth zoom state
    let lossSurfaceViewBounds = null;  // Current view bounds {minX, maxX, minY, maxY}
    let lossSurfaceOriginalBounds = null;  // Original wide bounds (for zoom out)
    let zoomBlendRate = 0.03;  // How fast to zoom (3% per frame)
    
    // Periodic re-probing state
    let lastReprobeEpoch = 0;
    let reprobeInterval = 10;  // Re-probe every N epochs
    
    // Re-probe grid points that are already BLUE (low loss)
    // Only update blues to deeper blues - don't shift greens/reds (confusing)
    function reprobeLossSurface() {
        if (!lossSurfaceCache) return;
        
        const { grid, minX, maxX, minY, maxY, resolution, maxLoss } = lossSurfaceCache;
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Threshold: only update cells that are already in the "blue" range
        // Blue is roughly the lower 30% of the log scale
        const blueThreshold = Math.pow(maxLoss, 0.3) * Math.pow(lossSurfaceCache.minLoss, 0.7);
        
        // Save current trained weights
        const savedWX = getWeightByIndex(idxX);
        const savedWY = getWeightByIndex(idxY);
        
        // Sample function for loss computation
        const samples = [];
        for (let i = 0; i < 20; i++) {
            const x = config.xMin + (i + 0.5) * (config.xMax - config.xMin) / 20;
            let y;
            try { y = config.targetFunc(x); } catch { y = 0; }
            samples.push({ x, y });
        }
        
        let updatedCount = 0;
        let newMin = lossSurfaceCache.minLoss;
        
        // Only check cells that are currently blue
        for (let iy = 0; iy < resolution; iy++) {
            const wy = minY + (iy / (resolution - 1)) * (maxY - minY);
            for (let ix = 0; ix < resolution; ix++) {
                // Skip cells that aren't already blue
                if (grid[iy][ix] > blueThreshold) continue;
                
                const wx = minX + (ix / (resolution - 1)) * (maxX - minX);
                
                // Set w1, w2 to grid point
                setWeightByIndex(idxX, wx);
                setWeightByIndex(idxY, wy);
                
                // Compute loss with current trained N-2 weights
                let loss = 0;
                for (const sample of samples) {
                    const fwd = forward(sample.x);
                    const error = fwd.yhat - sample.y;
                    loss += 0.5 * error * error;
                }
                loss /= samples.length;
                
                // Update if lower AND still blue (deeper blue, not jumping to green/red)
                if (loss < grid[iy][ix] && loss <= blueThreshold) {
                    grid[iy][ix] = loss;
                    updatedCount++;
                }
                if (loss < newMin) newMin = loss;
            }
        }
        
        // Restore w1, w2
        setWeightByIndex(idxX, savedWX);
        setWeightByIndex(idxY, savedWY);
        
        if (newMin < lossSurfaceCache.minLoss) {
            console.log(`Reprobe: min loss ${lossSurfaceCache.minLoss.toExponential(2)} ‚Üí ${newMin.toExponential(2)}`);
            lossSurfaceCache.minLoss = newMin;
        }
        if (updatedCount > 0) {
            console.log(`Reprobe: ${updatedCount} blue cells deepened`);
        }
    }
    
    // Update zoom to follow trace
    function updateLossSurfaceZoom() {
        if (!lossSurfaceCache || !lossSurfaceViewBounds || !lossSurfaceOriginalBounds) return;
        if (lossSurfaceTrail.length < 2) return;
        
        // Compute trace bounding box
        const trailXs = lossSurfaceTrail.map(p => p.x);
        const trailYs = lossSurfaceTrail.map(p => p.y);
        const trailMinX = Math.min(...trailXs);
        const trailMaxX = Math.max(...trailXs);
        const trailMinY = Math.min(...trailYs);
        const trailMaxY = Math.max(...trailYs);
        
        // Add margin (20% of trail size, minimum 1 unit)
        const trailW = trailMaxX - trailMinX;
        const trailH = trailMaxY - trailMinY;
        const marginX = Math.max(trailW * 0.2, 1);
        const marginY = Math.max(trailH * 0.2, 1);
        
        // Target bounds = trace bbox + margin
        let targetMinX = trailMinX - marginX;
        let targetMaxX = trailMaxX + marginX;
        let targetMinY = trailMinY - marginY;
        let targetMaxY = trailMaxY + marginY;
        
        // Ensure target doesn't exceed original bounds (can't zoom beyond computed surface)
        targetMinX = Math.max(targetMinX, lossSurfaceOriginalBounds.minX);
        targetMaxX = Math.min(targetMaxX, lossSurfaceOriginalBounds.maxX);
        targetMinY = Math.max(targetMinY, lossSurfaceOriginalBounds.minY);
        targetMaxY = Math.min(targetMaxY, lossSurfaceOriginalBounds.maxY);
        
        // Ensure minimum view size (don't zoom in too far)
        const minViewSize = 2;
        if (targetMaxX - targetMinX < minViewSize) {
            const centerX = (targetMinX + targetMaxX) / 2;
            targetMinX = centerX - minViewSize / 2;
            targetMaxX = centerX + minViewSize / 2;
        }
        if (targetMaxY - targetMinY < minViewSize) {
            const centerY = (targetMinY + targetMaxY) / 2;
            targetMinY = centerY - minViewSize / 2;
            targetMaxY = centerY + minViewSize / 2;
        }
        
        // Check if current position is outside view - if so, need to zoom out
        const currentX = getWeightByIndex(lossSurfaceWeightIndices[0]);
        const currentY = getWeightByIndex(lossSurfaceWeightIndices[1]);
        const viewMargin = 0.1;  // 10% margin before triggering zoom out
        const viewW = lossSurfaceViewBounds.maxX - lossSurfaceViewBounds.minX;
        const viewH = lossSurfaceViewBounds.maxY - lossSurfaceViewBounds.minY;
        
        if (currentX < lossSurfaceViewBounds.minX + viewW * viewMargin ||
            currentX > lossSurfaceViewBounds.maxX - viewW * viewMargin ||
            currentY < lossSurfaceViewBounds.minY + viewH * viewMargin ||
            currentY > lossSurfaceViewBounds.maxY - viewH * viewMargin) {
            // Current position near edge - expand target to include it with more margin
            targetMinX = Math.min(targetMinX, currentX - 2);
            targetMaxX = Math.max(targetMaxX, currentX + 2);
            targetMinY = Math.min(targetMinY, currentY - 2);
            targetMaxY = Math.max(targetMaxY, currentY + 2);
            
            // Clamp to original bounds
            targetMinX = Math.max(targetMinX, lossSurfaceOriginalBounds.minX);
            targetMaxX = Math.min(targetMaxX, lossSurfaceOriginalBounds.maxX);
            targetMinY = Math.max(targetMinY, lossSurfaceOriginalBounds.minY);
            targetMaxY = Math.min(targetMaxY, lossSurfaceOriginalBounds.maxY);
        }
        
        // Smoothly blend current view toward target
        lossSurfaceViewBounds.minX += (targetMinX - lossSurfaceViewBounds.minX) * zoomBlendRate;
        lossSurfaceViewBounds.maxX += (targetMaxX - lossSurfaceViewBounds.maxX) * zoomBlendRate;
        lossSurfaceViewBounds.minY += (targetMinY - lossSurfaceViewBounds.minY) * zoomBlendRate;
        lossSurfaceViewBounds.maxY += (targetMaxY - lossSurfaceViewBounds.maxY) * zoomBlendRate;
    }
    // With percentile-based surface computation, calibration is no longer needed
    // The surface shows "achievable" loss at each point, which is stable across training
    
    function populateWeightSelectors() {
        const selectX = document.getElementById('weightXSelect');
        const selectY = document.getElementById('weightYSelect');
        if (!selectX || !selectY) return;
        
        // Helper to convert number to subscript
        const toSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
        
        // Build list of all weights with descriptive names and categories
        const weightNames = [];
        let idx = 0;
        
        // First layer: input -> hidden (category: 'input')
        // w_ij notation: weight to hidden neuron h_1j (layer 1, neuron j)
        for (let i = 0; i < network.hiddenSize; i++) {
            const neuronIdx = i + 1;
            // For single layer: w_j(x‚Üíh_j), for multi-layer: w(x‚Üíh_1j)
            const hLabel = network.numLayers === 1 ? `h${toSub(neuronIdx)}` : `h${toSub(1)}${toSub(neuronIdx)}`;
            weightNames.push({ idx: idx++, name: `w(x‚Üí${hLabel})`, category: 'input', neuron: i });
        }
        
        // Hidden -> hidden layers (category: 'hidden')
        // w(h_ij‚Üíh_kl) notation
        for (let l = 1; l < network.numLayers; l++) {
            for (let i = 0; i < network.hiddenSize; i++) {
                for (let j = 0; j < network.hiddenSize; j++) {
                    weightNames.push({ idx: idx++, name: `w(h${toSub(l)}${toSub(j+1)}‚Üíh${toSub(l+1)}${toSub(i+1)})`, category: 'hidden', layer: l });
                }
            }
        }
        
        // Output layer (category: 'output') - w_j for output weights (single subscript for last layer)
        for (let i = 0; i < network.hiddenSize; i++) {
            const neuronIdx = i + 1;
            // Reference last hidden layer with h_ij notation
            const lastLayer = network.numLayers;
            const hLabel = network.numLayers === 1 ? `h${toSub(neuronIdx)}` : `h${toSub(lastLayer)}${toSub(neuronIdx)}`;
            weightNames.push({ idx: idx++, name: `w${toSub(neuronIdx)}(${hLabel}‚Üíy)`, category: 'output', neuron: i });
        }
        
        // Populate selectors
        selectX.innerHTML = '';
        selectY.innerHTML = '';
        
        weightNames.forEach(w => {
            const optX = document.createElement('option');
            optX.value = w.idx;
            optX.textContent = w.name;
            selectX.appendChild(optX);
            
            const optY = document.createElement('option');
            optY.value = w.idx;
            optY.textContent = w.name;
            selectY.appendChild(optY);
        });
        
        // Auto-select interesting weights:
        // Pick one from input layer and one from output layer for maximum independence
        const inputWeights = weightNames.filter(w => w.category === 'input');
        const outputWeights = weightNames.filter(w => w.category === 'output');
        
        let bestPair = [0, 1];
        
        if (inputWeights.length > 0 && outputWeights.length > 0) {
            // Pick first input weight and first output weight (different layers = more interesting)
            bestPair = [inputWeights[0].idx, outputWeights[0].idx];
        } else if (weightNames.length >= 2) {
            // Fallback: pick weights from different neurons
            bestPair = [0, Math.min(1, weightNames.length - 1)];
        }
        
        selectX.value = bestPair[0].toString();
        selectY.value = bestPair[1].toString();
        lossSurfaceWeightIndices = bestPair;
    }
    
    // Find the most "interesting" pair of weights by sampling loss variance
    function autoSelectInterestingWeights() {
        try {
            const selectX = document.getElementById('weightXSelect');
            const selectY = document.getElementById('weightYSelect');
            if (!selectX || !selectY) {
                console.log('Weight selectors not found');
                return;
            }
            
            const numWeights = selectX.options.length;
            if (numWeights < 2) {
                console.log('Not enough weights:', numWeights);
                // Just use first two weights as default
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
                return;
            }
            
            // Simple approach: just pick first input weight and first output weight
            // This is more robust for different network sizes
            const H = network.hiddenSize;
            const L = network.numLayers;
            
            // First weight (input to first hidden)
            const idx1 = 0;
            // Last weight (last hidden to output) - approximate
            const idx2 = Math.min(numWeights - 1, H);
            
            if (idx1 !== idx2 && idx2 < numWeights) {
                lossSurfaceWeightIndices = [idx1, idx2];
            } else {
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
            }
            
            selectX.value = lossSurfaceWeightIndices[0].toString();
            selectY.value = lossSurfaceWeightIndices[1].toString();
            lossSurfaceCache = null;
            lossSurfaceTrail = [];
            console.log('Auto-selected weights:', lossSurfaceWeightIndices);
        } catch(e) {
            console.error('autoSelectInterestingWeights error:', e);
            // Fallback to default
            lossSurfaceWeightIndices = [0, 1];
        }
    }
    
    function getWeightByIndex(idx) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            return network.weights[0][idx];
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                return network.weights[l][i][j];
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            return network.weights[network.weights.length - 1][outIdx];
        }
        
        return 0;
    }
    
    function setWeightByIndex(idx, value) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            network.weights[0][idx] = value;
            return;
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                network.weights[l][i][j] = value;
                return;
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            network.weights[network.weights.length - 1][outIdx] = value;
        }
    }
    
    // Abort flag for cancelling in-progress loss surface computation
    let abortLossSurfaceComputation = false;
    
    // Debounced loss surface computation - delays expensive calculation
    let lossSurfaceComputeTimer = null;
    function scheduleLossSurfaceComputation(delay = 1000) {
        // Signal any in-progress computation to abort
        abortLossSurfaceComputation = true;
        if (lossSurfaceComputeTimer) {
            clearTimeout(lossSurfaceComputeTimer);
        }
        const scheduleStart = performance.now();
        console.log(`Scheduling loss surface computation (${delay}ms delay)...`);
        lossSurfaceComputeTimer = setTimeout(() => {
            lossSurfaceComputeTimer = null;
            console.log(`Computing loss surface (after ${(performance.now() - scheduleStart).toFixed(0)}ms wait)...`);
            const t0 = performance.now();
            computeLossSurface();
            console.log(`  computeLossSurface: ${(performance.now() - t0).toFixed(0)}ms`);
            const t1 = performance.now();
            drawLossSurface();
            console.log(`  drawLossSurface: ${(performance.now() - t1).toFixed(0)}ms`);
            const t2 = performance.now();
            updateLossScaleLegend();
            console.log(`  updateLossScaleLegend: ${(performance.now() - t2).toFixed(0)}ms`);
            console.log(`  Total scheduled work: ${(performance.now() - t0).toFixed(0)}ms`);
        }, delay);
    }
    
    function computeLossSurface() {
        // Skip if no training data has been generated yet
        if (!dataset.generated || dataset.train.length === 0) {
            console.log('computeLossSurface: skipped (no training data yet)');
            lossSurfaceCache = null;  // Clear any stale cache
            return;
        }
        
        // One-time computation at training start
        const resolution = 45;  // ~2000 points (45x45), with non-uniform spacing
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Save current weights
        const savedWX = getWeightByIndex(idxX);
        const savedWY = getWeightByIndex(idxY);
        
        // Grid bounds will be set after mini-training finds the low-loss region
        // Placeholder values - will be updated
        let minX, maxX, minY, maxY;
        
        // Always use evenly-spaced samples from the clean target function
        // This ensures the loss landscape is stable and shows the "true" loss surface
        // (using training data with noise would cause visual jumps)
        const samples = [];
        const numSamples = 30;  // More samples for accurate loss estimation
        for (let i = 0; i < numSamples; i++) {
            const x = config.xMin + (i + 0.5) * (config.xMax - config.xMin) / numSamples;
            let y;
            try { y = config.targetFunc(x); } catch { y = 0; }
            samples.push({ x, y });
        }
        
        // Save all weights for restoration
        const savedWeights = JSON.parse(JSON.stringify(network.weights));
        const savedBiases = JSON.parse(JSON.stringify(network.biases));
        
        // Get total weights count
        let totalWeights = 0;
        for (let l = 0; l < network.weights.length; l++) {
            const layer = network.weights[l];
            if (Array.isArray(layer[0])) {
                totalWeights += layer.length * layer[0].length;
            } else {
                totalWeights += layer.length;
            }
        }
        
        // Multi-region training: 25 anchors √ó 1000 steps = 25k steps total
        // This is fast regardless of model size, so no limit needed
        const useGreedy = true;  // Always use multi-region training for meaningful loss maps
        
        console.log(`Computing loss surface: ${resolution}x${resolution} grid ${useGreedy ? 'with greedy optimization' : '(simple slice - network too large for greedy)'}`);
        const computeStart = performance.now();
        
        // Clear abort flag at start of computation
        abortLossSurfaceComputation = false;
        
        const grid = [];
        let minLoss = Infinity, maxLoss = -Infinity;
        let minLossX = 0, minLossY = 0;
        
        // Mini-training approach: run a few epochs of actual training to warm up N-2 weights
        // This is MUCH faster than greedy search AND gives more realistic loss surfaces
        let warmedUpWeights = null;
        let warmedUpBiases = null;
        
        // Will hold the trained position (where w1,w2 converge to = blue region)
        let trainedW1 = 0, trainedW2 = 0;
        let trainedLoss = Infinity;  // The actual achievable minimum loss
        
        // Multi-region mini-training: train at multiple (w1,w2) anchor points
        // to build a globally meaningful loss map
        const anchorLosses = [];  // Will store {w1, w2, loss} for each anchor
        
        // Set up grid bounds first (¬±6 range, fixed)
        minX = -6; maxX = 6;
        minY = -6; maxY = 6;
        
        // Pre-compute coordinate arrays (non-uniform, concentrated at center)
        const coordsX = [];
        const coordsY = [];
        for (let i = 0; i < resolution; i++) {
            const u = (i / (resolution - 1)) * 2 - 1;  // [-1, 1]
            const coord = Math.sign(u) * Math.pow(Math.abs(u), 2) * 6;  // ¬±6, concentrated at center
            coordsX.push(coord);
            coordsY.push(coord);
        }
        
        if (useGreedy) {
            console.log('  Regional training: optimizing N-2 at each grid point...');
            const miniTrainStart = performance.now();
            
            const miniTrainData = (dataset.generated && dataset.train.length > 0) ? dataset.train : samples;
            const miniLR = Math.min(0.1, 0.5 / Math.sqrt(totalWeights));
            
            // Steps per point - balance between quality and speed
            const stepsPerPoint = Math.max(50, Math.floor(20000 / (resolution * resolution)));
            console.log(`  Grid: ${resolution}x${resolution}, ${stepsPerPoint} steps/point`);
            
            // Create DETERMINISTIC initial weights for regional training
            // This ensures the loss map is the same regardless of when it's computed
            function initWeightsForGrid() {
                // Use small deterministic values (like Xavier with fixed seed)
                const H = network.hiddenSize;
                const scale = 1 / Math.sqrt(H);
                for (let l = 0; l < network.weights.length; l++) {
                    const w = network.weights[l];
                    if (Array.isArray(w[0])) {
                        for (let i = 0; i < w.length; i++) {
                            for (let j = 0; j < w[i].length; j++) {
                                // Deterministic pattern based on position
                                w[i][j] = scale * Math.sin((l * 1000 + i * 100 + j) * 0.1);
                            }
                        }
                    } else {
                        for (let i = 0; i < w.length; i++) {
                            w[i] = scale * Math.sin((l * 1000 + i) * 0.1);
                        }
                    }
                }
                for (let l = 0; l < network.biases.length; l++) {
                    for (let i = 0; i < network.biases[l].length; i++) {
                        network.biases[l][i] = 0;  // Start biases at zero
                    }
                }
            }
            
            // Build grid with regional training
            for (let iy = 0; iy < resolution; iy++) {
                const row = [];
                const wy = coordsY[iy];
                
                for (let ix = 0; ix < resolution; ix++) {
                    const wx = coordsX[ix];
                    
                    // Reset to DETERMINISTIC weights for each point
                    initWeightsForGrid();
                    
                    // Fix w1,w2 at this grid point
                    setWeightByIndex(idxX, wx);
                    setWeightByIndex(idxY, wy);
                    
                    // Mini-train N-2 weights for this point
                    for (let step = 0; step < stepsPerPoint; step++) {
                        const sample = miniTrainData[step % miniTrainData.length];
                        const fwd = forward(sample.x);
                        if (!Number.isFinite(fwd.yhat)) break;
                        
                        backward(sample.x, sample.y, fwd);
                        
                        // Update only N-2 weights
                        let wIdx = 0;
                        for (let l = 0; l < network.weights.length; l++) {
                            const w = network.weights[l];
                            const gw = grads.weights[l];
                            if (Array.isArray(w[0])) {
                                for (let i = 0; i < w.length; i++) {
                                    for (let j = 0; j < w[i].length; j++) {
                                        if (wIdx !== idxX && wIdx !== idxY) {
                                            const g = gw[i][j];
                                            if (Number.isFinite(g)) {
                                                w[i][j] -= miniLR * Math.max(-5, Math.min(5, g));
                                            }
                                        }
                                        wIdx++;
                                    }
                                }
                            } else {
                                for (let i = 0; i < w.length; i++) {
                                    if (wIdx !== idxX && wIdx !== idxY) {
                                        const g = gw[i];
                                        if (Number.isFinite(g)) {
                                            w[i] -= miniLR * Math.max(-5, Math.min(5, g));
                                        }
                                    }
                                    wIdx++;
                                }
                            }
                        }
                        for (let l = 0; l < network.biases.length; l++) {
                            const b = network.biases[l];
                            const gb = grads.biases[l];
                            for (let i = 0; i < b.length; i++) {
                                const g = gb[i];
                                if (Number.isFinite(g)) {
                                    b[i] -= miniLR * Math.max(-5, Math.min(5, g));
                                }
                            }
                        }
                    }
                    
                    // Compute achievable loss at this point
                    let loss = 0;
                    for (const sample of samples) {
                        const fwd = forward(sample.x);
                        const err = fwd.yhat - sample.y;
                        loss += 0.5 * err * err;
                    }
                    loss /= samples.length;
                    
                    row.push(loss);
                    if (loss < minLoss) { minLoss = loss; minLossX = wx; minLossY = wy; }
                    if (loss > maxLoss) maxLoss = loss;
                }
                grid.push(row);
            }
            
            trainedLoss = minLoss;
            trainedW1 = minLossX;
            trainedW2 = minLossY;
            
            console.log(`  Regional training done in ${((performance.now() - miniTrainStart)/1000).toFixed(2)}s`);
            console.log(`  Best achievable: ${minLoss.toExponential(2)} at (${minLossX.toFixed(1)}, ${minLossY.toFixed(1)})`);
            console.log(`  Worst: ${maxLoss.toExponential(2)}, ratio: ${(maxLoss/minLoss).toFixed(1)}x`);
        }
        
        // Grid was built in regional training block above
        const computeEnd = performance.now();
        console.log(`Loss surface computed in ${((computeEnd - computeStart)/1000).toFixed(2)}s`);
        console.log(`  Grid min loss: ${minLoss.toExponential(2)} at (${minLossX.toFixed(2)}, ${minLossY.toFixed(2)})`);
        console.log(`  Grid max loss: ${maxLoss.toExponential(2)}`);
        console.log(`  Loss ratio: ${(maxLoss/minLoss).toFixed(1)}x`);
        
        // For non-greedy mode, use grid min as the "trained" loss
        if (!useGreedy || !Number.isFinite(trainedLoss)) {
            trainedLoss = minLoss;
            trainedW1 = minLossX;
            trainedW2 = minLossY;
        }
        
        // Restore original random weights for actual training
        network.weights = savedWeights;
        network.biases = savedBiases;
        
        // Use trained loss as the true minimum (blue) - grid may not capture it exactly
        const trueMinLoss = trainedLoss < minLoss ? trainedLoss : minLoss;
        
        lossSurfaceCache = {
            grid, minLoss, maxLoss, minX, maxX, minY, maxY, resolution,
            coordsX, coordsY,  // Non-uniform coordinate arrays
            currentX: savedWX, currentY: savedWY,
            usedGreedy: useGreedy,
            trainedLoss: useGreedy ? trainedLoss : null,  // The actual achievable minimum
            trainedX: useGreedy ? trainedW1 : null,
            trainedY: useGreedy ? trainedW2 : null
        };
        
        // Store original bounds for zoom reference
        lossSurfaceOriginalBounds = { minX, maxX, minY, maxY };
        // Preserve existing view bounds if they exist (for recomputation during training)
        // Only initialize to original bounds on first computation
        if (!lossSurfaceViewBounds) {
            lossSurfaceViewBounds = { minX, maxX, minY, maxY };
        }
        
        // Set color scale: use ACTUAL grid min (blue) and max (red)
        // This ensures we see the full color range in the initial view
        if (!lossColorScale.calibrated) {
            lossColorScale.minLoss = minLoss;  // Actual grid minimum = blue
            lossColorScale.maxLoss = maxLoss;  // Actual grid maximum = red
            lossColorScale.noiseFloor = config.noise * config.noise;
            lossColorScale.calibrated = true;
            console.log(`Color scale: blue=${minLoss.toExponential(2)}, red=${maxLoss.toExponential(2)}`);
            console.log(`  Dynamic range: ${(maxLoss/minLoss).toFixed(1)}x`);
        } else {
            // Already calibrated - only extend blue end if we found lower loss
            if (minLoss < lossColorScale.minLoss) {
                console.log(`Extending blue end: ${lossColorScale.minLoss.toExponential(2)} ‚Üí ${minLoss.toExponential(2)}`);
                lossColorScale.minLoss = minLoss;
            }
            // Don't extend red end - that would make existing colors shift
        }
    }
    
    
    function drawLossSurface() {
        const canvas = document.getElementById('lossCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 60;
        const paddingRight = 60;
        const paddingTop = 40;
        const paddingBottom = 40;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const plotW = w - paddingLeft - paddingRight;
        const plotH = h - paddingTop - paddingBottom;
        
        if (!lossSurfaceCache) {
            // Draw placeholder axes and message
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, h - paddingBottom);
            ctx.lineTo(w - paddingRight, h - paddingBottom);
            ctx.stroke();
            
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Computing...', w/2, h/2);
            return;
        }
        
        const { grid, minLoss, maxLoss, resolution, coordsX, coordsY } = lossSurfaceCache;
        // Use view bounds for rendering (enables zoom), fall back to cache bounds
        const viewMinX = lossSurfaceViewBounds ? lossSurfaceViewBounds.minX : lossSurfaceCache.minX;
        const viewMaxX = lossSurfaceViewBounds ? lossSurfaceViewBounds.maxX : lossSurfaceCache.maxX;
        const viewMinY = lossSurfaceViewBounds ? lossSurfaceViewBounds.minY : lossSurfaceCache.minY;
        const viewMaxY = lossSurfaceViewBounds ? lossSurfaceViewBounds.maxY : lossSurfaceCache.maxY;
        // Grid's original coordinate bounds (for mapping grid indices to weight values)
        const gridMinX = lossSurfaceCache.minX;
        const gridMaxX = lossSurfaceCache.maxX;
        const gridMinY = lossSurfaceCache.minY;
        const gridMaxY = lossSurfaceCache.maxY;
        
        // Check if we have non-uniform coordinates
        const hasNonUniform = coordsX && coordsY;
        
        // Logarithmic color scale - maps ACTUAL grid min (blue) to max (red)
        // This ensures we always see the full color range regardless of absolute loss values
        const gridMin = lossSurfaceCache.minLoss;
        const gridMax = lossSurfaceCache.maxLoss;
        // Use actual grid range for color mapping
        const colorMin = Math.max(1e-10, gridMin * 0.9);  // Slightly below grid min for headroom
        const colorMax = gridMax * 1.1;  // Slightly above grid max
        const colorMinLog = Math.log10(colorMin);
        const colorMaxLog = Math.log10(Math.max(colorMin * 2, colorMax));
        const colorLogRange = Math.max(0.1, colorMaxLog - colorMinLog);
        
        // Set up clipping region to keep drawing within plot area
        ctx.save();
        ctx.beginPath();
        ctx.rect(paddingLeft, paddingTop, plotW, plotH);
        ctx.clip();
        
        // Draw each grid cell, supporting non-uniform grid coordinates
        for (let iy = 0; iy < resolution; iy++) {
            for (let ix = 0; ix < resolution; ix++) {
                // Get cell center and bounds - use non-uniform coords if available
                let cellWx, cellWy, cellLeft, cellRight, cellBottom, cellTop;
                
                if (hasNonUniform) {
                    cellWx = coordsX[ix];
                    cellWy = coordsY[iy];
                    // Cell bounds from adjacent coordinates (or extrapolate at edges)
                    cellLeft = ix > 0 ? (coordsX[ix-1] + coordsX[ix]) / 2 : coordsX[ix] - (coordsX[ix+1] - coordsX[ix]) / 2;
                    cellRight = ix < resolution-1 ? (coordsX[ix] + coordsX[ix+1]) / 2 : coordsX[ix] + (coordsX[ix] - coordsX[ix-1]) / 2;
                    cellBottom = iy > 0 ? (coordsY[iy-1] + coordsY[iy]) / 2 : coordsY[iy] - (coordsY[iy+1] - coordsY[iy]) / 2;
                    cellTop = iy < resolution-1 ? (coordsY[iy] + coordsY[iy+1]) / 2 : coordsY[iy] + (coordsY[iy] - coordsY[iy-1]) / 2;
                } else {
                    // Uniform grid fallback
                    const cellSize = (gridMaxX - gridMinX) / resolution;
                    cellWx = gridMinX + (ix + 0.5) * (gridMaxX - gridMinX) / resolution;
                    cellWy = gridMinY + (iy + 0.5) * (gridMaxY - gridMinY) / resolution;
                    cellLeft = cellWx - cellSize/2;
                    cellRight = cellWx + cellSize/2;
                    cellBottom = cellWy - cellSize/2;
                    cellTop = cellWy + cellSize/2;
                }
                
                // Skip if cell is completely outside current view
                if (cellRight < viewMinX || cellLeft > viewMaxX ||
                    cellTop < viewMinY || cellBottom > viewMaxY) {
                    continue;
                }
                
                const loss = grid[iy][ix];
                
                // Log scale normalization using actual grid range
                const logLoss = Math.log10(Math.max(1e-10, loss));
                const normLoss = (logLoss - colorMinLog) / colorLogRange;
                // Clamp to [0, 1] but allow slight overflow for smoother edges
                const clampedNorm = Math.max(0, Math.min(1, normLoss));
                
                // Smooth HSL-based gradient
                // Hue: 240 (blue) ‚Üí 0 (red) with full continuous range
                const hue = 240 * (1 - clampedNorm);
                const sat = 80 + 20 * Math.sin(clampedNorm * Math.PI);  // Boost in middle
                const light = 30 + 30 * (1 - Math.pow(Math.abs(clampedNorm - 0.5) * 2, 0.7));  // Smoother falloff
                
                ctx.fillStyle = `hsl(${hue.toFixed(2)}, ${sat.toFixed(1)}%, ${light.toFixed(1)}%)`;
                // Position based on VIEW bounds, not grid bounds
                const px = paddingLeft + ((cellLeft - viewMinX) / (viewMaxX - viewMinX)) * plotW;
                const py = paddingTop + (1 - (cellTop - viewMinY) / (viewMaxY - viewMinY)) * plotH;
                const drawW = ((cellRight - cellLeft) / (viewMaxX - viewMinX)) * plotW + 1;
                const drawH = ((cellTop - cellBottom) / (viewMaxY - viewMinY)) * plotH + 1;
                ctx.fillRect(px, py, drawW, drawH);
            }
        }
        
        // Restore context (removes clipping)
        ctx.restore();
        
        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotW, plotH);
        
        // Helper to convert weight values to canvas coordinates (using VIEW bounds for zoom)
        const toCanvasX = (wx) => paddingLeft + ((wx - viewMinX) / (viewMaxX - viewMinX)) * plotW;
        const toCanvasY = (wy) => paddingTop + (1 - (wy - viewMinY) / (viewMaxY - viewMinY)) * plotH;
        
        // Check for comparison mode - only valid if network architecture, activation, and target are the same
        // (comparing optimizer or learning rate differences makes sense, but different architectures don't share a loss landscape)
        function canCompareLossLandscapes() {
            if (!comparisonModeActive || !savedRuns.A || !savedRuns.B) return false;
            const cfgA = savedRuns.A.config;
            const cfgB = savedRuns.B.config;
            
            // Must have same architecture
            if (cfgA.numLayers !== cfgB.numLayers) return false;
            if (cfgA.hiddenSize !== cfgB.hiddenSize) return false;
            
            // Must have same activation (changes landscape shape)
            if (cfgA.activation !== cfgB.activation) return false;
            
            // Must have same target function
            if (cfgA.targetFuncStr !== cfgB.targetFuncStr) return false;
            
            // Must have saved trails with same weight indices
            if (!savedRuns.A.lossSurfaceTrail || !savedRuns.B.lossSurfaceTrail) return false;
            if (!savedRuns.A.lossSurfaceWeightIndices || !savedRuns.B.lossSurfaceWeightIndices) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[0] !== savedRuns.B.lossSurfaceWeightIndices[0]) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[1] !== savedRuns.B.lossSurfaceWeightIndices[1]) return false;
            
            return true;
        }
        
        const inComparisonMode = canCompareLossLandscapes();
        
        // Helper to draw a trail
        function drawTrail(trail, color, alpha = 0.85) {
            if (!trail || trail.length < 2) return;
            ctx.strokeStyle = color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trail[0].x), toCanvasY(trail[0].y));
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(toCanvasX(trail[i].x), toCanvasY(trail[i].y));
            }
            ctx.stroke();
        }
        
        if (inComparisonMode) {
            // Draw Run A trail (red/orange)
            if (savedRuns.A.lossSurfaceTrail) {
                drawTrail(savedRuns.A.lossSurfaceTrail, 'rgb(220, 53, 69)', 0.9);
                // Start marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const startA = savedRuns.A.lossSurfaceTrail[0];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startA.x), toCanvasY(startA.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const endA = savedRuns.A.lossSurfaceTrail[savedRuns.A.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endA.x), toCanvasY(endA.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw Run B trail (cyan/teal)
            if (savedRuns.B.lossSurfaceTrail) {
                drawTrail(savedRuns.B.lossSurfaceTrail, 'rgb(0, 188, 212)', 0.9);
                // Start marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const startB = savedRuns.B.lossSurfaceTrail[0];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startB.x), toCanvasY(startB.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const endB = savedRuns.B.lossSurfaceTrail[savedRuns.B.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endB.x), toCanvasY(endB.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        } else {
            // Normal mode - single trail
            if (lossSurfaceTrail.length > 1) {
                // Draw white trail with slight transparency
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                const first = lossSurfaceTrail[0];
                ctx.moveTo(toCanvasX(first.x), toCanvasY(first.y));
                for (let i = 1; i < lossSurfaceTrail.length; i++) {
                    const pt = lossSurfaceTrail[i];
                    ctx.lineTo(toCanvasX(pt.x), toCanvasY(pt.y));
                }
                ctx.stroke();
            }
            
            // Always draw start point if we have a starting position
            if (lossSurfaceStartPosition) {
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(toCanvasX(lossSurfaceStartPosition.x), toCanvasY(lossSurfaceStartPosition.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            // Draw current position
            const currentWX = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const currentWY = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const posX = toCanvasX(currentWX);
            const posY = toCanvasY(currentWY);
            
            // Draw current marker
            ctx.fillStyle = '#dc3545';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(posX, posY, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
        
        // Axis labels (use view bounds for zoom)
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        
        // X axis labels - just below the plot area
        const xLabelY = h - paddingBottom + 15;
        ctx.fillText(viewMinX.toFixed(1), paddingLeft, xLabelY);
        ctx.fillText(viewMaxX.toFixed(1), w - paddingRight, xLabelY);
        ctx.fillText('w‚ÇÅ', (paddingLeft + w - paddingRight) / 2, xLabelY);
        
        // Y axis labels - just left of the plot area
        ctx.textAlign = 'right';
        ctx.fillText(viewMinY.toFixed(1), paddingLeft - 4, h - paddingBottom + 3);
        ctx.fillText(viewMaxY.toFixed(1), paddingLeft - 4, paddingTop + 3);
        
        // Y axis title
        ctx.save();
        ctx.translate(12, (paddingTop + h - paddingBottom) / 2);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = 'center';
        ctx.fillText('w‚ÇÇ', 0, 0);
        ctx.restore();
    }
   
    function updateUI() {
        try {
            document.getElementById('stepCount').textContent = trainingState.step;
            const lastLoss = history.loss[history.loss.length - 1];
            const lossValue = document.getElementById('lossValue');
            if (lossValue) {
                lossValue.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }

            document.getElementById('totalAdds').textContent = trainingState.totalAdds.toLocaleString();
            document.getElementById('totalMuls').textContent = trainingState.totalMuls.toLocaleString();
            
            // Format ops count helper
            function formatOps(count) {
                if (count >= 1e9) return (count / 1e9).toFixed(1) + 'B';
                if (count >= 1e6) return (count / 1e6).toFixed(1) + 'M';
                if (count >= 1e3) return (count / 1e3).toFixed(1) + 'K';
                return count.toString();
            }
            
            // Update individual adds/muls displays
            const totalAddsDisplay = document.getElementById('totalAddsDisplay');
            const totalMulsDisplay = document.getElementById('totalMulsDisplay');
            if (totalAddsDisplay) totalAddsDisplay.textContent = formatOps(trainingState.totalAdds);
            if (totalMulsDisplay) totalMulsDisplay.textContent = formatOps(trainingState.totalMuls);
            
            // Update total ops display
            const totalOps = trainingState.totalAdds + trainingState.totalMuls;
            const totalOpsDisplay = document.getElementById('totalOpsDisplay');
            if (totalOpsDisplay) {
                totalOpsDisplay.textContent = formatOps(totalOps);
            }
            
            // Update epoch and step counters
            const epochCountEl = document.getElementById('epochCount');
            if (epochCountEl) {
                epochCountEl.textContent = dataset.epoch;
            }
            
            // Update train/test loss displays
            const trainLossEl = document.getElementById('trainLossValue');
            const testLossEl = document.getElementById('testLossValue');
            
            if (trainLossEl) {
                trainLossEl.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }
            
            // Only show test loss after evaluation button is clicked
            if (testLossEl && history.testLoss.length > 0 && revealOptions.evaluated) {
                const lastTestLoss = history.testLoss[history.testLoss.length - 1].loss;
                testLossEl.textContent = Number.isFinite(lastTestLoss) ? lastTestLoss.toExponential(2) : '‚Äî';
                
                // Highlight overfitting: test loss > train loss significantly
                if (lastTestLoss > lastLoss * 1.5) {
                    testLossEl.style.color = '#dc3545';  // Red warning
                } else {
                    testLossEl.style.color = '#ff9800';  // Normal orange
                }
            } else if (testLossEl) {
                testLossEl.textContent = '‚Äî';
                testLossEl.style.color = '#888';
            }
            
            // Update epoch status display
            if (dataset.generated) {
                const epochStatus = document.getElementById('epochStatus');
                if (epochStatus) {
                    epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
                }
            }
            
            // Calculate delta-loss (change in rolling average over last window)
            const deltaLossEl = document.getElementById('deltaLossValue');
            if (deltaLossEl && history.avgLoss.length >= 2) {
                const windowSize = Math.min(config.avgWindow, history.avgLoss.length);
                const currentAvg = history.avgLoss[history.avgLoss.length - 1];
                const prevAvg = history.avgLoss[Math.max(0, history.avgLoss.length - windowSize)];
                const deltaLoss = currentAvg - prevAvg;
                
                if (Number.isFinite(deltaLoss)) {
                    const sign = deltaLoss > 0 ? '+' : '';
                    deltaLossEl.textContent = sign + deltaLoss.toExponential(2);
                    // Green if decreasing (good), red if increasing (bad)
                    deltaLossEl.style.color = deltaLoss <= 0 ? '#28a745' : '#dc3545';
                } else {
                    deltaLossEl.textContent = '‚Äî';
                    deltaLossEl.style.color = '#666';
                }
            }

            // Update view slider max based on training progress
            try { updateViewSliderMax(); } catch(e) { /* ignore */ }

            try { drawNetwork(); } catch(e) { console.error('drawNetwork error:', e); }
            try { drawFitPlot(); } catch(e) { console.error('drawFitPlot error:', e); }
            try { drawTrainingTrace(); } catch(e) { console.error('drawTrainingTrace error:', e); }
            try { updateLossSurfaceZoom(); } catch(e) { console.error('updateLossSurfaceZoom error:', e); }
            try { drawLossSurface(); } catch(e) { console.error('drawLossSurface error:', e); }
            try { updateEquations(); } catch(e) { console.error('updateEquations error:', e); }
        } catch(e) {
            console.error('updateUI error:', e);
        }
    }
    
    // Track when we last auto-paused to allow continued training
    let lastAutoPauseStep = -2000;
    
    // Check if training should auto-pause (no improvement in last 1000 steps)
    function shouldAutoPause() {
        // Need at least 2000 steps before first check
        if (history.loss.length < 2000) return false;
        
        // Must run at least 1000 steps since last auto-pause before checking again
        if (trainingState.step - lastAutoPauseStep < 1000) return false;
        
        // Compute 1000-step rolling average for current window
        const windowSize = 1000;
        const currentWindow = history.loss.slice(-windowSize);
        const currentAvg = currentWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Compute 1000-step rolling average for previous window (1000 steps ago)
        const prevWindow = history.loss.slice(-2000, -1000);
        const prevAvg = prevWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Pause if current 1000-step average hasn't improved over previous 1000-step average
        if (currentAvg >= prevAvg) {
            lastAutoPauseStep = trainingState.step;
            return true;
        }
        return false;
    }

    // --------------- Wiring Controls ----------------

    function setupControls() {
        const lrSlider = document.getElementById('learningRate');
        const lrValue = document.getElementById('learningRateValue');
        lrSlider.addEventListener('input', () => {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        });
        (function initLR() {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        })();

        const noiseSlider = document.getElementById('noise');
        const noiseLabel = document.getElementById('noiseValue');
        noiseSlider.addEventListener('input', () => {
            config.noise = parseFloat(noiseSlider.value);
            noiseLabel.textContent = config.noise.toFixed(2);
        });
        config.noise = parseFloat(noiseSlider.value);
        noiseLabel.textContent = config.noise.toFixed(2);

        // ===== UNIFIED SLIDERS =====
        
        // Debounce timer for network config changes (avoid expensive recomputation on every slider tick)
        let networkConfigDebounceTimer = null;
        function debouncedResetModel(delay = 2000) {
            if (networkConfigDebounceTimer) {
                clearTimeout(networkConfigDebounceTimer);
            }
            networkConfigDebounceTimer = setTimeout(() => {
                networkConfigDebounceTimer = null;
                console.log('Debounced resetModel executing...');
                try {
                    resetModel();
                    console.log('resetModel completed');
                } catch(e) {
                    console.error('resetModel error:', e);
                }
            }, delay);
        }
        
        // Helper: Update slider value label position
        function updateSliderValuePosition(slider, valueEl) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const val = parseFloat(slider.value);
            const percent = ((val - min) / (max - min)) * 100;
            // Thumb doesn't go to 0% or 100% - it's constrained by thumb width (30px)
            // Interpolate position from 15px at 0% to (100% - 15px) at 100%
            valueEl.style.left = `calc(15px + (100% - 30px) * ${percent / 100})`;
            // Also update fill for non-range sliders
            slider.style.setProperty('--fill-percent', percent + '%');
            // Set thumb position on parent track element
            const track = slider.parentElement;
            if (track) track.style.setProperty('--thumb-position', percent + '%');
        }
        
        // Layers Slider
        const layersSlider = document.getElementById('layersSlider');
        const layersValue = document.getElementById('layersValue');
        if (layersSlider && layersValue) {
            console.log('Setting up layers slider, current network.numLayers:', network.numLayers);
            layersSlider.oninput = function() {
                const newVal = parseInt(this.value, 10);
                console.log('Layers slider changed to:', newVal);
                network.numLayers = newVal;
                layersValue.textContent = newVal.toString();
                updateSliderValuePosition(this, layersValue);
                // Abort any in-progress computation and schedule new one
                abortLossSurfaceComputation = true;
                scheduleLossSurfaceComputation(500);  // Short debounce for sliders
                // Immediately update network display
                initializeNetwork();
                populateWeightSelectors();
                drawNetwork();
            };
            // Initialize slider to match network state
            layersSlider.value = network.numLayers;
            layersValue.textContent = network.numLayers.toString();
            updateSliderValuePosition(layersSlider, layersValue);
        } else {
            console.error('Layers slider or value element not found!');
        }
        
        // Width Slider
        const widthSlider = document.getElementById('widthSlider');
        const widthValue = document.getElementById('widthValue');
        if (widthSlider && widthValue) {
            console.log('Setting up width slider, current network.hiddenSize:', network.hiddenSize);
            widthSlider.oninput = function() {
                const newVal = parseInt(this.value, 10);
                console.log('Width slider changed to:', newVal);
                network.hiddenSize = newVal;
                widthValue.textContent = newVal.toString();
                updateSliderValuePosition(this, widthValue);
                // Abort any in-progress computation and schedule new one
                abortLossSurfaceComputation = true;
                scheduleLossSurfaceComputation(500);  // Short debounce for sliders
                // Immediately update network display
                initializeNetwork();
                populateWeightSelectors();
                drawNetwork();
            };
            // Initialize
            widthSlider.value = network.hiddenSize;
            widthValue.textContent = network.hiddenSize.toString();
            updateSliderValuePosition(widthSlider, widthValue);
        } else {
            console.error('Width slider or value element not found!');
        }
        
        // Train Range Sliders (two-thumb)
        const trainMinSlider = document.getElementById('trainMinSlider');
        const trainMaxSlider = document.getElementById('trainMaxSlider');
        const trainMinValue = document.getElementById('trainMinValue');
        const trainMaxValue = document.getElementById('trainMaxValue');
        const trainRangeFill = document.getElementById('trainRangeFill');
        
        function updateTrainRangeUI() {
            if (!trainMinSlider || !trainMaxSlider) return;
            
            const min = parseFloat(trainMinSlider.min);
            const max = parseFloat(trainMinSlider.max);
            const minVal = parseFloat(trainMinSlider.value);
            const maxVal = parseFloat(trainMaxSlider.value);
            
            // Thumb is 34px wide, so half-width is 17px
            // Interpolate position from 17px at 0% to (100% - 17px) at 100%
            const minPercent = ((minVal - min) / (max - min));
            const maxPercent = ((maxVal - min) / (max - min));
            
            // Update value labels - position them on the thumb center
            if (trainMinValue) {
                trainMinValue.textContent = minVal.toFixed(1);
                trainMinValue.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            }
            if (trainMaxValue) {
                trainMaxValue.textContent = maxVal.toFixed(1);
                trainMaxValue.style.left = `calc(17px + (100% - 34px) * ${maxPercent})`;
            }
            
            // Update fill bar - same positioning formula
            if (trainRangeFill) {
                const leftPos = `calc(17px + (100% - 34px) * ${minPercent})`;
                const rightPos = `calc(17px + (100% - 34px) * ${maxPercent})`;
                trainRangeFill.style.left = leftPos;
                trainRangeFill.style.width = `calc((100% - 34px) * ${maxPercent - minPercent})`;
            }
        }
        
        if (trainMinSlider && trainMaxSlider) {
            trainMinSlider.addEventListener('input', () => {
                // Ensure min doesn't exceed max
                const maxVal = parseFloat(trainMaxSlider.value);
                if (parseFloat(trainMinSlider.value) > maxVal - 0.2) {
                    trainMinSlider.value = (maxVal - 0.2).toString();
                }
                config.trainXMin = parseFloat(trainMinSlider.value);
                updateTrainRangeUI();
                if (dataset.generated) {
                    updateTrainingRangeFromConfig();
                    drawFitPlot();
                    updateUI();
                }
            });
            
            trainMaxSlider.addEventListener('input', () => {
                // Ensure max doesn't go below min
                const minVal = parseFloat(trainMinSlider.value);
                if (parseFloat(trainMaxSlider.value) < minVal + 0.2) {
                    trainMaxSlider.value = (minVal + 0.2).toString();
                }
                config.trainXMax = parseFloat(trainMaxSlider.value);
                updateTrainRangeUI();
                if (dataset.generated) {
                    updateTrainingRangeFromConfig();
                    drawFitPlot();
                    updateUI();
                }
            });
        }
        
        // View Slider (training trace zoom)
        const viewSlider = document.getElementById('viewSlider');
        const viewValue = document.getElementById('viewValue');
        
        if (viewSlider && viewValue) {
            viewSlider.addEventListener('input', () => {
                const sliderVal = parseInt(viewSlider.value, 10);
                const maxPossible = parseInt(viewSlider.max, 10);
                
                if (sliderVal >= maxPossible) {
                    traceViewState.maxStep = Infinity;
                    viewValue.textContent = 'All';
                } else {
                    traceViewState.maxStep = sliderVal;
                    viewValue.textContent = sliderVal.toString();
                }
                updateSliderValuePosition(viewSlider, viewValue);
                drawTrainingTrace();
            });
            // Initialize
            updateSliderValuePosition(viewSlider, viewValue);
        }
        
        // Legacy backward compatibility (old mobile sliders - hidden)
        const numLayersSlider = document.getElementById('numLayers');
        const numLayersDisplay = document.getElementById('numLayersDisplay');
        const hiddenSizeSlider = document.getElementById('hiddenSize');
        const hiddenSizeDisplay = document.getElementById('hiddenSizeDisplay');

        const xMinSlider = document.getElementById('xMin');
        const xMaxSlider = document.getElementById('xMax');
        const xMinLabel = document.getElementById('xMinLabel');
        const xMaxLabel = document.getElementById('xMaxLabel');
        function syncXRange() {
            let minVal = parseFloat(xMinSlider.value);
            let maxVal = parseFloat(xMaxSlider.value);
            if (minVal >= maxVal) {
                if (this === xMinSlider) {
                    minVal = maxVal - 0.1;
                    xMinSlider.value = minVal.toString();
                } else {
                    maxVal = minVal + 0.1;
                    xMaxSlider.value = maxVal.toString();
                }
            }
            config.xMin = minVal;
            config.xMax = maxVal;
            xMinLabel.textContent = minVal.toFixed(1);
            xMaxLabel.textContent = maxVal.toFixed(1);
        }
        xMinSlider.addEventListener('input', syncXRange);
        xMaxSlider.addEventListener('input', syncXRange);
        config.xMin = parseFloat(xMinSlider.value);
        config.xMax = parseFloat(xMaxSlider.value);

        // Mobile x-range sliders
        const xMinMobile = document.getElementById('xMinMobile');
        const xMaxMobile = document.getElementById('xMaxMobile');
        const xMinMobileVal = document.getElementById('xMinMobileVal');
        const xMaxMobileVal = document.getElementById('xMaxMobileVal');
        if (xMinMobile && xMaxMobile) {
            xMinMobile.addEventListener('input', () => {
                config.xMin = parseFloat(xMinMobile.value);
                xMinMobileVal.textContent = config.xMin.toFixed(1);
                xMinSlider.value = config.xMin;
                drawFitPlot();
            });
            xMaxMobile.addEventListener('input', () => {
                config.xMax = parseFloat(xMaxMobile.value);
                xMaxMobileVal.textContent = config.xMax.toFixed(1);
                xMaxSlider.value = config.xMax;
                drawFitPlot();
            });
        }

        const targetFuncInput = document.getElementById('targetFuncInput');
        
        // Helper to update loss surface when target function changes
        function onTargetFuncChange() {
            compileTargetFunc();
            
            // Invalidate loss surface cache - new function means new landscape
            lossSurfaceCache = null;
            
            // Reset color scale calibration so it recalibrates for new function
            lossColorScale.calibrated = false;
            
            // Immediately recompute loss surface with new function
            if (dataset.generated || network.weights.length > 0) {
                computeLossSurface();
                updateLossScaleLegend();
            }
            
            drawFitPlot();  // Update preview
            drawLossSurface();  // Redraw with new colors
        }
        
        targetFuncInput.addEventListener('change', onTargetFuncChange);
        targetFuncInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                onTargetFuncChange();
            }
        });
        
        // Phase 1: Data generation controls
        const totalSamplesSlider = document.getElementById('totalSamples');
        const totalSamplesValue = document.getElementById('totalSamplesValue');
        if (totalSamplesSlider && totalSamplesValue) {
            totalSamplesSlider.addEventListener('input', () => {
                config.totalSamples = parseInt(totalSamplesSlider.value);
                totalSamplesValue.textContent = config.totalSamples;
            });
            config.totalSamples = parseInt(totalSamplesSlider.value);
        }
        
        // Data Range inputs for Phase 1
        const dataXMinInput = document.getElementById('dataXMinInput');
        const dataXMaxInput = document.getElementById('dataXMaxInput');
        const trainXMinInput = document.getElementById('trainXMinInput');
        const trainXMaxInput = document.getElementById('trainXMaxInput');
        
        // Helper function: calculate 95% training range, rounded toward zero for symmetry
        function calculateTrainingRange() {
            const center = (config.dataXMin + config.dataXMax) / 2;
            const halfRange = (config.dataXMax - config.dataXMin) / 2;
            const trainHalfRange = halfRange * 0.95;
            
            // Round toward zero to nearest 0.1 for clean symmetric values
            // E.g., for data range [-5, 5], train range becomes [-4.7, 4.7] not [-4.75, 4.75]
            const roundTowardZero = (val) => {
                const rounded = Math.round(val * 10) / 10;
                // If rounding away from zero, round the other way
                if (Math.abs(rounded) > Math.abs(val)) {
                    return val > 0 ? Math.floor(val * 10) / 10 : Math.ceil(val * 10) / 10;
                }
                return rounded;
            };
            
            config.trainXMin = roundTowardZero(center - trainHalfRange);
            config.trainXMax = roundTowardZero(center + trainHalfRange);
            
            // Clamp to data range
            config.trainXMin = Math.max(config.dataXMin, config.trainXMin);
            config.trainXMax = Math.min(config.dataXMax, config.trainXMax);
            
            // Update hidden inputs
            if (trainXMinInput) trainXMinInput.value = config.trainXMin;
            if (trainXMaxInput) trainXMaxInput.value = config.trainXMax;
            
            // Update sliders if they exist
            const trainMinSlider = document.getElementById('trainMinSlider');
            const trainMaxSlider = document.getElementById('trainMaxSlider');
            if (trainMinSlider) {
                trainMinSlider.min = config.dataXMin.toString();
                trainMinSlider.max = config.dataXMax.toString();
                trainMinSlider.value = config.trainXMin.toString();
            }
            if (trainMaxSlider) {
                trainMaxSlider.min = config.dataXMin.toString();
                trainMaxSlider.max = config.dataXMax.toString();
                trainMaxSlider.value = config.trainXMax.toString();
            }
            
            // Update slider UI labels if function exists
            if (typeof updateTrainRangeUI === 'function') {
                updateTrainRangeUI();
            }
        }
        
        if (dataXMinInput && dataXMaxInput) {
            // Helper to update when data range changes
            function onDataRangeChange() {
                config.dataXMin = parseFloat(dataXMinInput.value);
                config.dataXMax = parseFloat(dataXMaxInput.value);
                config.xMin = config.dataXMin;
                config.xMax = config.dataXMax;
                
                // Recalculate training range to 95% of new data range
                calculateTrainingRange();
                
                // Invalidate loss surface - it samples across data range
                lossSurfaceCache = null;
                lossColorScale.calibrated = false;
                
                // Recompute if we have a network
                if (network.weights.length > 0) {
                    computeLossSurface();
                    updateLossScaleLegend();
                }
                
                drawFitPlot();
                drawLossSurface();
            }
            
            dataXMinInput.addEventListener('change', onDataRangeChange);
            dataXMaxInput.addEventListener('change', onDataRangeChange);
            
            config.dataXMin = parseFloat(dataXMinInput.value);
            config.dataXMax = parseFloat(dataXMaxInput.value);
            config.xMin = config.dataXMin;
            config.xMax = config.dataXMax;
        }
        
        if (trainXMinInput && trainXMaxInput) {
            trainXMinInput.addEventListener('change', () => {
                config.trainXMin = parseFloat(trainXMinInput.value);
                // Clamp to data range
                config.trainXMin = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMin));
                trainXMinInput.value = config.trainXMin;
                drawFitPlot();
            });
            trainXMaxInput.addEventListener('change', () => {
                config.trainXMax = parseFloat(trainXMaxInput.value);
                // Clamp to data range
                config.trainXMax = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMax));
                trainXMaxInput.value = config.trainXMax;
                drawFitPlot();
            });
            config.trainXMin = parseFloat(trainXMinInput.value);
            config.trainXMax = parseFloat(trainXMaxInput.value);
        }
        
        // Evaluate button
        const evaluateBtn = document.getElementById('evaluateBtn');
        const evalResults = document.getElementById('evalResults');
        if (evaluateBtn) {
            evaluateBtn.addEventListener('click', () => {
                if (!dataset.generated) {
                    alert('Generate training data first!');
                    return;
                }
                
                const results = runEvaluation();
                
                if (results && evalResults) {
                    let resultText = `Total: ${results.testLossTotal.toFixed(4)}`;
                    if (results.pointsInRange > 0) {
                        resultText += ` | In-range: ${results.testLossInRange.toFixed(4)}`;
                    }
                    if (results.pointsOutRange > 0) {
                        resultText += ` | Out-range: ${results.testLossOutRange.toFixed(4)}`;
                        // Highlight if extrapolation is much worse
                        if (results.testLossOutRange > results.testLossInRange * 2) {
                            resultText += ' ‚ö†Ô∏è';
                        }
                    }
                    evalResults.textContent = resultText;
                    evalResults.style.display = 'inline';
                    evalResults.style.color = '#ff9800';
                }
                
                updateUI();
            });
        }
        
        // Generate Data button
        const generateDataBtn = document.getElementById('generateDataBtn');
        if (generateDataBtn) {
            generateDataBtn.addEventListener('click', () => {
                compileTargetFunc();
                
                // Calculate training range at 95% of data range (symmetric, rounded toward zero)
                calculateTrainingRange();
                
                generateDataset();
                resetModel();  // Initialize model for new data
                updateUI();
            });
        }
        
        // New Data button (returns to Phase 1)
        const newDataBtn = document.getElementById('newDataBtn');
        if (newDataBtn) {
            newDataBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger header toggle
                clearDataset();
                updateUI();
            });
        }
        
        // Data summary accordion toggle
        const dataSummaryHeader = document.getElementById('dataSummaryHeader');
        if (dataSummaryHeader) {
            dataSummaryHeader.addEventListener('click', (e) => {
                // Don't toggle if clicking the New button
                if (e.target.id === 'newDataBtn') return;
                
                const content = document.getElementById('dataSummaryContent');
                const toggle = document.getElementById('dataSummaryToggle');
                if (content && toggle) {
                    const isHidden = content.style.display === 'none';
                    content.style.display = isHidden ? 'block' : 'none';
                    toggle.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                }
            });
        }
        
        // Learning Guide sidebar toggle (sidebar is visible by default)
        const guideToggle = document.getElementById('guideToggle');
        const guideSidebar = document.getElementById('guideSidebar');
        
        if (guideToggle && guideSidebar) {
            guideToggle.addEventListener('click', () => {
                const isHidden = guideSidebar.style.display === 'none';
                guideSidebar.style.display = isHidden ? '' : 'none';  // Use '' to restore default flex behavior
                guideToggle.style.background = isHidden ? '#138496' : '#17a2b8';
                guideToggle.textContent = isHidden ? 'Hide Guide ‚óÄ' : 'üìñ Show Guide';
            });
        }
        
        // Reset Model button (keeps data, reinitializes weights)
        const resetModelBtn = document.getElementById('resetModelBtn');
        if (resetModelBtn) {
            resetModelBtn.addEventListener('click', () => {
                resetModel();
                document.getElementById('runBtn').textContent = 'Run';
                updateUI();
            });
        }
        
        // Run Epoch button
        const runEpochBtn = document.getElementById('runEpochBtn');
        if (runEpochBtn) {
            runEpochBtn.addEventListener('click', async () => {
                if (!dataset.generated) {
                    alert('Generate examples first!');
                    return;
                }
                
                exitComparisonMode();
                runEpochBtn.disabled = true;
                runEpochBtn.textContent = 'Running...';
                
                // Run one complete epoch
                const stepsPerEpoch = dataset.train.length;
                const startStep = dataset.stepInEpoch;
                const stepsRemaining = stepsPerEpoch - startStep;
                
                for (let i = 0; i < stepsRemaining; i++) {
                    trainStep();
                    
                    // Update UI periodically
                    if (i % 10 === 0) {
                        updateUI();
                        await new Promise(r => setTimeout(r, 0));  // Allow UI to update
                    }
                }
                
                runEpochBtn.disabled = false;
                runEpochBtn.textContent = 'Run Epoch';
                updateUI();
            });
        }
        
        // Reveal controls (Assessment phase)
        const showHeldOutCheckbox = document.getElementById('showHeldOut');
        const showRecipeCheckbox = document.getElementById('showRecipe');
        
        if (showHeldOutCheckbox) {
            showHeldOutCheckbox.addEventListener('change', () => {
                revealOptions.showHeldOut = showHeldOutCheckbox.checked;
                drawFitPlot();
                // Also evaluate test loss when revealing held-out
                if (revealOptions.showHeldOut && dataset.generated) {
                    const testLoss = computeTestLoss();
                    if (history.testLoss.length === 0 || 
                        history.testLoss[history.testLoss.length - 1].step !== trainingState.step) {
                        history.testLoss.push({ step: trainingState.step, loss: testLoss });
                    }
                    updateUI();
                }
            });
        }
        
        if (showRecipeCheckbox) {
            showRecipeCheckbox.addEventListener('change', () => {
                revealOptions.showRecipe = showRecipeCheckbox.checked;
                drawFitPlot();
            });
        }
        
        // Recipe accordion toggle
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        const recipeControls = document.getElementById('recipeControls');
        if (toggleRecipeBtn && recipeControls) {
            toggleRecipeBtn.addEventListener('click', () => {
                const isHidden = recipeControls.style.display === 'none';
                recipeControls.style.display = isHidden ? 'flex' : 'none';
                recipeControls.style.opacity = isHidden ? '1' : '0.6';  // Bright when editing
                toggleRecipeBtn.textContent = isHidden ? '‚ñº Hide Recipe' : '‚úèÔ∏è Edit Recipe';
            });
        }
        
        // View full data button
        const viewFullDataBtn = document.getElementById('viewFullDataBtn');
        if (viewFullDataBtn) {
            viewFullDataBtn.addEventListener('click', showFullDataView);
        }
        
        // Equations accordion toggle
        const toggleEquationsBtn = document.getElementById('toggleEquationsBtn');
        const equationsDiv = document.getElementById('equationsDiv');
        const equationsHeader = document.getElementById('equationsHeader');
        
        if (toggleEquationsBtn && equationsDiv) {
            const toggleEquations = () => {
                const isHidden = equationsDiv.style.display === 'none';
                equationsDiv.style.display = isHidden ? 'grid' : 'none';
                toggleEquationsBtn.textContent = isHidden ? '‚ñº Collapse' : '‚ñ∂ Expand';
            };
            
            toggleEquationsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleEquations();
            });
            
            // Also allow clicking on the header
            if (equationsHeader) {
                equationsHeader.addEventListener('click', toggleEquations);
            }
            
            // Start collapsed on mobile/tablet (sidebar is at bottom, want it visible)
            if (window.innerWidth <= 768) {
                equationsDiv.style.display = 'none';
                toggleEquationsBtn.textContent = '‚ñ∂ Expand';
            }
        }

        const activationSelector = document.getElementById('activationSelector');
        activationSelector.addEventListener('click', (e) => {
            if (!e.target.classList.contains('activation-option')) return;
            const options = activationSelector.querySelectorAll('.activation-option');
            options.forEach(opt => opt.classList.remove('selected'));
            e.target.classList.add('selected');
            config.activation = e.target.dataset.act;
            updateUI();
        });

        // Optimizer buttons
        document.querySelectorAll('#optimizerButtons .opt-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#optimizerButtons .opt-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                
                // Update config
                config.optimizer = btn.dataset.opt;
                
                // Auto-adjust learning rate for optimizer
                // Adam works best with lower learning rates (0.001-0.01)
                // Simple SGD works with higher rates (0.01-0.1)
                const lrSlider = document.getElementById('learningRate');
                const lrValue = document.getElementById('learningRateValue');
                if (btn.dataset.opt === 'adam' && config.learningRate > 0.02) {
                    // Lower the learning rate for Adam
                    config.learningRate = 0.01;
                    lrSlider.value = Math.log10(0.01);
                    lrValue.textContent = '0.010';
                } else if (btn.dataset.opt === 'sgd' && config.learningRate < 0.05) {
                    // Raise the learning rate for SGD
                    config.learningRate = 0.1;
                    lrSlider.value = Math.log10(0.1);
                    lrValue.textContent = '0.100';
                }
                
                initializeOptimizerState();
                updateUI();
            });
        });

        const gifBtnEl = document.getElementById('gifBtn');
        // Set button label based on whether GIF capture is available
        gifBtnEl.textContent = canUseGifWorkers() ? 'Capture GIF' : 'Screenshot';
        gifBtnEl.title = canUseGifWorkers() 
            ? 'Record an animated GIF of training convergence' 
            : 'Save a PNG screenshot (run from web server for animated GIF)';
        gifBtnEl.addEventListener('click', () => {
            startGifCapture();
        });

        const saveRunABtn = document.getElementById('saveRunA');
        const saveRunBBtn = document.getElementById('saveRunB');
        const compareBtn = document.getElementById('compareBtn');
        
        saveRunABtn.addEventListener('click', () => saveRun('A'));
        saveRunBBtn.addEventListener('click', () => saveRun('B'));
        
        compareBtn.addEventListener('click', () => {
            if (savedRuns.A && savedRuns.B) {
                comparisonModeActive = !comparisonModeActive;
                // Toggle button appearance
                if (comparisonModeActive) {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#0056b3; color:white; border:1px solid #0056b3; cursor:pointer;';
                    compareBtn.textContent = '‚úì Comparing A vs B';
                    // Recompute loss surface to fit both trails
                    computeLossSurface();  // Recompute to fit both trails
                } else {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
                    compareBtn.textContent = 'Compare A vs B';
                }
                updateUI();
            }
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            exitComparisonMode();  // Exit comparison when stepping
            animatedStep();
        });

        document.getElementById('runBtn').addEventListener('click', () => {
            trainingState.running = !trainingState.running;
            const btn = document.getElementById('runBtn');
            btn.textContent = trainingState.running ? 'Pause' : 'Run';
            trainingState.lastUpdateTime = performance.now();
            if (trainingState.running) {
                exitComparisonMode();  // Exit comparison when running
                requestAnimationFrame(runLoop);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('runBtn').textContent = 'Run';
            reset();
        });

        document.getElementById('traceLoss').addEventListener('change', updateUI);
        document.getElementById('traceAvgLoss').addEventListener('change', updateUI);
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        document.getElementById('traceLogScale').addEventListener('change', updateUI);
        
        // Loss surface controls
        const weightXSelect = document.getElementById('weightXSelect');
        const weightYSelect = document.getElementById('weightYSelect');
        
        // Auto mode for loss landscape (uses global lossLandscapeAutoMode)
        const weightSelectContainer = document.getElementById('weightSelectContainer');
        
        function setAutoMode(enabled) {
            lossLandscapeAutoMode = enabled;
            if (weightSelectContainer) weightSelectContainer.style.opacity = enabled ? '0.5' : '1';
            if (autoSelectBtn) {
                autoSelectBtn.style.background = enabled ? '#007bff' : '#6c757d';
                autoSelectBtn.style.borderColor = enabled ? '#007bff' : '#6c757d';
            }
        }
        
        if (weightXSelect && weightYSelect) {
            weightXSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[0] = parseInt(weightXSelect.value);
                lossSurfaceCache = null;  // Invalidate cache
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
            weightYSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[1] = parseInt(weightYSelect.value);
                lossSurfaceCache = null;
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
        }
        
        const autoSelectBtn = document.getElementById('autoSelectBtn');
        if (autoSelectBtn) {
            autoSelectBtn.addEventListener('click', () => {
                setAutoMode(true);  // Re-enter auto mode
                autoSelectBtn.textContent = '...';
                setTimeout(() => {
                    autoSelectInterestingWeights();
                    computeLossSurface();
                    drawLossSurface();
                    drawNetwork();  // Update highlight boxes
                    autoSelectBtn.textContent = 'Auto';
                }, 10);
            });
        }
        
        // Rolling average window slider
        const avgWindowSlider = document.getElementById('avgWindowSlider');
        const avgWindowValue = document.getElementById('avgWindowValue');
        avgWindowSlider.addEventListener('input', () => {
            config.avgWindow = parseInt(avgWindowSlider.value);
            avgWindowValue.textContent = config.avgWindow;
            // Recalculate all rolling averages with new window size
            history.avgLoss = [];
            const minPointsForAvg = 10;
            for (let i = 0; i < history.loss.length; i++) {
                if (i + 1 < minPointsForAvg) {
                    history.avgLoss.push(null);  // Not enough points yet
                } else {
                    let sum = 0, count = 0;
                    for (let j = i; j >= 0 && count < config.avgWindow; j--, count++) {
                        sum += history.loss[j];
                    }
                    history.avgLoss.push(sum / Math.max(1, count));
                }
            }
            updateUI();
        });
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        
        // Activation buttons in header
        document.querySelectorAll('#activationButtons .act-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#activationButtons .act-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                    b.style.fontWeight = '500';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
                
                // Update config
                config.activation = btn.dataset.act;
                
                // Also update hidden selector for compatibility
                const options = document.querySelectorAll('#activationSelector .activation-option');
                options.forEach(opt => opt.classList.remove('selected'));
                document.querySelector(`#activationSelector .activation-option[data-act="${btn.dataset.act}"]`)?.classList.add('selected');
                
                updateUI();
            });
        });
        
        // OLD DRAG HANDLES - Now replaced by unified sliders
        // The drag handles are hidden but we keep setupDragHandle function for potential future use
        // All control is now done via the new sliders: layersSlider, widthSlider, trainMinSlider/trainMaxSlider, viewSlider
        
        // Update displays on init
        document.getElementById('networkLayersDisplay').textContent = network.numLayers;
        document.getElementById('networkSizeDisplay').textContent = network.hiddenSize;
        document.getElementById('xMinDisplay').textContent = config.xMin.toFixed(1);
        document.getElementById('xMaxDisplay').textContent = config.xMax.toFixed(1);
    }
    
    function setupDragHandle(elementId, direction, onDrag, getLimits) {
        const handle = document.getElementById(elementId);
        if (!handle) return;
        
        let startX, startY;
        let currentOffset = 0;
        let intervalId = null;
        const DEAD_ZONE = 10;  // pixels before triggering
        const INTERVAL_MS = 200;  // slower rate - 5 changes per second max
        const INCREMENT_PER_TICK = 15;  // pixels worth of change per tick
        
        const startInterval = () => {
            if (intervalId) return;
            intervalId = setInterval(() => {
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    // Check if we can move in this direction
                    const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                    const wantsIncrease = currentOffset > 0;
                    
                    // For vertical handles, up (negative offset) = increase
                    const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                    
                    if ((effectiveIncrease && limits.canIncrease) || (!effectiveIncrease && limits.canDecrease)) {
                        const sign = currentOffset > 0 ? 1 : -1;
                        onDrag(sign * INCREMENT_PER_TICK);
                    }
                }
            }, INTERVAL_MS);
        };
        
        const stopInterval = () => {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        };
        
        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            currentOffset = 0;
            
            // Disable transition during drag for immediate feedback
            handle.style.transition = 'none';
            
            const onMouseMove = (e) => {
                const rawOffset = direction === 'horizontal' ? (e.clientX - startX) : (e.clientY - startY);
                
                // Check limits and prevent visual displacement in blocked direction
                const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                const wantsIncrease = rawOffset > 0;
                const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                
                // Block displacement if at limit
                if (effectiveIncrease && !limits.canIncrease) {
                    currentOffset = direction === 'vertical' ? Math.max(0, rawOffset) : Math.min(0, rawOffset);
                } else if (!effectiveIncrease && !limits.canDecrease) {
                    currentOffset = direction === 'vertical' ? Math.min(0, rawOffset) : Math.max(0, rawOffset);
                } else {
                    currentOffset = rawOffset;
                }
                
                // Clamp visual offset to reasonable range (¬±20px)
                const clampedOffset = Math.max(-20, Math.min(20, currentOffset));
                
                // Visual feedback - move the handle
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = `translateX(calc(-50% + ${clampedOffset}px))`;
                    } else {
                        handle.style.transform = `translateX(${clampedOffset}px)`;
                    }
                } else {
                    handle.style.transform = `translateY(calc(-50% + ${clampedOffset}px))`;
                }
                
                // Start interval if displaced beyond dead zone
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    startInterval();
                } else {
                    stopInterval();
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                stopInterval();
                
                // Re-enable transition for rubberband effect
                handle.style.transition = 'transform 0.15s ease-out';
                
                // Rubberband back to original position
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = 'translateX(-50%)';
                    } else {
                        handle.style.transform = 'translateX(0)';
                    }
                } else {
                    handle.style.transform = 'translateY(-50%)';
                }
                
                currentOffset = 0;
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    // --------------- Init ----------------------------

    function init() {
        try {
            console.log('LearnCurve: initializing...');
            compileTargetFunc();
            initializeNetwork();
            setupControls();
            populateWeightSelectors();
            
            // Compute loss surface first (needs initialized network)
            console.log('LearnCurve: computing initial loss surface...');
            try {
                autoSelectInterestingWeights();
                
                // Make w1 and w2 start with LARGER random values for more dramatic visualization
                const largeInitScale = 4.0;  // ¬±4 instead of ¬±1
                setWeightByIndex(lossSurfaceWeightIndices[0], (Math.random() - 0.5) * 2 * largeInitScale);
                setWeightByIndex(lossSurfaceWeightIndices[1], (Math.random() - 0.5) * 2 * largeInitScale);
                
                // Record start position BEFORE computing surface
                lossSurfaceStartPosition = {
                    x: getWeightByIndex(lossSurfaceWeightIndices[0]),
                    y: getWeightByIndex(lossSurfaceWeightIndices[1])
                };
                lossSurfaceTrail = [lossSurfaceStartPosition];
                
                computeLossSurface();
                console.log('LearnCurve: loss surface computed, cache:', lossSurfaceCache ? 'ready' : 'null');
            } catch(e) {
                console.error('Initial loss surface error:', e);
            }
            
            console.log('LearnCurve: setup complete, drawing initial UI...');
            
            // Draw all charts immediately (don't wait for requestAnimationFrame)
            try {
                console.log('LearnCurve: drawing all charts...');
                drawNetwork();
                drawFitPlot();
                drawTrainingTrace();
                drawLossSurface();
                updateEquations();
                
                // Update phase UI at the end
                updatePhaseUI();
                updateUI();
                
                console.log('LearnCurve: initialization complete');
            } catch(e) {
                console.error('Initial draw error:', e);
            }
        } catch(e) {
            console.error('Init error:', e);
        }
    }

    // Run init immediately since script is at end of body
    console.log('LearnCurve: starting init...');
    init();
</script>
</body>
</html>

