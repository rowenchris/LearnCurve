<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Interactive visualization of neural network learning. Watch a network learn to approximate any function in real-time.">
    <meta name="keywords" content="neural network, machine learning, deep learning, education, visualization, gradient descent">
    <title>LearnCurve - Interactive Neural Network Demo</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 16px;
            background: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 10px 14px 14px 14px;
            min-height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-size: 22px;
            margin: 0 0 8px 0;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 10px;
        }
        
        .controls-strip {
            grid-column: 1 / -1;
        }
        
        .viz-grid {
            display: contents;
        }

        .panel {
            background: #fafafa;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
        }

        .panel h2 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #444;
            border-bottom: 2px solid #007bff;
            padding-bottom: 3px;
        }

        .panel h3 {
            font-size: 14px;
            margin: 6px 0;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            font-size: 12px;
            min-width: 150px;
        }

        .control-group label {
            margin-bottom: 2px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 160px;
        }

        .control-group select,
        .control-group input[type="text"] {
            font-size: 13px;
            padding: 2px 4px;
        }

        .value {
            font-size: 11px;
            color: #777;
        }

        button {
            padding: 6px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        #networkCanvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 10px auto;
            max-width: 100%;
            height: auto;
        }

        canvas.chart {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
            touch-action: manipulation;  /* Better touch handling on mobile */
        }
        
        canvas {
            touch-action: manipulation;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
        }

        .stat-value {
            font-size: 13px;
            font-weight: bold;
        }

        .activation-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .activation-option {
            font-size: 11px;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid #ccc;
            cursor: pointer;
            background: #fff;
        }

        .activation-option.selected {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        .equations-panel {
            grid-column: 1 / -1;  /* Span all columns */
            flex: 1;  /* Fill remaining height */
            display: flex;
            flex-direction: column;
        }
        
        .equations-panel h2 {
            margin-bottom: 4px;
            flex-shrink: 0;
        }
        
        .equations {
            font-size: 11px;
            line-height: 1.3;
            flex: 1;
            min-height: 150px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;  /* 2 columns: Forward Pass | Backward Pass */
            gap: 12px;
        }

        .equation-block {
            padding: 4px 6px;
        }

        .equation-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .math {
            font-family: "Courier New", monospace;
            color: #333;
            font-size: 13px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #777;
            margin-bottom: 2px;
        }

        /* Tablet and smaller - single column layout */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
                max-width: 100%;
            }
            .grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            .panel h2 {
                font-size: 15px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
            }
            .control-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .control-group {
                flex-wrap: wrap;
            }
            .equations-panel {
                grid-column: 1;  /* Single column on mobile */
            }
            .equations {
                grid-template-columns: 1fr 1fr;  /* 2 columns on tablet */
                font-size: 12px;
                max-height: 220px;
            }
        }
        
        /* iPhone and small mobile */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                max-width: 100%;
                overflow-x: hidden;
            }
            h1 {
                font-size: 18px;
            }
            .subtitle {
                font-size: 11px;
                line-height: 1.4;
            }
            .panel {
                padding: 8px;
                overflow-x: auto;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
                height: auto;
            }
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
            }
            .control-group input[type="range"] {
                width: 100%;
            }
            .control-group select {
                width: 100%;
            }
            .stats {
                flex-direction: column;
                gap: 4px;
                align-items: flex-start;
            }
            button {
                padding: 8px 12px;
                font-size: 13px;
            }
            .chart-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            .checkbox-group {
                font-size: 12px;
            }
            .equations {
                grid-template-columns: 1fr;  /* Single column on small screens */
                font-size: 11px;
                max-height: 250px;
            }
            /* Hide drag handles on mobile - they don't work well with touch */
            #sizeHandle, #layersHandle, #xMinHandle, #xMaxHandle {
                display: none;
            }
            /* Show hidden sliders on mobile for layer/size control */
            #numLayers, #hiddenSize {
                display: inline-block !important;
                width: 80px;
                margin: 0 5px;
            }
            #numLayersValue, #hiddenSizeValue {
                display: inline !important;
            }
            /* Add mobile-only slider container */
            .mobile-sliders {
                display: flex !important;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 10px;
                padding: 8px;
                background: #f0f4f8;
                border-radius: 4px;
            }
            /* Make activation buttons stack */
            #networkActivation {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            #networkActivation > div {
                flex-wrap: wrap;
            }
        }
    </style>
    <!-- GIF library for capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body>
<div class="container">
    <h1 style="margin-bottom:2px;">LearnCurve</h1>
    <p style="margin:0 0 8px 0; font-size:11px; color:#666;">An interactive visualization tool for understanding how neural networks learn to approximate mathematical functions in real-time. ¬© 2025 Chris Rowen ‚Äî Available under <a href="https://opensource.org/licenses/MIT" style="color:#007bff; text-decoration:none;">MIT License</a></p>

    <div class="grid">
        <!-- CONTROLS STRIP - spans full width, two rows -->
        <div class="panel controls-strip" style="padding:8px 12px;">
            <!-- Row 1: Target function and training parameters -->
            <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:6px;">
                <!-- Target function -->
                <div style="display:flex; align-items:center; gap:4px;">
                    <label style="font-size:11px; font-weight:600;">Target f(x):</label>
                    <input type="text" id="targetFuncInput" value="x*x" style="width:100px; font-size:11px; padding:3px 5px;" />
                    <span style="font-size:9px; color:#777;">(x + - * / ^ sin cos exp log sqrt abs PI E)</span>
                </div>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Noise -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#555;">Noise:</label>
                    <input type="range" id="noise" min="0" max="1" step="0.05" value="0" style="width:50px;">
                    <span class="value" id="noiseValue" style="font-size:10px; min-width:28px;">0.00</span>
                </div>
                
                <!-- Learning Rate -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#555;">Learning Rate:</label>
                    <input type="range" id="learningRate" min="-3" max="-0.3" step="0.01" value="-1" style="width:50px;">
                    <span class="value" id="learningRateValue" style="font-size:10px; min-width:32px;">0.100</span>
                </div>
                
                <!-- Optimizer -->
                <div id="optimizerButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#555;">Optimizer:</label>
                    <button class="opt-btn" data-opt="sgd" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer;" title="Simple Gradient Descent&#10;&#10;w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇL/‚àÇw&#10;&#10;Each weight moves opposite to its gradient, proportional to learning rate Œ∑.&#10;&#10;Recommended learning rate: 0.05-0.2&#10;Simple but can be slow or oscillate.">Simple</button>
                    <button class="opt-btn" data-opt="adam" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer;" title="Adam Optimizer&#10;&#10;Combines two ideas:&#10;‚Ä¢ Momentum: smooth out noisy gradients&#10;‚Ä¢ Adaptive rates: bigger steps for rare gradients&#10;&#10;Recommended learning rate: 0.001-0.02&#10;(Lower than Simple because Adam amplifies updates)&#10;&#10;Usually learns faster and more reliably.">Adam</button>
                </div>
                
                <!-- Activation -->
                <div id="activationButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#555;">Activation:</label>
                    <button class="act-btn" data-act="relu" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="14" height="10" viewBox="0 0 20 14"><path d="M1 10 L10 10 L19 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>ReLU
                    </button>
                    <button class="act-btn" data-act="sigmoid" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="16" height="10" viewBox="0 0 24 14"><path d="M1 12 L4 12 Q8 12 12 7 Q16 2 20 2 L23 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>Sigmoid
                    </button>
                </div>
            </div>
            
            <!-- Row 2: Action buttons, compare, and stats -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <!-- Action buttons -->
                <button id="stepBtn" style="padding:4px 10px; font-size:11px;">Step</button>
                <button id="runBtn" style="padding:4px 10px; font-size:11px;">Run</button>
                <button id="resetBtn" style="padding:4px 10px; font-size:11px;">Reset</button>
                <button id="gifBtn" style="padding:4px 8px; font-size:10px;">Capture</button>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Compare buttons -->
                <button id="saveRunA" style="padding:4px 8px; font-size:10px; background:#6c757d;">Save Run A</button>
                <button id="saveRunB" style="padding:4px 8px; font-size:10px; background:#6c757d;">Save Run B</button>
                <button id="compareBtn" style="padding:4px 8px; font-size:10px; background:#6c757d;" disabled>Compare A vs B</button>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Stats -->
                <span style="font-size:11px; color:#555;">Step: <strong id="stepCount">0</strong></span>
                <span style="font-size:11px; color:#555;">Loss: <strong id="lossValue">‚Äî</strong></span>
                <span style="font-size:11px; color:#007bff;"><span id="stepsPerSec">‚Äî</span> steps/s</span>
            </div>
            
            <!-- Hidden elements -->
            <input type="range" id="xMin" min="-5" max="0" step="0.1" value="-2" style="display:none;">
            <input type="range" id="xMax" min="0" max="5" step="0.1" value="2" style="display:none;">
            <span id="xMinLabel" style="display:none;">-2</span>
            <span id="xMaxLabel" style="display:none;">2</span>
            <span id="runALabel" style="display:none;"></span>
            <span id="runBLabel" style="display:none;"></span>
            <span id="totalAdds" style="display:none;">0</span>
            <span id="totalMuls" style="display:none;">0</span>
            <span id="opsLossAdd" style="display:none">0</span>
            <span id="opsLossMul" style="display:none">0</span>
            <div class="activation-selector" id="activationSelector" style="display:none;">
                <span class="activation-option selected" data-act="relu">ReLU</span>
                <span class="activation-option" data-act="sigmoid">sigmoid</span>
            </div>
            <div class="mobile-sliders" style="display:none;">
                <input type="range" id="numLayers" min="1" max="4" step="1" value="1">
                <span id="numLayersValue">1</span>
                <input type="range" id="hiddenSize" min="2" max="16" step="1" value="3">
                <span id="hiddenSizeValue">3</span>
            </div>
        </div>

        <!-- 2x2 VISUALIZATION GRID -->
        <!-- Top Left: Network Design -->
        <div class="panel" style="padding:6px 6px 10px 6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; padding-bottom:0;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Network Design</h2>
                <div id="opsTableHtml" style="font-size:9px; background:#f8f9ff; border:1px solid #007bff; border-radius:3px; padding:2px 6px;">
                    <span style="color:#28a745;">Fwd:</span><span id="opsFwdAdds">0</span>+<span id="opsFwdMuls">0</span>√ó
                    <span style="color:#dc3545; margin-left:4px;">Back:</span><span id="opsBackAdds">0</span>+<span id="opsBackMuls">0</span>√ó
                </div>
            </div>
            <div style="position:relative; display:inline-block;">
                <canvas id="networkCanvas" width="520" height="300"></canvas>
                <div id="sizeHandle" style="position:absolute; right:-18px; top:50%; transform:translateY(-50%); width:20px; height:60px; background:linear-gradient(to bottom, #007bff, #0056b3); border-radius:3px; cursor:ns-resize; display:flex; flex-direction:column; align-items:center; justify-content:space-evenly; color:white; font-size:8px; transition: transform 0.15s ease-out;" title="Drag: Width"><span>‚ñ≤</span><span style="writing-mode:vertical-rl; text-orientation:mixed; font-size:8px;">Width</span><span>‚ñº</span></div>
                <div id="layersHandle" style="position:absolute; bottom:-12px; left:50%; transform:translateX(-50%); height:18px; width:70px; background:linear-gradient(to right, #007bff, #0056b3); border-radius:3px; cursor:ew-resize; display:flex; align-items:center; justify-content:center; color:white; font-size:8px; transition: transform 0.15s ease-out;" title="Drag: Layers">‚óÄ Layers ‚ñ∂</div>
            </div>
            <span id="networkLayersDisplay" style="display:none;">1</span>
            <span id="networkSizeDisplay" style="display:none;">3</span>
            <div id="networkActivation" style="display:none;"></div>
        </div>

        <!-- Top Right: Fit Plot -->
        <div class="panel" style="padding:6px;">
            <h2 style="margin:0 0 4px 0; font-size:13px; border:none; padding:0;">Fit Plot: f(x) vs ≈∑(x)</h2>
            <div style="position:relative;">
                <canvas id="fitCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
                <div id="xMinHandle" style="position:absolute; left:40px; bottom:2px; width:24px; height:12px; background:#007bff; border-radius:2px; cursor:ew-resize; display:flex; align-items:center; justify-content:center; color:white; font-size:7px;" title="x-min">‚óÄ‚ñ∂</div>
                <div id="xMaxHandle" style="position:absolute; right:40px; bottom:2px; width:24px; height:12px; background:#007bff; border-radius:2px; cursor:ew-resize; display:flex; align-items:center; justify-content:center; color:white; font-size:7px;" title="x-max">‚óÄ‚ñ∂</div>
            </div>
            <span id="xMinDisplay" style="display:none;">-2.0</span>
            <span id="xMaxDisplay" style="display:none;">2.0</span>
            <div class="mobile-sliders" style="display:none;">
                <input type="range" id="xMinMobile" min="-5" max="0" step="0.5" value="-2"><span id="xMinMobileVal">-2</span>
                <input type="range" id="xMaxMobile" min="0" max="5" step="0.5" value="2"><span id="xMaxMobileVal">2</span>
            </div>
        </div>

        <!-- Bottom Left: Training Trace -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Training Trace</h2>
                <div style="display:flex; gap:6px; font-size:9px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:1px;"><input type="checkbox" id="traceLoss" checked>Loss</label>
                    <label style="display:flex; align-items:center; gap:1px;"><input type="checkbox" id="traceWeights" checked>Weights</label>
                    <label style="display:flex; align-items:center; gap:1px;"><input type="checkbox" id="traceLogScale">Log Scale</label>
                    <span style="color:#ccc;">|</span>
                    <label style="display:flex; align-items:center; gap:1px;"><input type="checkbox" id="traceAvgLoss" checked>Avg Loss</label>
                    <span>Window:</span><input type="range" id="avgWindowSlider" min="10" max="1000" step="10" value="100" style="width:40px;"><span id="avgWindowValue" style="color:#007bff;">100</span>
                    <span style="color:#ccc;">|</span>
                    <span>ŒîLoss:<strong id="deltaLossValue" style="color:#28a745;">‚Äî</strong></span>
                </div>
            </div>
            <div style="position:relative; width:520px; margin:0 auto;">
                <canvas id="traceCanvas" class="chart" width="520" height="360"></canvas>
                <div id="traceViewHandle" style="position:absolute; bottom:4px; left:230px; width:60px; height:14px; background:linear-gradient(to right, #007bff, #0056b3); border-radius:3px; cursor:ew-resize; display:none; align-items:center; justify-content:center; color:white; font-size:8px; opacity:0.9; z-index:10;" title="Drag left/right to zoom into early training steps (when paused)">‚óÄ Zoom ‚ñ∂</div>
            </div>
        </div>

        <!-- Bottom Right: Loss Landscape -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Loss Landscape</h2>
                <div style="display:flex; gap:3px; font-size:9px; align-items:center;">
                    <span id="weightSelectContainer" style="display:flex; gap:2px; align-items:center; opacity:0.5;" title="Click to manually select weights">
                        <select id="weightXSelect" style="font-size:8px; padding:1px; max-width:65px;"><option value="0">w‚ÇÅ</option></select>
                        <span style="font-size:8px;">vs</span>
                        <select id="weightYSelect" style="font-size:8px; padding:1px; max-width:65px;"><option value="1">w‚ÇÇ</option></select>
                    </span>
                    <button id="autoSelectBtn" style="font-size:9px; padding:1px 4px; background:#007bff; border:2px solid #007bff; color:white;" title="Auto-select interesting weights">Auto</button>
                </div>
            </div>
            <canvas id="lossCanvas" class="chart" width="520" height="360"></canvas>
            <div style="font-size:9px; color:#888; text-align:center;">üü¢&nbsp;Start &nbsp;üî¥&nbsp;Current ‚Ä¢ <span style="color:#00f;">‚ñ†</span>‚â§0.001 <span style="color:#0aa;">‚ñ†</span>0.01 <span style="color:#0a0;">‚ñ†</span>0.1 <span style="color:#aa0;">‚ñ†</span>1.0 <span style="color:#f00;">‚ñ†</span>‚â•10</div>
        </div>
    </div>
    
    <!-- EQUATIONS STRIP - spans full width -->
    <div class="panel equations-panel" style="padding:6px 10px;">
        <h2 style="margin:0 0 4px 0; font-size:13px; border:none; padding:0;">Equations & Backprop</h2>
        <div class="equations" id="equationsDiv"></div>
    </div>
</div>

<script>
    // ---------------- Config & State ----------------

    let config = {
        learningRate: 0.1,
        activation: 'relu',
        xMin: -2,
        xMax: 2,
        noise: 0,
        targetFunc: null,
        targetFuncStr: 'x^2',
        optimizer: 'sgd',
        avgWindow: 100
    };

    let network = {
        numLayers: 1,
        hiddenSize: 3,
        weights: [],
        biases: []
    };

    let grads = {
        weights: [],
        biases: []
    };

    let history = {
        steps: [],
        loss: [],
        avgLoss: [],
        weights: []
    };

    let trainingState = {
        running: false,
        animating: false,
        step: 0,
        totalAdds: 0,
        totalMuls: 0,
        lastUpdateTime: performance.now(),
        stepsSinceLastUpdate: 0,
        recentSamples: []
    };
    
    // Training trace view control - null means show all, otherwise show steps 0 to this value
    let traceViewEndStep = null;

    let gifCapture = {
        recording: false,
        gif: null,
        framesRemaining: 0
    };

    let optimizerState = {
        m: [],
        v: [],
        r: [],
        t: 0
    };

    let savedRuns = {
        A: null,
        B: null
    };

    let comparisonModeActive = false;

    function exitComparisonMode() {
        if (!comparisonModeActive) return;
        comparisonModeActive = false;
        const compareBtn = document.getElementById('compareBtn');
        if (compareBtn && savedRuns.A && savedRuns.B) {
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
            compareBtn.textContent = 'Compare A vs B';
        }
    }

    const activationFns = {
        relu: {
            fn: (z) => Math.max(0, z),
            dfn: (z) => z > 0 ? 1 : 0
        },
        tanh: {
            fn: (z) => Math.tanh(z),
            dfn: (z) => {
                const t = Math.tanh(z);
                return 1 - t * t;
            }
        },
        sigmoid: {
            fn: (z) => 1 / (1 + Math.exp(-z)),
            dfn: (z) => {
                const s = 1 / (1 + Math.exp(-z));
                return s * (1 - s);
            }
        }
    };

    // --------------- Utility Functions ---------------
    
    // Fix fuzzy text on HiDPI displays
    function setupHiDPICanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return ctx;
    }

    function gaussianNoise(mean=0, std=1) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const n = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + std * n;
    }
    
    // Generate nice round tick values for axes
    function getNiceTicks(min, max, targetCount = 5) {
        const range = max - min;
        if (range <= 0) return [min];
        
        // Find a nice step size
        const roughStep = range / targetCount;
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const normalized = roughStep / magnitude;
        
        let niceStep;
        if (normalized <= 1) niceStep = magnitude;
        else if (normalized <= 2) niceStep = 2 * magnitude;
        else if (normalized <= 5) niceStep = 5 * magnitude;
        else niceStep = 10 * magnitude;
        
        // Generate ticks
        const ticks = [];
        const start = Math.ceil(min / niceStep) * niceStep;
        for (let tick = start; tick <= max; tick += niceStep) {
            ticks.push(tick);
        }
        
        // Ensure we have at least start and end
        if (ticks.length === 0 || ticks[0] > min) ticks.unshift(Math.floor(min / niceStep) * niceStep);
        if (ticks[ticks.length - 1] < max) ticks.push(Math.ceil(max / niceStep) * niceStep);
        
        return ticks;
    }
    
    // Generate nice tick values for log scale (powers of 10)
    function getLogTicks(logMin, logMax) {
        const ticks = [];
        const startPow = Math.floor(logMin);
        const endPow = Math.ceil(logMax);
        
        for (let p = startPow; p <= endPow; p++) {
            if (p >= logMin && p <= logMax) {
                ticks.push(p);
            }
        }
        
        // If range is very small, add intermediate ticks
        if (ticks.length < 3 && (logMax - logMin) < 2) {
            const midTicks = [];
            for (let p = startPow; p <= endPow; p++) {
                midTicks.push(p);
                // Add 0.5 log step (sqrt(10) ‚âà 3.16x)
                if (p + 0.5 <= logMax && p + 0.5 >= logMin) {
                    midTicks.push(p + 0.5);
                }
            }
            return midTicks.filter(t => t >= logMin && t <= logMax);
        }
        
        return ticks;
    }

    function createCompositeCanvas() {
        // Get all three canvases
        const networkCanvas = document.getElementById('networkCanvas');
        const fitCanvas = document.getElementById('fitCanvas');
        const traceCanvas = document.getElementById('traceCanvas');
        
        // Create composite canvas: network on left, fit and trace stacked on right
        const padding = 10;
        const leftWidth = networkCanvas.width;
        const rightWidth = Math.max(fitCanvas.width, traceCanvas.width);
        const totalWidth = leftWidth + rightWidth + padding * 3;
        const totalHeight = Math.max(networkCanvas.height, fitCanvas.height + traceCanvas.height + padding) + padding * 2;
        
        const composite = document.createElement('canvas');
        composite.width = totalWidth;
        composite.height = totalHeight;
        const ctx = composite.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, totalWidth, totalHeight);
        
        // Draw network canvas (left side)
        ctx.drawImage(networkCanvas, padding, padding);
        
        // Draw fit canvas (top right)
        ctx.drawImage(fitCanvas, leftWidth + padding * 2, padding);
        
        // Draw trace canvas (bottom right)
        ctx.drawImage(traceCanvas, leftWidth + padding * 2, fitCanvas.height + padding * 2);
        
        // Add title
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Network', padding, padding - 2);
        ctx.fillText('Fit: f(x) vs ≈∑(x)', leftWidth + padding * 2, padding - 2);
        ctx.fillText('Training Trace', leftWidth + padding * 2, fitCanvas.height + padding * 2 - 2);
        
        return composite;
    }
    
    // Check if GIF capture with workers is available
    function canUseGifWorkers() {
        // Workers don't work from file:// protocol
        return window.location.protocol !== 'file:';
    }
    
    // Fallback: capture a single screenshot as PNG
    function captureScreenshot() {
        const composite = createCompositeCanvas();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        
        composite.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `learncurve_${timestamp}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }
    
    // Adaptive GIF capture - scans training to find interesting convergence region
    function startGifCapture() {
        if (gifCapture.recording) return;
        
        // Check if we can use web workers (required for GIF.js)
        if (!canUseGifWorkers()) {
            const useScreenshot = confirm(
                'Animated GIF capture requires running from a web server.\n\n' +
                'Options:\n' +
                '‚Ä¢ Click OK to download a PNG screenshot instead\n' +
                '‚Ä¢ Click Cancel, then run: python3 -m http.server 8000\n' +
                '  and open http://localhost:8000/index.html for GIF capture'
            );
            if (useScreenshot) {
                captureScreenshot();
            }
            return;
        }
        
        
        trainingState.running = false;
        document.getElementById('runBtn').textContent = 'Run';
        
        // Show status
        const gifBtn = document.getElementById('gifBtn');
        const originalText = gifBtn.textContent;
        gifBtn.textContent = 'Scanning...';
        gifBtn.disabled = true;
        
        // Phase 1: Scan training to find convergence
        setTimeout(() => {
            const scanResult = scanForConvergence();
            gifBtn.textContent = 'Recording...';
            
            // Phase 2: Reset and record with adaptive keyframes
            reset();
            
            setTimeout(() => {
                startAdaptiveCapture(scanResult, () => {
                    gifBtn.textContent = originalText;
                    gifBtn.disabled = false;
                });
            }, 100);
        }, 50);
    }
    
    function scanForConvergence() {
        // Save current state
        const savedNetwork = JSON.parse(JSON.stringify(network));
        const savedHistory = JSON.parse(JSON.stringify(history));
        const savedTrainingState = JSON.parse(JSON.stringify(trainingState));
        
        // Reset for scan
        reset();
        
        const losses = [];
        const maxScanSteps = 500;
        const targetFrames = 80;
        
        // Run silent training to collect loss data
        for (let i = 0; i < maxScanSteps; i++) {
            trainStep();
            losses.push(history.loss[history.loss.length - 1]);
            
            // Check for early convergence
            if (losses.length > 50) {
                const recent = losses.slice(-30);
                const variance = computeVariance(recent);
                const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                if (variance < 0.0001 * mean * mean) {
                    break; // Converged early
                }
            }
        }
        
        // Analyze loss curve to find interesting region
        const L0 = losses[0];
        const Lmin = Math.min(...losses);
        const totalDrop = L0 - Lmin;
        
        // Find key milestones
        let start5pct = 0, start50pct = 0, end90pct = losses.length - 1, convergencePoint = losses.length - 1;
        
        for (let i = 0; i < losses.length; i++) {
            const drop = L0 - losses[i];
            if (start5pct === 0 && drop >= 0.05 * totalDrop) start5pct = i;
            if (start50pct === 0 && drop >= 0.50 * totalDrop) start50pct = i;
            if (drop >= 0.90 * totalDrop) { end90pct = i; break; }
        }
        
        // Detect convergence (low variance)
        for (let i = 50; i < losses.length; i++) {
            const window = losses.slice(i - 30, i);
            const variance = computeVariance(window);
            const mean = window.reduce((a, b) => a + b, 0) / window.length;
            if (variance < 0.0001 * mean * mean) {
                convergencePoint = i;
                break;
            }
        }
        
        // Compute |dL/dt| for each step
        const derivatives = losses.map((L, i) => 
            i === 0 ? 0 : Math.abs(losses[i-1] - L)
        );
        
        // Select keyframes adaptively
        const keyframes = selectKeyframes(losses, derivatives, {
            start5pct, start50pct, end90pct, convergencePoint
        }, targetFrames);
        
        // Restore original state
        network = savedNetwork;
        history = savedHistory;
        trainingState = savedTrainingState;
        
        return { losses, keyframes, convergencePoint };
    }
    
    function computeVariance(arr) {
        if (arr.length === 0) return 0;
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
    }
    
    function selectKeyframes(losses, derivatives, milestones, targetFrames) {
        const frames = new Set([0]); // Always include first
        
        // Always include milestone frames
        frames.add(milestones.start5pct);
        frames.add(milestones.start50pct);
        frames.add(milestones.end90pct);
        frames.add(Math.min(milestones.convergencePoint, losses.length - 1));
        frames.add(losses.length - 1); // Always include last
        
        // Score each step by "interestingness" (derivative magnitude)
        const maxDeriv = Math.max(...derivatives.slice(1)) || 1;
        const scores = derivatives.map(d => d / maxDeriv);
        
        // Add frames based on derivative (more change = more frames)
        const numSegments = 20;
        const segmentSize = Math.ceil(losses.length / numSegments);
        
        for (let seg = 0; seg < numSegments; seg++) {
            const segStart = seg * segmentSize;
            const segEnd = Math.min((seg + 1) * segmentSize, losses.length);
            
            // Find max derivative in this segment
            let maxIdx = segStart;
            let maxScore = 0;
            for (let i = segStart; i < segEnd; i++) {
                if (scores[i] > maxScore) {
                    maxScore = scores[i];
                    maxIdx = i;
                }
            }
            
            // Add more frames for high-derivative segments
            if (maxScore > 0.1) {
                frames.add(maxIdx);
                // Add extra frames around high-action areas
                if (maxScore > 0.3 && seg < numSegments - 1) {
                    frames.add(Math.min(maxIdx + 2, losses.length - 1));
                }
            } else {
                // Low derivative - just sample the segment sparsely
                frames.add(Math.floor((segStart + segEnd) / 2));
            }
        }
        
        // Convert to sorted array and limit to targetFrames
        let result = [...frames].sort((a, b) => a - b);
        
        // If we have too many, subsample evenly
        while (result.length > targetFrames) {
            // Remove every other frame except first/last
            const newResult = [result[0]];
            for (let i = 2; i < result.length - 1; i += 2) {
                newResult.push(result[i]);
            }
            newResult.push(result[result.length - 1]);
            result = newResult;
        }
        
        return result;
    }
    
    function startAdaptiveCapture(scanResult, onComplete) {
        const { keyframes } = scanResult;
        
        // Reset to fresh state with same random seed
        reset();
        
        const composite = createCompositeCanvas();
        
        try {
            gifCapture.gif = new GIF({
                workers: 2,
                quality: 10,
                width: composite.width,
                height: composite.height,
                workerScript: 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js'
            });
        } catch (e) {
            console.error('Failed to create GIF:', e);
            alert('GIF capture failed: ' + e.message);
            if (onComplete) onComplete();
            return;
        }
        
        gifCapture.recording = true;
        gifCapture.keyframes = keyframes;
        gifCapture.keyframeIndex = 0;
        gifCapture.currentStep = 0;
        
        gifCapture.gif.on('finished', function (blob) {
            // Clear timeout since we finished normally
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `convergence_${timestamp}.gif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            gifCapture.recording = false;
            if (onComplete) onComplete();
        });
        
        // Timeout safety - force complete after 30 seconds
        gifCapture.timeout = setTimeout(() => {
            if (gifCapture.recording) {
                console.warn('GIF capture timeout - forcing completion');
                gifCapture.recording = false;
                gifCapture.gif = null;
                if (onComplete) onComplete();
            }
        }, 30000);
        
        adaptiveCaptureLoop();
    }
    
    function adaptiveCaptureLoop() {
        if (!gifCapture.recording || gifCapture.keyframeIndex >= gifCapture.keyframes.length) {
            if (gifCapture.gif) {
                gifCapture.gif.render();
            }
            return;
        }
        
        const targetStep = gifCapture.keyframes[gifCapture.keyframeIndex];
        
        // Train until we reach the target step (with safety limit)
        let safetyCounter = 0;
        const maxIterations = 10000;
        while (gifCapture.currentStep < targetStep && safetyCounter < maxIterations) {
            const prevStep = trainingState.step;
            trainStep();
            gifCapture.currentStep++;
            safetyCounter++;
            
            // If trainStep didn't actually train (NaN or other issue), break out
            if (trainingState.step === prevStep || !Number.isFinite(history.loss[history.loss.length - 1])) {
                console.warn('GIF capture: training issue detected, finishing early');
                gifCapture.keyframeIndex = gifCapture.keyframes.length; // Force finish
                break;
            }
        }
        
        updateUI();
        
        // Calculate delay based on next keyframe distance (variable speed)
        let delay = 100;
        if (gifCapture.keyframeIndex < gifCapture.keyframes.length - 1) {
            const gap = gifCapture.keyframes[gifCapture.keyframeIndex + 1] - targetStep;
            // Bigger gaps = less action = shorter delay (faster playback)
            delay = gap > 20 ? 50 : gap > 5 ? 100 : 150;
        } else {
            delay = 200; // Pause at end
        }
        
        // Capture frame
        const composite = createCompositeCanvas();
        gifCapture.gif.addFrame(composite, {copy: true, delay});
        
        gifCapture.keyframeIndex++;
        setTimeout(adaptiveCaptureLoop, 30);
    }

    function initializeOptimizerState() {
        optimizerState.m = [];
        optimizerState.v = [];
        optimizerState.r = [];
        optimizerState.t = 0;

        // For each weight matrix/vector
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            if (Array.isArray(w[0])) {
                optimizerState.m.push(w.map(row => row.map(() => 0)));
                optimizerState.v.push(w.map(row => row.map(() => 0)));
                optimizerState.r.push(w.map(row => row.map(() => 0)));
            } else {
                optimizerState.m.push(w.map(() => 0));
                optimizerState.v.push(w.map(() => 0));
                optimizerState.r.push(w.map(() => 0));
            }
        }

        // Biases
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            optimizerState.m.push(b.map(() => 0));
            optimizerState.v.push(b.map(() => 0));
            optimizerState.r.push(b.map(() => 0));
        }
    }
function updateParameters() {
    const lr = config.learningRate;
    const beta1 = 0.9;
    const beta2 = 0.999;
    const epsilon = 1e-8;
    const rho = 0.9;
    const momentumCoeff = 0.9;
    const gradClip = 5.0;  // Gradient clipping threshold

    // Clip gradients to prevent explosion
    function clipGrad(g) {
        if (!Number.isFinite(g)) return 0;
        return Math.max(-gradClip, Math.min(gradClip, g));
    }
    
    // Apply gradient clipping to all gradients
    for (let l = 0; l < grads.weights.length; l++) {
        const gw = grads.weights[l];
        if (Array.isArray(gw[0])) {
            for (let i = 0; i < gw.length; i++) {
                for (let j = 0; j < gw[i].length; j++) {
                    gw[i][j] = clipGrad(gw[i][j]);
                }
            }
        } else {
            for (let i = 0; i < gw.length; i++) {
                gw[i] = clipGrad(gw[i]);
            }
        }
    }
    for (let l = 0; l < grads.biases.length; l++) {
        const gb = grads.biases[l];
        for (let i = 0; i < gb.length; i++) {
            gb[i] = clipGrad(gb[i]);
        }
    }

    let idx = 0;

    // Plain SGD
    if (config.optimizer === 'sgd') {
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            const gw = grads.weights[l];
            if (Array.isArray(w[0])) {
                // matrix
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        w[i][j] -= lr * gw[i][j];
                    }
                }
            } else {
                // vector
                for (let i = 0; i < w.length; i++) {
                    w[i] -= lr * gw[i];
                }
            }
        }
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            const gb = grads.biases[l];
            for (let i = 0; i < b.length; i++) {
                b[i] -= lr * gb[i];
            }
        }
        return;
    }

    // Momentum / RMSProp / Adam
    optimizerState.t += 1;

    // Weights
    for (let l = 0; l < network.weights.length; l++) {
        const w = network.weights[l];
        const gw = grads.weights[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;

            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        v[i][j] = vCoeff * v[i][j] + oneMinus * gw[i][j];
                        w[i][j] -= lr * v[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    v[i] = vCoeff * v[i] + oneMinus * gw[i];
                    w[i] -= lr * v[i];
                }
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        r[i][j] = rho * r[i][j] + oneMinusRho * gw[i][j] * gw[i][j];
                        const step = lr / Math.sqrt(r[i][j] + epsilon);
                        w[i][j] -= step * gw[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    r[i] = rho * r[i] + oneMinusRho * gw[i] * gw[i];
                    const step = lr / Math.sqrt(r[i] + epsilon);
                    w[i] -= step * gw[i];
                }
            }
        } else if (config.optimizer === 'adam') {
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        m[i][j] = beta1 * m[i][j] + (1 - beta1) * gw[i][j];
                        v[i][j] = beta2 * v[i][j] + (1 - beta2) * gw[i][j] * gw[i][j];
                        const mHat = m[i][j] / (1 - Math.pow(beta1, optimizerState.t));
                        const vHat = v[i][j] / (1 - Math.pow(beta2, optimizerState.t));
                        w[i][j] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    m[i] = beta1 * m[i] + (1 - beta1) * gw[i];
                    v[i] = beta2 * v[i] + (1 - beta2) * gw[i] * gw[i];
                    const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                    const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                    w[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                }
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }

    // Biases
    for (let l = 0; l < network.biases.length; l++) {
        const b = network.biases[l];
        const gb = grads.biases[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;
            for (let i = 0; i < b.length; i++) {
                v[i] = vCoeff * v[i] + oneMinus * gb[i];
                b[i] -= lr * v[i];
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            for (let i = 0; i < b.length; i++) {
                r[i] = rho * r[i] + oneMinusRho * gb[i] * gb[i];
                const step = lr / Math.sqrt(r[i] + epsilon);
                b[i] -= step * gb[i];
            }
        } else if (config.optimizer === 'adam') {
            for (let i = 0; i < b.length; i++) {
                m[i] = beta1 * m[i] + (1 - beta1) * gb[i];
                v[i] = beta2 * v[i] + (1 - beta2) * gb[i] * gb[i];
                const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                b[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }
}

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    function makeRunLabel(slot) {
        const optName = config.optimizer === 'sgd' ? 'Simple' : config.optimizer;
        return `${slot}: ${config.activation}, L=${network.numLayers}, H=${network.hiddenSize}, Œ∑=${config.learningRate.toFixed(3)}, ${optName}`;
    }

    function saveRun(slot) {
        if (history.steps.length < 2) {
            alert('Train the network for a few steps before saving a run.');
            return;
        }

        const run = {
            label: makeRunLabel(slot),
            steps: history.steps.slice(),
            loss: history.loss.slice(),
            avgLoss: history.avgLoss.slice(),
            network: deepClone(network),
            config: {
                activation: config.activation,
                learningRate: config.learningRate,
                numLayers: network.numLayers,
                hiddenSize: network.hiddenSize,
                targetFuncStr: config.targetFuncStr,
                optimizer: config.optimizer
            },
            // Save loss landscape trail for comparison visualization
            lossSurfaceTrail: lossSurfaceTrail.slice(),
            lossSurfaceWeightIndices: lossSurfaceWeightIndices.slice()
        };

        savedRuns[slot] = run;

        const labelEl = document.getElementById(slot === 'A' ? 'runALabel' : 'runBLabel');
        if (labelEl) {
            labelEl.textContent = run.label;
        }

        // Style the save button to show it has saved data (subtle indicator - thicker border)
        const saveBtn = document.getElementById(slot === 'A' ? 'saveRunA' : 'saveRunB');
        if (saveBtn) {
            saveBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:8px; border:2px solid #28a745; box-shadow:0 0 3px rgba(40,167,69,0.3);';
        }

        // Enable and style compare button when both A and B are saved
        const compareBtn = document.getElementById('compareBtn');
        if (savedRuns.A && savedRuns.B) {
            compareBtn.disabled = false;
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
        }

        updateUI();
    }

    function forwardWithNetwork(x, net, activationName) {
        const actFn = activationFns[activationName].fn;
        const h = net.hiddenSize;
        const numLayers = net.numLayers;

        let activations = [];
        let zValues = [];

        activations.push([x]);

        // Hidden layer 1
        let z = new Array(h);
        let a = new Array(h);
        const w0 = net.weights[0]; // shape [h, 1] represented as [h]
        const b0 = net.biases[0];  // shape [h]
        for (let i = 0; i < h; i++) {
            let zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = actFn(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let layer = 1; layer < numLayers; layer++) {
            const prev = activations[activations.length - 1];
            const w = net.weights[layer];  // shape [h, h]
            const b = net.biases[layer];   // shape [h]

            z = new Array(h);
            a = new Array(h);

            for (let i = 0; i < h; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < h; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = actFn(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output layer
        const lastLayer = activations[activations.length - 1];
        const wOut = net.weights[net.weights.length - 1];       // shape [h]
        const bOut = net.biases[net.biases.length - 1][0];      // shape [1]
        let yhat = bOut;
        for (let i = 0; i < h; i++) {
            yhat += wOut[i] * lastLayer[i];
        }

        return yhat;
    }

    // -------------- Network, Target & Ops --------------

    function compileTargetFunc() {
        const input = document.getElementById('targetFuncInput');
        let originalStr = input.value.trim() || 'x*x';
        
        // Make case-insensitive by converting to lowercase for function matching
        let fStr = originalStr;
        
        // Allow ^ as power operator (convert to **)
        fStr = fStr.replace(/\^/g, '**');
        
        // Convert shorthand functions to Math.* (case-insensitive)
        // Order matters - longer names first
        fStr = fStr.replace(/\blog10\b/gi, 'Math.log10');  // log base 10
        fStr = fStr.replace(/\bsqrt\b/gi, 'Math.sqrt');
        fStr = fStr.replace(/\babs\b/gi, 'Math.abs');
        fStr = fStr.replace(/\bsin\b/gi, 'Math.sin');
        fStr = fStr.replace(/\bcos\b/gi, 'Math.cos');
        fStr = fStr.replace(/\btan\b/gi, 'Math.tan');
        fStr = fStr.replace(/\bexp\b/gi, 'Math.exp');      // e^x (natural exponential)
        fStr = fStr.replace(/\blog\b/gi, 'Math.log');      // natural log (ln)
        fStr = fStr.replace(/\bfloor\b/gi, 'Math.floor');
        fStr = fStr.replace(/\bceil\b/gi, 'Math.ceil');
        fStr = fStr.replace(/\bround\b/gi, 'Math.round');
        fStr = fStr.replace(/\bsign\b/gi, 'Math.sign');
        fStr = fStr.replace(/\bmin\b/gi, 'Math.min');
        fStr = fStr.replace(/\bmax\b/gi, 'Math.max');
        fStr = fStr.replace(/\bpow\b/gi, 'Math.pow');
        
        // Convert constants (case-insensitive)
        fStr = fStr.replace(/\bPI\b/gi, 'Math.PI');        // œÄ ‚âà 3.14159
        fStr = fStr.replace(/\bE\b/gi, 'Math.E');          // e ‚âà 2.71828
        
        // Make x case-insensitive (X -> x)
        fStr = fStr.replace(/\bX\b/g, 'x');

        // Get or create error display elements
        let errorSpan = document.getElementById('targetFuncError');
        if (!errorSpan) {
            errorSpan = document.createElement('span');
            errorSpan.id = 'targetFuncError';
            errorSpan.style.cssText = 'color:#dc3545; font-size:11px; margin-left:8px; display:block;';
            input.parentNode.appendChild(errorSpan);
        }

        try {
            const fn = new Function('x', 'return ' + fStr + ';');
            // Test it at a few points
            fn(0);
            fn(1);
            fn(-1);
            config.targetFunc = fn;
            config.targetFuncStr = fStr;
            input.style.borderColor = '#28a745';  // Green border for valid
            input.style.backgroundColor = '#fff';
            errorSpan.textContent = '';
            errorSpan.innerHTML = '';
        } catch (e) {
            // Highlight input in red but DON'T revert - let user continue editing
            input.style.borderColor = '#dc3545';
            input.style.backgroundColor = '#fff0f0';
            
            // Try to extract position info from error message
            const errorMsg = e.message;
            let highlightedError = errorMsg;
            
            // Try to find problematic tokens
            const unexpectedMatch = errorMsg.match(/Unexpected token '?([^']*)'?/i);
            const identifierMatch = errorMsg.match(/(\w+) is not defined/i);
            
            if (unexpectedMatch && unexpectedMatch[1]) {
                const badToken = unexpectedMatch[1];
                const pos = originalStr.indexOf(badToken);
                if (pos >= 0) {
                    // Show the input with the bad part highlighted
                    const before = originalStr.substring(0, pos);
                    const bad = originalStr.substring(pos, pos + badToken.length);
                    const after = originalStr.substring(pos + badToken.length);
                    highlightedError = `Error at "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>": ${errorMsg}`;
                }
            } else if (identifierMatch && identifierMatch[1]) {
                const badId = identifierMatch[1];
                // Find case-insensitive match in original
                const regex = new RegExp('\\b' + badId + '\\b', 'i');
                const match = originalStr.match(regex);
                if (match) {
                    const pos = originalStr.search(regex);
                    const before = originalStr.substring(0, pos);
                    const bad = match[0];
                    const after = originalStr.substring(pos + bad.length);
                    highlightedError = `Unknown: "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>" - did you mean a function like sin, cos, exp?`;
                }
            }
            
            errorSpan.innerHTML = '‚ö† ' + highlightedError;
            // Keep the previous valid function running - don't change config.targetFunc
        }
    }

    function initializeNetwork() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        network.weights = [];
        network.biases = [];
        grads.weights = [];
        grads.biases = [];

        function randnScaled(scale) {
            return scale * gaussianNoise(0, 1);
        }

        // Input -> Layer 1: weights shape [H, 1]
        const w0 = new Array(H);
        const b0 = new Array(H);
        const scale0 = 1 / Math.sqrt(1);
        for (let i = 0; i < H; i++) {
            w0[i] = randnScaled(scale0);
            b0[i] = 0;
        }
        network.weights.push(w0);
        network.biases.push(b0);
        grads.weights.push(new Array(H).fill(0));
        grads.biases.push(new Array(H).fill(0));

        // Hidden ‚Üí Hidden
        for (let l = 1; l < L; l++) {
            const w = new Array(H);
            const b = new Array(H);
            const scale = 1 / Math.sqrt(H);
            for (let i = 0; i < H; i++) {
                w[i] = new Array(H);
                for (let j = 0; j < H; j++) {
                    w[i][j] = randnScaled(scale);
                }
                b[i] = 0;
            }
            network.weights.push(w);
            network.biases.push(b);

            const gw = new Array(H);
            for (let i = 0; i < H; i++) {
                gw[i] = new Array(H).fill(0);
            }
            grads.weights.push(gw);
            grads.biases.push(new Array(H).fill(0));
        }

        // Output layer: weights [H], bias [1]
        const wOut = new Array(H);
        const bOut = [0];
        const scaleOut = 1 / Math.sqrt(H);
        for (let i = 0; i < H; i++) {
            wOut[i] = randnScaled(scaleOut);
        }
        network.weights.push(wOut);
        network.biases.push(bOut);

        grads.weights.push(new Array(H).fill(0));
        grads.biases.push([0]);

        initializeOptimizerState();
        computeOpsPerStep();
    }

    function computeOpsPerStep() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        let fwdAdds = 0, fwdMuls = 0;
        let backAdds = 0, backMuls = 0;
        let lossAdds = 0, lossMuls = 0;

        // Forward ops: each neuron does sum of inputs + bias + activation
        // Layer 1: H neurons, each 1 multiply + 1 add + (bias add)
        fwdMuls += H;  // w*x
        fwdAdds += H;  // plus bias

        // Hidden layers
        for (let l = 1; l < L; l++) {
            // each H neuron: H multiplies + H adds + 1 add for bias
            fwdMuls += H * H;
            fwdAdds += H * (H + 1);
        }

        // Output layer: H multiplies + H adds + 1 bias
        fwdMuls += H;
        fwdAdds += H + 1;

        // Loss = 1/2 (yhat - y)^2 -> 1 sub, 1 mul
        lossAdds += 1;
        lossMuls += 1;

        // Backward (rough estimate, symmetrical to forward)
        backMuls += fwdMuls * 2;
        backAdds += fwdAdds * 2;

        // Ops are now drawn on the Network Design canvas
        // Keep these for backwards compatibility if elements exist
        const setIfExists = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
        setIfExists('opsFwdAdd', fwdAdds);
        setIfExists('opsFwdMul', fwdMuls);
        setIfExists('opsLossAdd', lossAdds);
        setIfExists('opsLossMul', lossMuls);
        setIfExists('opsBackAdd', backAdds);
        setIfExists('opsBackMul', backMuls);
        setIfExists('opsTotAdd', fwdAdds + lossAdds + backAdds);
        setIfExists('opsTotMul', fwdMuls + lossMuls + backMuls);

        return { fwdAdds, fwdMuls, lossAdds, lossMuls, backAdds, backMuls };
    }

    function sampleTrainingPoint() {
        const x = config.xMin + Math.random() * (config.xMax - config.xMin);
        let y;
        try {
            y = config.targetFunc(x);
        } catch {
            y = 0;
        }
        if (config.noise > 0) {
            y += gaussianNoise(0, config.noise);
        }
        return { x, y };
    }

    function forward(x) {
        const act = activationFns[config.activation].fn;
        const L = network.numLayers;
        const H = network.hiddenSize;

        const activations = [];
        const zValues = [];

        activations.push([x]);

        // Layer 1
        const w0 = network.weights[0];   // [H]
        const b0 = network.biases[0];    // [H]
        let z = new Array(H);
        let a = new Array(H);
        for (let i = 0; i < H; i++) {
            const zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = act(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let l = 1; l < L; l++) {
            const w = network.weights[l];  // [H,H]
            const b = network.biases[l];   // [H]
            const prev = activations[activations.length - 1];

            z = new Array(H);
            a = new Array(H);
            for (let i = 0; i < H; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < H; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = act(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output
        const last = activations[activations.length - 1];
        const wOut = network.weights[network.weights.length - 1]; // [H]
        const bOut = network.biases[network.biases.length - 1][0];
        let yhat = bOut;
        for (let i = 0; i < H; i++) {
            yhat += wOut[i] * last[i];
        }

        return { yhat, activations, zValues };
    }

    function backward(x, y, forwardResult) {
        const { yhat, activations, zValues } = forwardResult;
        const H = network.hiddenSize;
        const L = network.numLayers;
        const actPrime = activationFns[config.activation].dfn;

        const error = yhat - y;
        const loss = 0.5 * error * error;

        // Initialize grads
        for (let l = 0; l < grads.weights.length; l++) {
            if (Array.isArray(grads.weights[l])) {
                if (Array.isArray(grads.weights[l][0])) {
                    for (let i = 0; i < grads.weights[l].length; i++) {
                        grads.weights[l][i].fill(0);
                    }
                } else {
                    grads.weights[l].fill(0);
                }
            }
            grads.biases[l].fill(0);
        }

        // Output layer
        const deltaOut = error;
        const hL = activations[activations.length - 1];

        for (let i = 0; i < H; i++) {
            grads.weights[grads.weights.length - 1][i] = deltaOut * hL[i];
        }
        grads.biases[grads.biases.length - 1][0] = deltaOut;

        let deltaNext = new Array(H);
        for (let i = 0; i < H; i++) {
            deltaNext[i] = network.weights[network.weights.length - 1][i] * deltaOut;
        }

        const deltas = new Array(L);
        for (let l = L - 1; l >= 0; l--) {
            const z = zValues[l];
            const delta = new Array(H);

            for (let i = 0; i < H; i++) {
                delta[i] = deltaNext[i] * actPrime(z[i]);
            }
            deltas[l] = delta;

            // Get input to this layer: for l=0 it's x, otherwise it's activations[l-1]
            const gW = grads.weights[l];
            const gB = grads.biases[l];

            if (l === 0) {
                // First layer: input is x (scalar)
                for (let i = 0; i < H; i++) {
                    gW[i] = delta[i] * x;
                    gB[i] = delta[i];
                }
            } else {
                // Hidden layers: input is previous layer's activations
                const prev = activations[l - 1];
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        gW[i][j] = delta[i] * prev[j];
                    }
                    gB[i] = delta[i];
                }
            }

            if (l > 0) {
                const w = network.weights[l];
                const deltaPrev = new Array(H).fill(0);
                for (let i = 0; i < H; i++) {
                    for (let j = 0; j < H; j++) {
                        deltaPrev[j] += w[i][j] * delta[i];
                    }
                }
                deltaNext = deltaPrev;
            }
        }

        return loss;
    }

    // --------------- Training Loop ------------------

    function trainStep() {
        trainingState.stepsSinceLastUpdate++;
        trainingState.step++;

        const sample = sampleTrainingPoint();
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);

        // Check for NaN - if detected, stop training and warn
        if (!Number.isFinite(loss) || !Number.isFinite(fwd.yhat)) {
            console.warn('NaN detected in training - stopping. Try reducing learning rate or resetting.');
            trainingState.running = false;
            return;
        }

        updateParameters();

        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);

        const window = config.avgWindow;
        let sum = 0;
        let count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < window; i--, count++) {
            sum += history.loss[i];
        }
        // Only show meaningful average after we have at least 10 data points
        const minPointsForAvg = 10;
        if (history.loss.length >= minPointsForAvg) {
            history.avgLoss.push(sum / count);
        } else {
            history.avgLoss.push(null);  // Will be skipped when drawing
        }

        const maxSamples = 500;
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > maxSamples) {
            trainingState.recentSamples.shift();
        }

        // Accumulate actual ops count
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        // Update loss surface trail - adaptive sampling for full history
        // Record more frequently at start, less frequently as training progresses
        const trailInterval = trainingState.step < 100 ? 2 : 
                             trainingState.step < 1000 ? 5 : 
                             trainingState.step < 5000 ? 10 : 20;
        if (trainingState.step % trailInterval === 0 && lossSurfaceCache) {
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            lossSurfaceTrail.push({ x: wx, y: wy });
            // No limit - keep full history for complete path visualization
        }
        
        // Auto-refresh loss surface every N steps (if cache exists)
        if (lossSurfaceAutoUpdate && lossSurfaceCache && trainingState.step % lossSurfaceUpdateInterval === 0) {
            // Check if current weights are outside the view - if so, recompute with expanded bounds
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const { minX, maxX, minY, maxY } = lossSurfaceCache;
            const margin = 0.1;  // 10% margin before triggering recompute
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            
            if (wx < minX + rangeX * margin || wx > maxX - rangeX * margin ||
                wy < minY + rangeY * margin || wy > maxY - rangeY * margin) {
                // Weights near edge or outside - recompute with expanded view
                computeLossSurface();
            }
            drawLossSurface();
        }
    }

    function runLoop() {
        if (!trainingState.running) return;

        const now = performance.now();
        const stepsPerFrame = 10;
        for (let i = 0; i < stepsPerFrame; i++) {
            trainStep();
        }

        const elapsed = now - trainingState.lastUpdateTime;
        if (elapsed > 0) {
            const stepsPerSec = (stepsPerFrame * 1000) / elapsed;
            document.getElementById('stepsPerSec').textContent = stepsPerSec.toFixed(0);
        }

        trainingState.lastUpdateTime = now;

        updateUI();

        // Auto-pause if no improvement in last 1000 steps
        if (shouldAutoPause()) {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            console.log('Auto-paused: no improvement in last 1000 steps');
            return;
        }

        if (trainingState.running) {
            requestAnimationFrame(runLoop);
        }
    }

    function reset() {
        trainingState.running = false;
        trainingState.animating = false;
        trainingState.step = 0;
        trainingState.totalAdds = 0;
        trainingState.totalMuls = 0;
        trainingState.lastUpdateTime = performance.now();
        trainingState.stepsSinceLastUpdate = 0;
        trainingState.recentSamples = [];
        
        // Stop any ongoing GIF recording
        if (gifCapture.recording || gifCapture.timeout) {
            gifCapture.recording = false;
            gifCapture.gif = null;
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const gifBtn = document.getElementById('gifBtn');
            if (gifBtn) {
                gifBtn.textContent = 'Capture GIF';
                gifBtn.disabled = false;
            }
        }

        history.steps = [];
        history.loss = [];
        history.avgLoss = [];
        history.weights = [];

        // Exit comparison mode but DON'T clear saved runs - allow A/B comparison across different configs
        exitComparisonMode();

        compileTargetFunc();
        initializeNetwork();
        
        // Repopulate weight selectors and recompute loss surface
        populateWeightSelectors();
        lossSurfaceCache = null;
        lossSurfaceTrail = [];  // Clear optimization trail
        
        // Recompute loss surface after reset
        if (lossLandscapeAutoMode) {
            autoSelectInterestingWeights();
        }
        computeLossSurface();
        
        // Record starting position for trail
        lossSurfaceStartPosition = {
            x: getWeightByIndex(lossSurfaceWeightIndices[0]),
            y: getWeightByIndex(lossSurfaceWeightIndices[1])
        };
        lossSurfaceTrail = [lossSurfaceStartPosition];

        const sample = sampleTrainingPoint();
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);
        history.steps.push(0);
        history.loss.push(loss);
        history.avgLoss.push(null);  // Don't show average until we have 10 points
        
        // Record initial weights
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);

        updateUI();
    }

    // --------------- Drawing -----------------------

    function drawNetwork(animState = null) {
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        
        ctx.clearRect(0, 0, w, h);
        
        const numLayers = network.numLayers;
        const hiddenSize = network.hiddenSize;
        
        // Animation state
        const isAnimating = animState !== null;
        const animPhase = animState?.phase;
        const animLayer = animState?.layer;
        
        // Layout calculations - input/output gaps are 50% of hidden layer spacing
        const marginLeft = 50;   // Increased for weight labels
        const marginRight = 80;  // Larger to fit y-hat node and weight labels
        const usableWidth = w - marginLeft - marginRight;
        
        // Calculate spacing: input-to-hidden and hidden-to-output are 0.5x the hidden-to-hidden spacing
        // Total segments: 0.5 + (numLayers-1) + 0.5 = numLayers for numLayers >= 1
        // For 1 hidden layer: 0.5 + 0.5 = 1 segment
        // For 2 hidden layers: 0.5 + 1 + 0.5 = 2 segments
        // For 3 hidden layers: 0.5 + 2 + 0.5 = 3 segments
        const totalSegments = numLayers;
        const hiddenLayerSpacing = usableWidth / totalSegments;
        const inputOutputGap = hiddenLayerSpacing * 0.5;  // 50% of hidden layer spacing
        
        const nodeRadius = 20;
        const fontSize = 13;
        const smallFont = 10;
        const weightFont = 9;  // Smaller font for weights
        
        // Calculate positions for each layer
        const layers = [];
        
        // Input layer - at left margin
        layers.push({x: marginLeft, nodes: [{y: h/2}]});
        
        // Hidden layers - spread across the middle
        const hiddenStartX = marginLeft + inputOutputGap;
        for (let l = 0; l < numLayers; l++) {
            const x = hiddenStartX + hiddenLayerSpacing * l;
            const nodes = [];
            const spacing = Math.min(70, (h - 80) / (hiddenSize - 1 || 1));
            const startY = h/2 - (hiddenSize - 1) * spacing / 2;
            for (let i = 0; i < hiddenSize; i++) {
                nodes.push({y: startY + i * spacing});
            }
            layers.push({x, nodes});
        }
        
        // Output layer - at right margin
        layers.push({x: w - marginRight, nodes: [{y: h/2}]});
        
        // Draw connections with weights
        ctx.font = `${weightFont}px sans-serif`;
        ctx.textAlign = 'center';
        
        // Helper to compute flat weight index for loss landscape highlighting
        function getWeightFlatIndex(layerIdx, fromIdx, toIdx) {
            let idx = 0;
            const H = hiddenSize;
            // Input to first hidden
            if (layerIdx === 0) return toIdx;
            idx += H;
            // Hidden to hidden
            for (let l = 1; l < layerIdx; l++) {
                idx += H * H;
            }
            if (layerIdx < numLayers) {
                return idx + fromIdx * H + toIdx;
            }
            idx += (numLayers - 1) * H * H;
            // Output layer
            return idx + fromIdx;
        }
        
        for (let l = 0; l < layers.length - 1; l++) {
            const fromLayer = layers[l];
            const toLayer = layers[l + 1];
            
            // Highlight during forward animation
            const shouldHighlight = isAnimating && animPhase === 'forward' && animLayer === l + 1;
            
            // Count total connections for offset calculation
            const totalConnections = fromLayer.nodes.length * toLayer.nodes.length;
            let connectionIdx = 0;
            
            // Check for backward pass highlighting
            const shouldHighlightBack = isAnimating && animPhase === 'backward' && animLayer === l + 1;
            
            fromLayer.nodes.forEach((fromNode, fromIdx) => {
                toLayer.nodes.forEach((toNode, toIdx) => {
                    // Check if this weight is selected for loss landscape
                    const flatIdx = getWeightFlatIndex(l, fromIdx, toIdx);
                    const isLossLandscapeWeight = (flatIdx === lossSurfaceWeightIndices[0] || flatIdx === lossSurfaceWeightIndices[1]);
                    
                    // Use green for forward pass, red for backward pass (matches Ops/Step table)
                    if (shouldHighlight) {
                        ctx.strokeStyle = '#28a745';  // Green for forward
                        ctx.lineWidth = 3;
                    } else if (shouldHighlightBack) {
                        ctx.strokeStyle = '#dc3545';  // Red for backward
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#007bff';
                        ctx.lineWidth = 1;
                    }
                    ctx.beginPath();
                    ctx.moveTo(fromLayer.x, fromNode.y);
                    ctx.lineTo(toLayer.x, toNode.y);
                    ctx.stroke();
                    
                    // Draw weight value on connection with horizontal offset to prevent overlap
                    // Offset based on connection index, spreading weights along the line
                    // Use narrower range (0.35-0.65) to keep weights away from edges
                    const t = totalConnections > 1 ? 0.35 + 0.3 * (connectionIdx / (totalConnections - 1)) : 0.5;
                    let labelX = fromLayer.x + (toLayer.x - fromLayer.x) * t;
                    let labelY = fromNode.y + (toNode.y - fromNode.y) * t;
                    
                    // Clamp to canvas bounds with padding
                    const textPadding = 20;
                    labelX = Math.max(textPadding, Math.min(w - textPadding, labelX));
                    labelY = Math.max(12, Math.min(h - 12, labelY));
                    
                    let weight;
                    if (l === 0) {
                        weight = network.weights[0][toIdx];
                    } else if (l < numLayers) {
                        weight = network.weights[l][fromIdx] ? network.weights[l][fromIdx][toIdx] : network.weights[l][toIdx];
                    } else {
                        weight = network.weights[network.weights.length - 1][fromIdx];
                    }
                    
                    if (weight !== undefined) {
                        // Draw small background for readability
                        const textWidth = ctx.measureText(weight.toFixed(2)).width;
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillRect(labelX - textWidth/2 - 2, labelY - 8, textWidth + 4, 11);
                        ctx.fillStyle = '#007bff';
                        ctx.fillText(weight.toFixed(2), labelX, labelY);
                        
                        // Subtle blue box for loss landscape weights
                        if (isLossLandscapeWeight) {
                            ctx.strokeStyle = '#007bff';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(labelX - textWidth/2 - 3, labelY - 9, textWidth + 6, 13);
                        }
                    }
                    connectionIdx++;
                });
            });
        }
        
        // Draw nodes
        const actSymbol = config.activation === 'relu' ? 'ReLU' : 'œÉ';
        
        // Determine if we can show full equations (small networks only)
        const canShowFullEq = numLayers <= 2 && hiddenSize <= 4;
        const wideRadius = canShowFullEq ? nodeRadius * 2.2 : nodeRadius * 1.15;
        
        // Helper to format weight with sign
        const fmtW = (w) => {
            if (w === undefined || w === null) return '?';
            const val = w.toFixed(2);
            return w >= 0 ? `+${val}` : val;
        };
        const fmtWFirst = (w) => {
            if (w === undefined || w === null) return '?';
            return w.toFixed(2);
        };
        
        layers.forEach((layer, layerIdx) => {
            layer.nodes.forEach((node, nodeIdx) => {
                const nodeHighlight = isAnimating && animPhase === 'forward' && animLayer === layerIdx;
                const showGradients = isAnimating && animPhase === 'backward' && animLayer === layerIdx;
                
                if (layerIdx === 0) {
                    // Input node - small dot
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#333';
                    ctx.beginPath();
                    ctx.arc(layer.x, node.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (layerIdx === layers.length - 1) {
                    // Output node - wider oval
                    const outRadius = canShowFullEq ? wideRadius : nodeRadius * 1.3;
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#f0f8ff';
                    ctx.strokeStyle = '#6f42c1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, outRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    if (canShowFullEq) {
                        // Full equation: ≈∑ = v1*h1 + v2*h2 + ... + b
                        const outputWeights = network.weights[network.weights.length - 1];
                        const outputBias = network.biases[network.biases.length - 1][0];
                        let eqParts = [];
                        for (let i = 0; i < hiddenSize && i < 4; i++) {
                            const w = outputWeights[i];
                            if (i === 0) {
                                eqParts.push(`${fmtWFirst(w)}¬∑h${numLayers}${i+1}`);
                            } else {
                                eqParts.push(`${fmtW(w)}¬∑h${numLayers}${i+1}`);
                            }
                        }
                        if (hiddenSize > 4) eqParts.push('...');
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('≈∑', layer.x, node.y - 8);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Show equation on two lines if needed
                        const eq1 = eqParts.slice(0, 2).join('');
                        const eq2 = eqParts.slice(2).join('') + fmtW(outputBias);
                        ctx.fillText(eq1, layer.x, node.y + 4);
                        if (eq2.length > 3) {
                            ctx.fillText(eq2, layer.x, node.y + 13);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('≈∑', layer.x, node.y - 6);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText('Œ£v¬∑h+b', layer.x, node.y + 8);
                    }
                } else {
                    // Hidden node - oval with equation
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#e3f2fd';
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, wideRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    if (canShowFullEq) {
                        // Full equation: ReLU(w1*x + b) for first layer
                        // or ReLU(w1*h1 + w2*h2 + ... + b) for subsequent layers
                        let eqStr = '';
                        if (layerIdx === 1) {
                            // First hidden layer: input is x
                            const w = network.weights[0][nodeIdx];
                            const b = network.biases[0][nodeIdx];
                            eqStr = `${actSymbol}(${fmtWFirst(w)}¬∑x${fmtW(b)})`;
                        } else {
                            // Subsequent hidden layers
                            const prevLayerSize = hiddenSize;
                            const layerWeights = network.weights[layerIdx - 1];
                            const bias = network.biases[layerIdx - 1][nodeIdx];
                            let terms = [];
                            for (let i = 0; i < prevLayerSize && i < 3; i++) {
                                const w = layerWeights[i] ? layerWeights[i][nodeIdx] : layerWeights[nodeIdx];
                                if (i === 0) {
                                    terms.push(`${fmtWFirst(w)}¬∑h${layerIdx-1}${i+1}`);
                                } else {
                                    terms.push(`${fmtW(w)}¬∑h${layerIdx-1}${i+1}`);
                                }
                            }
                            if (prevLayerSize > 3) terms.push('...');
                            eqStr = `${actSymbol}(${terms.join('')}${fmtW(bias)})`;
                        }
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize - 1}px sans-serif`;
                        ctx.fillText(`h${layerIdx}${nodeIdx+1}`, layer.x, node.y - 6);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Truncate if too long
                        if (eqStr.length > 20) {
                            ctx.fillText(eqStr.substring(0, 20), layer.x, node.y + 5);
                            ctx.fillText(eqStr.substring(20), layer.x, node.y + 14);
                        } else {
                            ctx.fillText(eqStr, layer.x, node.y + 6);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize}px sans-serif`;
                        ctx.fillText(`h${layerIdx}${nodeIdx+1}`, layer.x, node.y - 4);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText(`${actSymbol}(z)`, layer.x, node.y + 8);
                    }
                }
            });
        });
        
        // Draw bias values for all non-input nodes
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        layers.forEach((layer, layerIdx) => {
            if (layerIdx === 0) return;  // Skip input layer
            
            layer.nodes.forEach((node, nodeIdx) => {
                let bias = 0;
                if (layerIdx < layers.length - 1) {
                    // Hidden layer bias
                    bias = network.biases[layerIdx - 1] ? network.biases[layerIdx - 1][nodeIdx] : 0;
                } else {
                    // Output layer bias
                    bias = network.biases[network.biases.length - 1] ? network.biases[network.biases.length - 1][0] : 0;
                }
                
                // Draw bias value below node (closer to bubble)
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                const biasText = `b=${bias.toFixed(1)}`;
                const textW = ctx.measureText(biasText).width;
                ctx.fillRect(layer.x - textW/2 - 1, node.y + nodeRadius - 1, textW + 2, 10);
                ctx.fillStyle = '#e67e22';
                ctx.fillText(biasText, layer.x, node.y + nodeRadius + 7);
            });
        });
        
        // Input label - larger and bolder
        ctx.fillStyle = '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('x', layers[0].x, layers[0].nodes[0].y - 12);
        
        // Show current values: x, y, ≈∑, and loss
        if (trainingState.recentSamples.length > 0) {
            const lastSample = trainingState.recentSamples[trainingState.recentSamples.length - 1];
            const lastLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : null;
            
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            
            // Left side: input and target
            ctx.fillText(`x = ${lastSample.x.toFixed(3)}`, 8, 18);
            ctx.fillText(`y = ${lastSample.y.toFixed(3)}`, 8, 32);
            
            // Right side: prediction and loss
            ctx.textAlign = 'right';
            if (history.loss.length > 0) {
                const fwd = forward(lastSample.x);
                ctx.fillText(`≈∑ = ${fwd.yhat.toFixed(3)}`, w - 8, 18);
                ctx.fillStyle = lastLoss < 0.01 ? '#28a745' : '#dc3545';
                ctx.fillText(`L = ¬Ω(≈∑-y)¬≤ = ${lastLoss.toFixed(4)}`, w - 8, 32);
            }
        }
        
        // Bottom: architecture info - larger font for readability
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        const optName = config.optimizer === 'sgd' ? 'Simple' : 'Adam';
        // Count total weights: first layer (H) + hidden layers ((L-1)*H*H) + output layer (H)
        const totalWeights = hiddenSize + (numLayers - 1) * hiddenSize * hiddenSize + hiddenSize;
        const totalBiases = numLayers * hiddenSize + 1;
        const totalParams = totalWeights + totalBiases;
        ctx.fillText(`${numLayers} hidden layer${numLayers > 1 ? 's' : ''} √ó ${hiddenSize} neurons  ‚Ä¢  ${totalParams} params  ‚Ä¢  ${actSymbol}  ‚Ä¢  ${optName}`, w/2, h - 6);
        
        // Update HTML Ops/Step table (check elements exist first)
        const ops = computeOpsPerStep();
        const opsFwdAdds = document.getElementById('opsFwdAdds');
        const opsFwdMuls = document.getElementById('opsFwdMuls');
        const opsBackAdds = document.getElementById('opsBackAdds');
        const opsBackMuls = document.getElementById('opsBackMuls');
        const opsTotAdds = document.getElementById('opsTotAdds');
        const opsTotMuls = document.getElementById('opsTotMuls');
        
        if (opsFwdAdds) opsFwdAdds.textContent = ops.fwdAdds;
        if (opsFwdMuls) opsFwdMuls.textContent = ops.fwdMuls;
        if (opsBackAdds) opsBackAdds.textContent = ops.backAdds;
        if (opsBackMuls) opsBackMuls.textContent = ops.backMuls;
        if (opsTotAdds) opsTotAdds.textContent = ops.fwdAdds + ops.backAdds;
        if (opsTotMuls) opsTotMuls.textContent = ops.fwdMuls + ops.backMuls;
    }
    
    // Animated step function
    async function animatedStep() {
        if (trainingState.animating) return;
        trainingState.animating = true;
        
        // Sample data
        const sample = sampleTrainingPoint();
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > 500) {
            trainingState.recentSamples.shift();
        }
        
        const numLayers = network.numLayers;
        const delayPerLayer = 300; // 0.3 seconds per layer
        
        // Animate forward pass
        drawNetwork({phase: 'forward', layer: 0});
        await sleep(delayPerLayer);
        
        for (let i = 1; i <= numLayers; i++) {
            drawNetwork({phase: 'forward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'forward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        // Compute forward and backward
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);
        
        // Animate backward pass
        drawNetwork({phase: 'backward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        for (let i = numLayers; i >= 1; i--) {
            drawNetwork({phase: 'backward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'backward', layer: 0});
        await sleep(delayPerLayer);
        
        // Update parameters
        updateParameters();
        
        // Update history
        trainingState.step++;
        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);
        
        const windowSize = config.avgWindow;
        let sum = 0, count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < windowSize; i--, count++) {
            sum += history.loss[i];
        }
        history.avgLoss.push(sum / Math.max(1, count));
        
        // Update ops
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        trainingState.animating = false;
        updateUI();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function updateEquations() {
        const L = network.numLayers;
        const H = network.hiddenSize;
        const act = config.activation;
        const actName = act === 'relu' ? 'ReLU' : 'Sigmoid';
        
        // Subscript numbers for cleaner notation
        const sub = (n) => ['‚ÇÄ','‚ÇÅ','‚ÇÇ','‚ÇÉ','‚ÇÑ'][n] || n;
        
        // Activation derivative in calculus terms
        const actDeriv = {
            'relu': "f'(z) = 1 if z > 0, else 0  <em style='color:#888'>(no saturation!)</em>",
            'sigmoid': "f'(z) = f(z) ¬∑ (1 ‚àí f(z))  <em style='color:#888'>(can vanish near 0 or 1)</em>"
        };
        
        let forwardHtml = `
            <strong>Setup:</strong> ${L} hidden layer${L>1?'s':''}, ${H} neurons each<br>
            <strong>Activation:</strong> f = ${actName}<br><br>
        `;
        
        // Layer-by-layer forward with subscripts
        forwardHtml += `<span style="color:#2E86AB">h${sub(0)}</span> = x  <em style="color:#888">(input)</em><br>`;
        for (let l = 1; l <= L; l++) {
            const prevH = l === 1 ? 'x' : `h${sub(l-1)}`;
            forwardHtml += `<span style="color:#F18F01">z${sub(l)}</span> = W${sub(l)} ¬∑ ${prevH} + b${sub(l)}  <em style="color:#888">(weighted sum)</em><br>`;
            forwardHtml += `<span style="color:#28a745">h${sub(l)}</span> = f(z${sub(l)})  <em style="color:#888">(apply activation)</em><br>`;
        }
        forwardHtml += `<br><span style="color:#6f42c1">≈∑</span> = v ¬∑ h${sub(L)} + c  <em style="color:#888">(output layer)</em>`;
        
        // Backward pass with calculus notation
        let backwardHtml = `
            <strong>Loss function:</strong> L = ¬Ω(≈∑ ‚àí y)¬≤<br><br>
            <strong>Chain rule from output:</strong><br>
            <span style="color:#dc3545">‚àÇL/‚àÇ≈∑</span> = ≈∑ ‚àí y  <em style="color:#888">(prediction error)</em><br>
            ‚àÇL/‚àÇv = (‚àÇL/‚àÇ≈∑) ¬∑ h${sub(L)}<br>
            ‚àÇL/‚àÇc = ‚àÇL/‚àÇ≈∑<br><br>
            <strong>Chain rule through layers:</strong><br>
        `;
        
        for (let l = L; l >= 1; l--) {
            const upstream = l === L ? '(‚àÇL/‚àÇ≈∑) ¬∑ v' : `(‚àÇL/‚àÇh${sub(l+1)}) ¬∑ W${sub(l+1)}`;
            const prevH = l === 1 ? 'x' : `h${sub(l-1)}`;
            backwardHtml += `<span style="color:#dc3545">‚àÇL/‚àÇh${sub(l)}</span> = ${upstream} ¬∑ f'(z${sub(l)})<br>`;
            backwardHtml += `‚àÇL/‚àÇW${sub(l)} = (‚àÇL/‚àÇh${sub(l)}) ¬∑ ${prevH},  ‚àÇL/‚àÇb${sub(l)} = ‚àÇL/‚àÇh${sub(l)}<br>`;
        }
        
        backwardHtml += `<br><strong>Activation derivative:</strong><br>${actDeriv[act]}`;
        
        // Optimizer explanation
        const optName = config.optimizer === 'sgd' ? 'Simple (SGD)' : 'Adam';
        const optExplain = config.optimizer === 'sgd' 
            ? `<strong>Weight Update:</strong><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇL/‚àÇw<br>
               <em style="color:#888">Each weight changes proportionally to its gradient.</em>`
            : `<strong>Weight Update:</strong><br>
               m ‚Üê 0.9¬∑m + 0.1¬∑‚àáL <em style="color:#888">(momentum)</em><br>
               v ‚Üê 0.999¬∑v + 0.001¬∑(‚àáL)¬≤ <em style="color:#888">(adapt)</em><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ m / ‚àöv<br>
               <em style="color:#888">Momentum smooths updates; adaptive rates help rare gradients.</em>`;
        
        const html = `
            <div class="equation-block">
                <div class="equation-title">Forward Pass</div>
                <div class="math">${forwardHtml}</div>
            </div>
            <div class="equation-block">
                <div class="equation-title">Backward Pass (Gradients)</div>
                <div class="math">${backwardHtml}</div>
                <br>
                <div class="equation-title" style="margin-top:8px;">Optimizer: ${optName}</div>
                <div class="math">${optExplain}</div>
            </div>
        `;
        
        document.getElementById('equationsDiv').innerHTML = html;
    }


    function drawFitPlot() {
        const canvas = document.getElementById('fitCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 50;
        const paddingRight = 50;
        const paddingTop = 30;  // Reduced from 50 to move graph up
        const paddingBottom = 38;  // Reduced to bring axis labels closer to handles
        const padding = 50;  // Keep for backward compatibility where uniform padding used

        ctx.clearRect(0, 0, w, h);

        const xMin = config.xMin;
        const xMax = config.xMax;
        const xRange = xMax - xMin;

        const hasRunA = !!savedRuns.A;
        const hasRunB = !!savedRuns.B;
        const comparisonMode = hasRunA && hasRunB;

        const numPoints = 200;
        const truthPoints = [];
        const modelPoints = [];
        let modelPointsA = null;
        let modelPointsB = null;

        for (let i = 0; i <= numPoints; i++) {
            const x = xMin + (i / numPoints) * xRange;
            let yTruth;
            try {
                yTruth = config.targetFunc(x);
            } catch (e) {
                yTruth = 0;
            }
            truthPoints.push({ x, y: yTruth });

            if (comparisonMode) {
                if (!modelPointsA) modelPointsA = [];
                if (!modelPointsB) modelPointsB = [];
                const netA = savedRuns.A.network;
                const cfgA = savedRuns.A.config;
                const netB = savedRuns.B.network;
                const cfgB = savedRuns.B.config;
                modelPointsA.push({ x, y: forwardWithNetwork(x, netA, cfgA.activation) });
                modelPointsB.push({ x, y: forwardWithNetwork(x, netB, cfgB.activation) });
            } else {
                modelPoints.push({ x, y: forward(x).yhat });
            }
        }

        let allY = truthPoints.map(p => p.y);
        if (comparisonMode) {
            allY = allY.concat(modelPointsA.map(p => p.y)).concat(modelPointsB.map(p => p.y));
        } else {
            allY = allY.concat(modelPoints.map(p => p.y));
        }
        trainingState.recentSamples.forEach(s => allY.push(s.y));
        let yMin = Math.min(...allY);
        let yMax = Math.max(...allY);
        if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
            yMin = -1;
            yMax = 1;
        }
        const yRange = yMax - yMin || 1;

        const plotWidth = w - paddingLeft - paddingRight;
        const plotHeight = h - paddingTop - paddingBottom;
        const toCanvasX = (x) => paddingLeft + (x - xMin) / xRange * plotWidth;
        const toCanvasY = (y) => h - paddingBottom - (y - yMin) / yRange * plotHeight;

        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotWidth, plotHeight);

        // Draw X axis tick marks and labels
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const numXTicks = 5;
        for (let i = 0; i <= numXTicks; i++) {
            const xVal = xMin + (i / numXTicks) * xRange;
            const cx = toCanvasX(xVal);
            // Tick mark
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(cx, h - paddingBottom);
            ctx.lineTo(cx, h - paddingBottom + 5);
            ctx.stroke();
            // Label
            ctx.fillText(xVal.toFixed(1), cx, h - paddingBottom + 16);
        }

        // Draw Y axis tick marks and labels
        ctx.textAlign = 'right';
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            const yVal = yMin + (i / numYTicks) * yRange;
            const cy = toCanvasY(yVal);
            // Tick mark
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(paddingLeft - 5, cy);
            ctx.lineTo(paddingLeft, cy);
            ctx.stroke();
            // Label
            ctx.fillText(yVal.toFixed(2), paddingLeft - 8, cy + 3);
        }

        ctx.strokeStyle = '#28a745';
        ctx.lineWidth = 2;
        ctx.beginPath();
        truthPoints.forEach((p, i) => {
            const cx = toCanvasX(p.x);
            const cy = toCanvasY(p.y);
            if (i === 0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
        });
        ctx.stroke();

        if (comparisonMode) {
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsA.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsB.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        } else {
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPoints.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        }

        ctx.fillStyle = 'rgba(220, 53, 69, 0.5)';
        trainingState.recentSamples.forEach((s) => {
            const cx = toCanvasX(s.x);
            const cy = toCanvasY(s.y);
            ctx.beginPath();
            ctx.arc(cx, cy, 2.5, 0, 2 * Math.PI);
            ctx.fill();
        });

        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('x', w / 2, h - 8);
        ctx.save();
        ctx.translate(10, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('y', 0, 0);
        ctx.restore();

        // Single row legend at top
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        const legendY = 14;
        let legendX = w - 280;

        // f(x) truth - green line
        ctx.strokeStyle = '#28a745';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 16, legendY);
        ctx.stroke();
        ctx.fillStyle = '#333';
        ctx.fillText('f(x)', legendX + 20, legendY + 4);
        legendX += 50;

        // ≈∑(x) model - blue line
        ctx.strokeStyle = '#007bff';
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 16, legendY);
        ctx.stroke();
        ctx.fillStyle = '#333';
        ctx.fillText('≈∑(x)', legendX + 20, legendY + 4);
        legendX += 50;

        // samples - red dot
        ctx.fillStyle = 'rgba(220, 53, 69, 0.5)';
        ctx.beginPath();
        ctx.arc(legendX + 4, legendY, 3, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = '#333';
        ctx.fillText('samples', legendX + 12, legendY + 4);

        if (comparisonMode) {
            // Add A/B labels for comparison mode
            legendX += 60;
            ctx.strokeStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('≈∑_B', legendX + 20, legendY + 4);
        }
    }

    function drawTrainingTraceComparison(ctx, w, h,
                                     paddingLeft, paddingRight,
                                     paddingTop, paddingBottom,
                                     runA, runB,
                                     showLoss, showAvgLoss, useLogScale = false,
                                     viewEndStep = null) {
    if (!runA || !runB) return;

    // Apply view filtering if specified
    let filteredRunA = runA;
    let filteredRunB = runB;
    if (viewEndStep !== null) {
        // Find index where step exceeds viewEndStep
        const idxA = runA.steps.findIndex(s => s > viewEndStep);
        const endIdxA = idxA === -1 ? runA.steps.length : idxA;
        filteredRunA = {
            steps: runA.steps.slice(0, endIdxA),
            loss: runA.loss.slice(0, endIdxA),
            avgLoss: runA.avgLoss.slice(0, endIdxA)
        };
        
        const idxB = runB.steps.findIndex(s => s > viewEndStep);
        const endIdxB = idxB === -1 ? runB.steps.length : idxB;
        filteredRunB = {
            steps: runB.steps.slice(0, endIdxB),
            loss: runB.loss.slice(0, endIdxB),
            avgLoss: runB.avgLoss.slice(0, endIdxB)
        };
    }

    const series = [];

    if (showLoss) {
        series.push({
            name: 'Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.loss,
            color: '#dc3545',
            lineWidth: 2
        });
        series.push({
            name: 'Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.loss,
            color: '#ff9800',
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.avgLoss,
            color: '#007bff',
            lineWidth: 3
        });
        series.push({
            name: 'Avg Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.avgLoss,
            color: '#00bcd4',
            lineWidth: 3
        });
    }

    if (series.length === 0) return;

    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X (steps)
    let stepMin = Infinity;
    let stepMax = -Infinity;
    series.forEach(s => {
        if (s.steps.length > 0) {
            stepMin = Math.min(stepMin, s.steps[0]);
            stepMax = Math.max(stepMax, s.steps[s.steps.length - 1]);
        }
    });
    if (!Number.isFinite(stepMin) || !Number.isFinite(stepMax)) return;
    const stepRange = stepMax - stepMin || 1;

    // Y (loss, linear)
    let yMin = Infinity;
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v)) return;
            yMin = Math.min(yMin, v);
            yMax = Math.max(yMax, v);
        });
    });
    if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
        yMin = 0;
        yMax = 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(1e-6, Math.abs(yMin) * 0.1);
        yMin -= eps;
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMin -= pad;
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) =>
        h - paddingBottom - ((val - yMin) / yRange) * plotHeight;

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicksComp = getNiceTicks(stepMin, stepMax, 5);
    xTicksComp.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values
    ctx.textAlign = 'right';
    const yTicksComp = getNiceTicks(yMin, yMax, 5);
    yTicksComp.forEach(val => {
        if (val < yMin || val > yMax) return;
        const y = toY(val);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        ctx.fillText(val.toPrecision(3), paddingLeft - 4, y + 3);
    });

    // Axis labels - moved further left to avoid overlap with tick labels
    ctx.save();
    ctx.translate(10, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText(useLogScale ? 'Loss (log‚ÇÅ‚ÇÄ)' : 'Loss (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        for (let i = 0; i < s.data.length; i++) {
            const x = toX(s.steps[i]);
            const y = toY(s.data[i]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    });

    // Legend - 2 columns to avoid overlap
    const legendStartX = w / 2 - 120;
    const legendColWidth = 110;
    const legendStartY = 12;
    const legendRowHeight = 14;
    
    series.forEach((s, i) => {
        const col = i % 2;  // 0 or 1
        const row = Math.floor(i / 2);  // 0, 1, ...
        const x = legendStartX + col * legendColWidth;
        const y = legendStartY + row * legendRowHeight;
        
        ctx.fillStyle = s.color;
        ctx.fillRect(x, y, 20, s.lineWidth);
        ctx.fillStyle = '#333';
        ctx.font = s.lineWidth === 3 ? 'bold 10px sans-serif' : '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(s.name, x + 24, y + 4);
    });
}

function drawTrainingTrace() {
    const canvas = document.getElementById('traceCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const paddingLeft = 60;
    const paddingRight = 60;
    const paddingTop = 40;
    const paddingBottom = 40;

    ctx.clearRect(0, 0, w, h);

    const showLoss = document.getElementById('traceLoss').checked;
    const showAvgLoss = document.getElementById('traceAvgLoss').checked;
    const showWeights = document.getElementById('traceWeights').checked;
    const useLogScale = document.getElementById('traceLogScale').checked;

    const hasRunA = !!savedRuns.A;
    const hasRunB = !!savedRuns.B;
    const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

    // Determine max steps for zoom handle (works for both normal and comparison modes)
    let maxSteps;
    if (comparisonMode) {
        maxSteps = Math.max(
            savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
            savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
        );
    } else {
        maxSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
    }
    
    // Show view handle when paused and have enough data to zoom
    const viewHandle = document.getElementById('traceViewHandle');
    const hasEnoughData = comparisonMode ? maxSteps > 50 : history.steps.length > 50;
    if (viewHandle) {
        const canZoom = !trainingState.running && hasEnoughData;
        if (canZoom) {
            viewHandle.style.display = 'flex';
            viewHandle.style.opacity = '0.9';
        } else if (hasEnoughData) {
            // Show but grayed out when running
            viewHandle.style.display = 'flex';
            viewHandle.style.opacity = '0.3';
        } else {
            viewHandle.style.display = 'none';
        }
        
        // Reset view when running
        if (trainingState.running) {
            traceViewEndStep = null;
        }
    }

    if (comparisonMode) {
        drawTrainingTraceComparison(
            ctx, w, h,
            paddingLeft, paddingRight,
            paddingTop, paddingBottom,
            savedRuns.A, savedRuns.B,
            showLoss, showAvgLoss, useLogScale,
            traceViewEndStep  // Pass the view end step
        );
        return;
    }

    // Draw axes even when no data yet
    const hasData = history.steps.length > 0;
    
    // Calculate view window: always start from 0, end based on traceViewEndStep (when paused)
    let viewStartIdx = 0;
    let viewEndIdx = history.steps.length;
    
    // If we have a view end step set, use it
    if (traceViewEndStep !== null && traceViewEndStep < history.steps.length) {
        viewEndIdx = Math.max(10, traceViewEndStep);
    }
    
    // Get sliced data for the view
    const viewSteps = hasData ? history.steps.slice(viewStartIdx, viewEndIdx) : [];
    const viewLoss = hasData ? history.loss.slice(viewStartIdx, viewEndIdx) : [];
    const viewAvgLoss = hasData ? history.avgLoss.slice(viewStartIdx, viewEndIdx) : [];
    
    const series = [];

    if (showLoss) {
        series.push({
            name: 'Loss',
            steps: viewSteps,
            data: viewLoss,
            color: '#dc3545',
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss (100)',
            steps: viewSteps,
            data: viewAvgLoss,
            color: '#007bff',
            lineWidth: 3
        });
    }

    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X axis range (use defaults if no data)
    const stepMin = viewSteps.length > 0 ? viewSteps[0] : 0;
    const stepMax = viewSteps.length > 0 ? viewSteps[viewSteps.length - 1] : 100;
    const stepRange = stepMax - stepMin || 100;

    // Y axis range for loss (supports log scale) - ALWAYS starts from 0 in linear mode
    let yMin = 0;  // Loss always starts from 0
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v) || (useLogScale && v <= 0)) return;
            const val = useLogScale ? Math.log10(v) : v;
            yMax = Math.max(yMax, val);
        });
    });
    if (useLogScale) {
        // For log scale, find the minimum non-zero value
        yMin = Infinity;
        series.forEach(s => {
            s.data.forEach(v => {
                if (v > 0) yMin = Math.min(yMin, Math.log10(v));
            });
        });
        if (!Number.isFinite(yMin)) yMin = -4;
    }
    if (!Number.isFinite(yMax)) {
        yMax = useLogScale ? 0 : 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(0.1, Math.abs(yMin) * 0.1);
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;
    
    // Get sliced weights for the view
    const viewWeights = hasData ? history.weights.slice(viewStartIdx, viewEndIdx) : [];
    
    // Y axis range for weights (separate right axis)
    let wMin = Infinity;
    let wMax = -Infinity;
    if (showWeights && viewWeights.length > 0) {
        viewWeights.forEach(wArr => {
            wArr.forEach(v => {
                if (Number.isFinite(v)) {
                    wMin = Math.min(wMin, v);
                    wMax = Math.max(wMax, v);
                }
            });
        });
    }
    if (!Number.isFinite(wMin) || !Number.isFinite(wMax)) {
        wMin = -2;
        wMax = 2;
    }
    if (wMin === wMax) {
        wMin -= 1;
        wMax += 1;
    } else {
        const wPad = 0.1 * (wMax - wMin);
        wMin -= wPad;
        wMax += wPad;
    }
    const wRange = wMax - wMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) => {
        const v = useLogScale ? Math.log10(Math.max(val, 1e-10)) : val;
        return h - paddingBottom - ((v - yMin) / yRange) * plotHeight;
    };

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicks = getNiceTicks(stepMin, stepMax, 5);
    xTicks.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values (log scale uses powers of 10)
    ctx.textAlign = 'right';
    const yTicks = useLogScale ? getLogTicks(yMin, yMax) : getNiceTicks(yMin, yMax, 5);
    yTicks.forEach(yVal => {
        if (yVal < yMin || yVal > yMax) return;
        const y = h - paddingBottom - ((yVal - yMin) / yRange) * plotHeight;
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        if (useLogScale) {
            const realVal = Math.pow(10, yVal);
            // Format as power of 10: 10^-2 shows as "0.01", 10^-3 as "0.001" etc.
            if (Number.isInteger(yVal)) {
                ctx.fillText(realVal.toExponential(0), paddingLeft - 4, y + 3);
            } else {
                ctx.fillText(realVal.toPrecision(2), paddingLeft - 4, y + 3);
            }
        } else {
            ctx.fillText(yVal.toPrecision(3), paddingLeft - 4, y + 3);
        }
    });

    // Axis labels
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(useLogScale ? 'Loss (log‚ÇÅ‚ÇÄ)' : 'Loss (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Draw loss series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < s.data.length; i++) {
            const val = s.data[i];
            if (!Number.isFinite(val) || (useLogScale && val <= 0)) continue;
            const x = toX(s.steps[i]);
            const y = toY(val);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    });

    // Draw weight traces (on right Y axis)
    if (showWeights && viewWeights && viewWeights.length > 0) {
        const numWeights = viewWeights[0].length;
        const weightColors = ['#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#ff7f0e', '#2ca02c'];
        
        // Use pre-calculated weight range from earlier
        const toWY = (val) => h - paddingBottom - ((val - wMin) / wRange) * plotHeight;
        
        // Draw right axis tick marks and labels for weights - use nice values
        ctx.textAlign = 'left';
        ctx.font = '9px sans-serif';
        const wTicks = getNiceTicks(wMin, wMax, 5);
        wTicks.forEach(wVal => {
            if (wVal < wMin || wVal > wMax) return;
            const y = h - paddingBottom - ((wVal - wMin) / wRange) * plotHeight;
            // Tick mark
            ctx.strokeStyle = '#9467bd';
            ctx.beginPath();
            ctx.moveTo(w - paddingRight, y);
            ctx.lineTo(w - paddingRight + 5, y);
            ctx.stroke();
            // Label
            ctx.fillStyle = '#9467bd';
            ctx.fillText(wVal.toFixed(1), w - paddingRight + 8, y + 3);
        });
        
        // Draw weight lines
        for (let wi = 0; wi < Math.min(numWeights, 8); wi++) {
            ctx.strokeStyle = weightColors[wi % weightColors.length];
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < viewWeights.length; i++) {
                const x = toX(viewSteps[i]);
                const y = toWY(viewWeights[i][wi]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        
        // Right axis label
        ctx.save();
        ctx.translate(w - 5, h / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#9467bd';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Weights', 0, 0);
        ctx.restore();
    }
}

    // Loss surface visualization
    let lossSurfaceCache = null;
    let lossSurfaceWeightIndices = [0, 1];
    let lossSurfaceTrail = [];  // Trail of weight positions during training
    let lossSurfaceStartPosition = null;  // Store starting position separately
    let lossSurfaceAutoUpdate = true;  // Auto-update every N steps
    let lossSurfaceUpdateInterval = 50;  // Update every 50 steps
    let lossLandscapeAutoMode = true;  // Auto-select weights by default
    
    function populateWeightSelectors() {
        const selectX = document.getElementById('weightXSelect');
        const selectY = document.getElementById('weightYSelect');
        if (!selectX || !selectY) return;
        
        // Build list of all weights with descriptive names and categories
        const weightNames = [];
        let idx = 0;
        
        // First layer: input -> hidden (category: 'input')
        for (let i = 0; i < network.hiddenSize; i++) {
            weightNames.push({ idx: idx++, name: `w(x‚Üíh‚ÇÅ${i+1})`, category: 'input', neuron: i });
        }
        
        // Hidden -> hidden layers (category: 'hidden')
        for (let l = 1; l < network.numLayers; l++) {
            for (let i = 0; i < network.hiddenSize; i++) {
                for (let j = 0; j < network.hiddenSize; j++) {
                    weightNames.push({ idx: idx++, name: `w(h${l}${j+1}‚Üíh${l+1}${i+1})`, category: 'hidden', layer: l });
                }
            }
        }
        
        // Output layer (category: 'output')
        for (let i = 0; i < network.hiddenSize; i++) {
            weightNames.push({ idx: idx++, name: `v(h${network.numLayers}${i+1}‚Üí≈∑)`, category: 'output', neuron: i });
        }
        
        // Populate selectors
        selectX.innerHTML = '';
        selectY.innerHTML = '';
        
        weightNames.forEach(w => {
            const optX = document.createElement('option');
            optX.value = w.idx;
            optX.textContent = w.name;
            selectX.appendChild(optX);
            
            const optY = document.createElement('option');
            optY.value = w.idx;
            optY.textContent = w.name;
            selectY.appendChild(optY);
        });
        
        // Auto-select interesting weights:
        // Pick one from input layer and one from output layer for maximum independence
        const inputWeights = weightNames.filter(w => w.category === 'input');
        const outputWeights = weightNames.filter(w => w.category === 'output');
        
        let bestPair = [0, 1];
        
        if (inputWeights.length > 0 && outputWeights.length > 0) {
            // Pick first input weight and first output weight (different layers = more interesting)
            bestPair = [inputWeights[0].idx, outputWeights[0].idx];
        } else if (weightNames.length >= 2) {
            // Fallback: pick weights from different neurons
            bestPair = [0, Math.min(1, weightNames.length - 1)];
        }
        
        selectX.value = bestPair[0].toString();
        selectY.value = bestPair[1].toString();
        lossSurfaceWeightIndices = bestPair;
    }
    
    // Find the most "interesting" pair of weights by sampling loss variance
    function autoSelectInterestingWeights() {
        try {
            const selectX = document.getElementById('weightXSelect');
            const selectY = document.getElementById('weightYSelect');
            if (!selectX || !selectY) {
                console.log('Weight selectors not found');
                return;
            }
            
            const numWeights = selectX.options.length;
            if (numWeights < 2) {
                console.log('Not enough weights:', numWeights);
                // Just use first two weights as default
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
                return;
            }
            
            // Simple approach: just pick first input weight and first output weight
            // This is more robust for different network sizes
            const H = network.hiddenSize;
            const L = network.numLayers;
            
            // First weight (input to first hidden)
            const idx1 = 0;
            // Last weight (last hidden to output) - approximate
            const idx2 = Math.min(numWeights - 1, H);
            
            if (idx1 !== idx2 && idx2 < numWeights) {
                lossSurfaceWeightIndices = [idx1, idx2];
            } else {
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
            }
            
            selectX.value = lossSurfaceWeightIndices[0].toString();
            selectY.value = lossSurfaceWeightIndices[1].toString();
            lossSurfaceCache = null;
            lossSurfaceTrail = [];
            console.log('Auto-selected weights:', lossSurfaceWeightIndices);
        } catch(e) {
            console.error('autoSelectInterestingWeights error:', e);
            // Fallback to default
            lossSurfaceWeightIndices = [0, 1];
        }
    }
    
    function getWeightByIndex(idx) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            return network.weights[0][idx];
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                return network.weights[l][i][j];
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            return network.weights[network.weights.length - 1][outIdx];
        }
        
        return 0;
    }
    
    function setWeightByIndex(idx, value) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            network.weights[0][idx] = value;
            return;
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                network.weights[l][i][j] = value;
                return;
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            network.weights[network.weights.length - 1][outIdx] = value;
        }
    }
    
    function computeLossSurface() {
        const resolution = 60;  // 60x60 grid for finer detail
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Save current weights
        const savedWX = getWeightByIndex(idxX);
        const savedWY = getWeightByIndex(idxY);
        
        // Determine range - include all trail points plus current position with padding
        let minX = savedWX, maxX = savedWX;
        let minY = savedWY, maxY = savedWY;
        
        // Include start position
        if (lossSurfaceStartPosition) {
            minX = Math.min(minX, lossSurfaceStartPosition.x);
            maxX = Math.max(maxX, lossSurfaceStartPosition.x);
            minY = Math.min(minY, lossSurfaceStartPosition.y);
            maxY = Math.max(maxY, lossSurfaceStartPosition.y);
        }
        
        // Include all trail points
        for (const pt of lossSurfaceTrail) {
            minX = Math.min(minX, pt.x);
            maxX = Math.max(maxX, pt.x);
            minY = Math.min(minY, pt.y);
            maxY = Math.max(maxY, pt.y);
        }
        
        // Add padding (20% on each side, minimum ¬±2 range)
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;
        const padX = Math.max(2, rangeX * 0.2);
        const padY = Math.max(2, rangeY * 0.2);
        minX -= padX;
        maxX += padX;
        minY -= padY;
        maxY += padY;
        
        // Sample training points for loss calculation
        const numSamples = 20;
        const samples = [];
        for (let i = 0; i < numSamples; i++) {
            const x = config.xMin + Math.random() * (config.xMax - config.xMin);
            let y;
            try { y = config.targetFunc(x); } catch { y = 0; }
            samples.push({ x, y });
        }
        
        // Compute loss grid
        const grid = [];
        let minLoss = Infinity, maxLoss = -Infinity;
        
        for (let iy = 0; iy < resolution; iy++) {
            const row = [];
            const wy = minY + (iy / (resolution - 1)) * (maxY - minY);
            
            for (let ix = 0; ix < resolution; ix++) {
                const wx = minX + (ix / (resolution - 1)) * (maxX - minX);
                
                // Set weights
                setWeightByIndex(idxX, wx);
                setWeightByIndex(idxY, wy);
                
                // Compute average loss over samples
                let totalLoss = 0;
                for (const sample of samples) {
                    const fwd = forward(sample.x);
                    const error = fwd.yhat - sample.y;
                    totalLoss += 0.5 * error * error;
                }
                const avgLoss = totalLoss / numSamples;
                
                row.push(avgLoss);
                if (avgLoss < minLoss) minLoss = avgLoss;
                if (avgLoss > maxLoss) maxLoss = avgLoss;
            }
            grid.push(row);
        }
        
        // Restore weights
        setWeightByIndex(idxX, savedWX);
        setWeightByIndex(idxY, savedWY);
        
        lossSurfaceCache = {
            grid, minLoss, maxLoss, minX, maxX, minY, maxY, resolution,
            currentX: savedWX, currentY: savedWY
        };
    }
    
    function drawLossSurface() {
        const canvas = document.getElementById('lossCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 45;
        const paddingRight = 35;
        const paddingTop = 20;
        const paddingBottom = 25;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const plotW = w - paddingLeft - paddingRight;
        const plotH = h - paddingTop - paddingBottom;
        
        if (!lossSurfaceCache) {
            // Draw placeholder axes and message
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, h - paddingBottom);
            ctx.lineTo(w - paddingRight, h - paddingBottom);
            ctx.stroke();
            
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Computing...', w/2, h/2);
            return;
        }
        
        const { grid, minLoss, maxLoss, minX, maxX, minY, maxY, resolution } = lossSurfaceCache;
        const cellW = plotW / resolution;
        const cellH = plotH / resolution;
        
        // Fixed logarithmic color scale for consistent comparisons
        // Maps loss 0.001 (deep blue) to 10.0 (deep red)
        const fixedMinLog = Math.log10(0.001);  // -3
        const fixedMaxLog = Math.log10(10);      // 1
        const fixedLogRange = fixedMaxLog - fixedMinLog;  // 4 decades
        
        for (let iy = 0; iy < resolution; iy++) {
            for (let ix = 0; ix < resolution; ix++) {
                const loss = grid[iy][ix];
                
                // Fixed log scale normalization (0 = loss 0.001, 1 = loss 10)
                const clampedLoss = Math.max(0.001, Math.min(10, loss));
                const logLoss = Math.log10(clampedLoss);
                const normLoss = (logLoss - fixedMinLog) / fixedLogRange;
                
                // Smooth HSL-based gradient with more color resolution
                // Hue: 240 (blue) ‚Üí 180 (cyan) ‚Üí 120 (green) ‚Üí 60 (yellow) ‚Üí 0 (red)
                const hue = 240 * (1 - normLoss);  // Blue to red
                const sat = 85 + 15 * Math.sin(normLoss * Math.PI);  // Slight saturation boost in middle
                const light = 35 + 25 * (1 - Math.abs(normLoss - 0.5) * 2);  // Brighter in middle
                
                ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                const px = paddingLeft + ix * cellW;
                const py = paddingTop + (resolution - 1 - iy) * cellH;
                ctx.fillRect(px, py, cellW + 1, cellH + 1);
            }
        }
        
        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotW, plotH);
        
        // Helper to convert weight values to canvas coordinates
        const toCanvasX = (wx) => paddingLeft + ((wx - minX) / (maxX - minX)) * plotW;
        const toCanvasY = (wy) => paddingTop + (1 - (wy - minY) / (maxY - minY)) * plotH;
        
        // Check for comparison mode - only valid if network architecture, activation, and target are the same
        // (comparing optimizer or learning rate differences makes sense, but different architectures don't share a loss landscape)
        function canCompareLossLandscapes() {
            if (!comparisonModeActive || !savedRuns.A || !savedRuns.B) return false;
            const cfgA = savedRuns.A.config;
            const cfgB = savedRuns.B.config;
            
            // Must have same architecture
            if (cfgA.numLayers !== cfgB.numLayers) return false;
            if (cfgA.hiddenSize !== cfgB.hiddenSize) return false;
            
            // Must have same activation (changes landscape shape)
            if (cfgA.activation !== cfgB.activation) return false;
            
            // Must have same target function
            if (cfgA.targetFuncStr !== cfgB.targetFuncStr) return false;
            
            // Must have saved trails with same weight indices
            if (!savedRuns.A.lossSurfaceTrail || !savedRuns.B.lossSurfaceTrail) return false;
            if (!savedRuns.A.lossSurfaceWeightIndices || !savedRuns.B.lossSurfaceWeightIndices) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[0] !== savedRuns.B.lossSurfaceWeightIndices[0]) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[1] !== savedRuns.B.lossSurfaceWeightIndices[1]) return false;
            
            return true;
        }
        
        const inComparisonMode = canCompareLossLandscapes();
        
        // Helper to draw a trail
        function drawTrail(trail, color, alpha = 0.85) {
            if (!trail || trail.length < 2) return;
            ctx.strokeStyle = color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trail[0].x), toCanvasY(trail[0].y));
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(toCanvasX(trail[i].x), toCanvasY(trail[i].y));
            }
            ctx.stroke();
        }
        
        if (inComparisonMode) {
            // Draw Run A trail (red/orange)
            if (savedRuns.A.lossSurfaceTrail) {
                drawTrail(savedRuns.A.lossSurfaceTrail, 'rgb(220, 53, 69)', 0.9);
                // Start marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const startA = savedRuns.A.lossSurfaceTrail[0];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startA.x), toCanvasY(startA.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const endA = savedRuns.A.lossSurfaceTrail[savedRuns.A.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endA.x), toCanvasY(endA.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw Run B trail (cyan/teal)
            if (savedRuns.B.lossSurfaceTrail) {
                drawTrail(savedRuns.B.lossSurfaceTrail, 'rgb(0, 188, 212)', 0.9);
                // Start marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const startB = savedRuns.B.lossSurfaceTrail[0];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startB.x), toCanvasY(startB.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const endB = savedRuns.B.lossSurfaceTrail[savedRuns.B.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endB.x), toCanvasY(endB.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        } else {
            // Normal mode - single trail
            if (lossSurfaceTrail.length > 1) {
                // Draw white trail with slight transparency
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                const first = lossSurfaceTrail[0];
                ctx.moveTo(toCanvasX(first.x), toCanvasY(first.y));
                for (let i = 1; i < lossSurfaceTrail.length; i++) {
                    const pt = lossSurfaceTrail[i];
                    ctx.lineTo(toCanvasX(pt.x), toCanvasY(pt.y));
                }
                ctx.stroke();
            }
            
            // Always draw start point if we have a starting position
            if (lossSurfaceStartPosition) {
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(toCanvasX(lossSurfaceStartPosition.x), toCanvasY(lossSurfaceStartPosition.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            // Draw current position
            const currentWX = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const currentWY = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const posX = toCanvasX(currentWX);
            const posY = toCanvasY(currentWY);
            
            // Draw current marker
            ctx.fillStyle = '#dc3545';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(posX, posY, 6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
        
        // Axis labels
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        
        // X axis labels - just below the plot area
        const xLabelY = h - paddingBottom + 15;
        ctx.fillText(minX.toFixed(1), paddingLeft, xLabelY);
        ctx.fillText(maxX.toFixed(1), w - paddingRight, xLabelY);
        ctx.fillText('w‚ÇÅ', (paddingLeft + w - paddingRight) / 2, xLabelY);
        
        // Y axis labels - just left of the plot area
        ctx.textAlign = 'right';
        ctx.fillText(minY.toFixed(1), paddingLeft - 4, h - paddingBottom + 3);
        ctx.fillText(maxY.toFixed(1), paddingLeft - 4, paddingTop + 3);
        
        // Y axis title
        ctx.save();
        ctx.translate(12, (paddingTop + h - paddingBottom) / 2);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = 'center';
        ctx.fillText('w‚ÇÇ', 0, 0);
        ctx.restore();
    }
   
    function updateUI() {
        try {
            document.getElementById('stepCount').textContent = trainingState.step;
            const lastLoss = history.loss[history.loss.length - 1];
            document.getElementById('lossValue').textContent =
                Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';

            document.getElementById('totalAdds').textContent = trainingState.totalAdds.toLocaleString();
            document.getElementById('totalMuls').textContent = trainingState.totalMuls.toLocaleString();
            
            // Calculate delta-loss (change in rolling average over last window)
            const deltaLossEl = document.getElementById('deltaLossValue');
            if (deltaLossEl && history.avgLoss.length >= 2) {
                const windowSize = Math.min(config.avgWindow, history.avgLoss.length);
                const currentAvg = history.avgLoss[history.avgLoss.length - 1];
                const prevAvg = history.avgLoss[Math.max(0, history.avgLoss.length - windowSize)];
                const deltaLoss = currentAvg - prevAvg;
                
                if (Number.isFinite(deltaLoss)) {
                    const sign = deltaLoss > 0 ? '+' : '';
                    deltaLossEl.textContent = sign + deltaLoss.toExponential(2);
                    // Green if decreasing (good), red if increasing (bad)
                    deltaLossEl.style.color = deltaLoss <= 0 ? '#28a745' : '#dc3545';
                } else {
                    deltaLossEl.textContent = '‚Äî';
                    deltaLossEl.style.color = '#666';
                }
            }

            try { drawNetwork(); } catch(e) { console.error('drawNetwork error:', e); }
            try { drawFitPlot(); } catch(e) { console.error('drawFitPlot error:', e); }
            try { drawTrainingTrace(); } catch(e) { console.error('drawTrainingTrace error:', e); }
            try { drawLossSurface(); } catch(e) { console.error('drawLossSurface error:', e); }
            try { updateEquations(); } catch(e) { console.error('updateEquations error:', e); }
        } catch(e) {
            console.error('updateUI error:', e);
        }
    }
    
    // Track when we last auto-paused to allow continued training
    let lastAutoPauseStep = -2000;
    
    // Check if training should auto-pause (no improvement in last 1000 steps)
    function shouldAutoPause() {
        // Need at least 2000 steps before first check
        if (history.loss.length < 2000) return false;
        
        // Must run at least 1000 steps since last auto-pause before checking again
        if (trainingState.step - lastAutoPauseStep < 1000) return false;
        
        // Compute 1000-step rolling average for current window
        const windowSize = 1000;
        const currentWindow = history.loss.slice(-windowSize);
        const currentAvg = currentWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Compute 1000-step rolling average for previous window (1000 steps ago)
        const prevWindow = history.loss.slice(-2000, -1000);
        const prevAvg = prevWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Pause if current 1000-step average hasn't improved over previous 1000-step average
        if (currentAvg >= prevAvg) {
            lastAutoPauseStep = trainingState.step;
            return true;
        }
        return false;
    }

    // --------------- Wiring Controls ----------------

    function setupControls() {
        const lrSlider = document.getElementById('learningRate');
        const lrValue = document.getElementById('learningRateValue');
        lrSlider.addEventListener('input', () => {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        });
        (function initLR() {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        })();

        const noiseSlider = document.getElementById('noise');
        const noiseLabel = document.getElementById('noiseValue');
        noiseSlider.addEventListener('input', () => {
            config.noise = parseFloat(noiseSlider.value);
            noiseLabel.textContent = config.noise.toFixed(2);
        });
        config.noise = parseFloat(noiseSlider.value);
        noiseLabel.textContent = config.noise.toFixed(2);

        const numLayersSlider = document.getElementById('numLayers');
        const numLayersValue = document.getElementById('numLayersValue');
        numLayersSlider.addEventListener('input', () => {
            network.numLayers = parseInt(numLayersSlider.value, 10);
            numLayersValue.textContent = network.numLayers.toString();
            reset();  // Auto-reset when network architecture changes
        });
        network.numLayers = parseInt(numLayersSlider.value, 10);
        numLayersValue.textContent = network.numLayers.toString();

        const hiddenSizeSlider = document.getElementById('hiddenSize');
        const hiddenSizeValue = document.getElementById('hiddenSizeValue');
        hiddenSizeSlider.addEventListener('input', () => {
            network.hiddenSize = parseInt(hiddenSizeSlider.value, 10);
            hiddenSizeValue.textContent = network.hiddenSize.toString();
            reset();  // Auto-reset when network architecture changes
        });
        network.hiddenSize = parseInt(hiddenSizeSlider.value, 10);
        hiddenSizeValue.textContent = network.hiddenSize.toString();

        const xMinSlider = document.getElementById('xMin');
        const xMaxSlider = document.getElementById('xMax');
        const xMinLabel = document.getElementById('xMinLabel');
        const xMaxLabel = document.getElementById('xMaxLabel');
        function syncXRange() {
            let minVal = parseFloat(xMinSlider.value);
            let maxVal = parseFloat(xMaxSlider.value);
            if (minVal >= maxVal) {
                if (this === xMinSlider) {
                    minVal = maxVal - 0.1;
                    xMinSlider.value = minVal.toString();
                } else {
                    maxVal = minVal + 0.1;
                    xMaxSlider.value = maxVal.toString();
                }
            }
            config.xMin = minVal;
            config.xMax = maxVal;
            xMinLabel.textContent = minVal.toFixed(1);
            xMaxLabel.textContent = maxVal.toFixed(1);
        }
        xMinSlider.addEventListener('input', syncXRange);
        xMaxSlider.addEventListener('input', syncXRange);
        config.xMin = parseFloat(xMinSlider.value);
        config.xMax = parseFloat(xMaxSlider.value);

        // Mobile x-range sliders
        const xMinMobile = document.getElementById('xMinMobile');
        const xMaxMobile = document.getElementById('xMaxMobile');
        const xMinMobileVal = document.getElementById('xMinMobileVal');
        const xMaxMobileVal = document.getElementById('xMaxMobileVal');
        if (xMinMobile && xMaxMobile) {
            xMinMobile.addEventListener('input', () => {
                config.xMin = parseFloat(xMinMobile.value);
                xMinMobileVal.textContent = config.xMin.toFixed(1);
                xMinSlider.value = config.xMin;
                drawFitPlot();
            });
            xMaxMobile.addEventListener('input', () => {
                config.xMax = parseFloat(xMaxMobile.value);
                xMaxMobileVal.textContent = config.xMax.toFixed(1);
                xMaxSlider.value = config.xMax;
                drawFitPlot();
            });
        }

        const targetFuncInput = document.getElementById('targetFuncInput');
        targetFuncInput.addEventListener('change', () => {
            compileTargetFunc();
            reset();
        });
        targetFuncInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                compileTargetFunc();
                reset();
            }
        });

        const activationSelector = document.getElementById('activationSelector');
        activationSelector.addEventListener('click', (e) => {
            if (!e.target.classList.contains('activation-option')) return;
            const options = activationSelector.querySelectorAll('.activation-option');
            options.forEach(opt => opt.classList.remove('selected'));
            e.target.classList.add('selected');
            config.activation = e.target.dataset.act;
            updateUI();
        });

        // Optimizer buttons
        document.querySelectorAll('#optimizerButtons .opt-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#optimizerButtons .opt-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                
                // Update config
                config.optimizer = btn.dataset.opt;
                
                // Auto-adjust learning rate for optimizer
                // Adam works best with lower learning rates (0.001-0.01)
                // Simple SGD works with higher rates (0.01-0.1)
                const lrSlider = document.getElementById('learningRate');
                const lrValue = document.getElementById('learningRateValue');
                if (btn.dataset.opt === 'adam' && config.learningRate > 0.02) {
                    // Lower the learning rate for Adam
                    config.learningRate = 0.01;
                    lrSlider.value = Math.log10(0.01);
                    lrValue.textContent = '0.010';
                } else if (btn.dataset.opt === 'sgd' && config.learningRate < 0.05) {
                    // Raise the learning rate for SGD
                    config.learningRate = 0.1;
                    lrSlider.value = Math.log10(0.1);
                    lrValue.textContent = '0.100';
                }
                
                initializeOptimizerState();
                updateUI();
            });
        });

        const gifBtnEl = document.getElementById('gifBtn');
        // Set button label based on whether GIF capture is available
        gifBtnEl.textContent = canUseGifWorkers() ? 'Capture GIF' : 'Screenshot';
        gifBtnEl.title = canUseGifWorkers() 
            ? 'Record an animated GIF of training convergence' 
            : 'Save a PNG screenshot (run from web server for animated GIF)';
        gifBtnEl.addEventListener('click', () => {
            startGifCapture();
        });

        const saveRunABtn = document.getElementById('saveRunA');
        const saveRunBBtn = document.getElementById('saveRunB');
        const compareBtn = document.getElementById('compareBtn');
        
        saveRunABtn.addEventListener('click', () => saveRun('A'));
        saveRunBBtn.addEventListener('click', () => saveRun('B'));
        
        compareBtn.addEventListener('click', () => {
            if (savedRuns.A && savedRuns.B) {
                comparisonModeActive = !comparisonModeActive;
                // Toggle button appearance
                if (comparisonModeActive) {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#0056b3; color:white; border:1px solid #0056b3; cursor:pointer;';
                    compareBtn.textContent = '‚úì Comparing A vs B';
                } else {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
                    compareBtn.textContent = 'Compare A vs B';
                }
                updateUI();
            }
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            exitComparisonMode();  // Exit comparison when stepping
            animatedStep();
        });

        document.getElementById('runBtn').addEventListener('click', () => {
            trainingState.running = !trainingState.running;
            const btn = document.getElementById('runBtn');
            btn.textContent = trainingState.running ? 'Pause' : 'Run';
            trainingState.lastUpdateTime = performance.now();
            if (trainingState.running) {
                exitComparisonMode();  // Exit comparison when running
                requestAnimationFrame(runLoop);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('runBtn').textContent = 'Run';
            reset();
        });

        document.getElementById('traceLoss').addEventListener('change', updateUI);
        document.getElementById('traceAvgLoss').addEventListener('change', updateUI);
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        document.getElementById('traceLogScale').addEventListener('change', updateUI);
        
        // Loss surface controls
        const weightXSelect = document.getElementById('weightXSelect');
        const weightYSelect = document.getElementById('weightYSelect');
        
        // Auto mode for loss landscape (uses global lossLandscapeAutoMode)
        const weightSelectContainer = document.getElementById('weightSelectContainer');
        
        function setAutoMode(enabled) {
            lossLandscapeAutoMode = enabled;
            if (weightSelectContainer) weightSelectContainer.style.opacity = enabled ? '0.5' : '1';
            if (autoSelectBtn) {
                autoSelectBtn.style.background = enabled ? '#007bff' : '#6c757d';
                autoSelectBtn.style.borderColor = enabled ? '#007bff' : '#6c757d';
            }
        }
        
        if (weightXSelect && weightYSelect) {
            weightXSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[0] = parseInt(weightXSelect.value);
                lossSurfaceCache = null;  // Invalidate cache
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
            weightYSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[1] = parseInt(weightYSelect.value);
                lossSurfaceCache = null;
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
        }
        
        const autoSelectBtn = document.getElementById('autoSelectBtn');
        if (autoSelectBtn) {
            autoSelectBtn.addEventListener('click', () => {
                setAutoMode(true);  // Re-enter auto mode
                autoSelectBtn.textContent = '...';
                setTimeout(() => {
                    autoSelectInterestingWeights();
                    computeLossSurface();
                    drawLossSurface();
                    drawNetwork();  // Update highlight boxes
                    autoSelectBtn.textContent = 'Auto';
                }, 10);
            });
        }
        
        // Rolling average window slider
        const avgWindowSlider = document.getElementById('avgWindowSlider');
        const avgWindowValue = document.getElementById('avgWindowValue');
        avgWindowSlider.addEventListener('input', () => {
            config.avgWindow = parseInt(avgWindowSlider.value);
            avgWindowValue.textContent = config.avgWindow;
            // Recalculate all rolling averages with new window size
            history.avgLoss = [];
            const minPointsForAvg = 10;
            for (let i = 0; i < history.loss.length; i++) {
                if (i + 1 < minPointsForAvg) {
                    history.avgLoss.push(null);  // Not enough points yet
                } else {
                    let sum = 0, count = 0;
                    for (let j = i; j >= 0 && count < config.avgWindow; j--, count++) {
                        sum += history.loss[j];
                    }
                    history.avgLoss.push(sum / Math.max(1, count));
                }
            }
            updateUI();
        });
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        
        // Activation buttons in header
        document.querySelectorAll('#activationButtons .act-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#activationButtons .act-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                    b.style.fontWeight = '500';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
                
                // Update config
                config.activation = btn.dataset.act;
                
                // Also update hidden selector for compatibility
                const options = document.querySelectorAll('#activationSelector .activation-option');
                options.forEach(opt => opt.classList.remove('selected'));
                document.querySelector(`#activationSelector .activation-option[data-act="${btn.dataset.act}"]`)?.classList.add('selected');
                
                updateUI();
            });
        });
        
        // Drag handles for layers (horizontal) and size (vertical)
        // Time-based: each tick changes value by 1
        // getLimits returns { canDecrease, canIncrease } to block movement at extremes
        setupDragHandle('layersHandle', 'horizontal', (delta) => {
            const change = delta > 0 ? 1 : -1;
            const newVal = Math.max(1, Math.min(4, network.numLayers + change));
            if (newVal !== network.numLayers) {
                network.numLayers = newVal;
                document.getElementById('numLayers').value = newVal;
                document.getElementById('numLayersValue').textContent = newVal;
                document.getElementById('networkLayersDisplay').textContent = newVal;
                reset();
            }
        }, () => ({
            canDecrease: network.numLayers > 1,  // Can't go below 1 layer
            canIncrease: network.numLayers < 4   // Can't go above 4 layers
        }));
        
        setupDragHandle('sizeHandle', 'vertical', (delta) => {
            // Vertical: negative delta (drag up) = increase size
            const change = delta > 0 ? -1 : 1;
            const newVal = Math.max(2, Math.min(16, network.hiddenSize + change));
            if (newVal !== network.hiddenSize) {
                network.hiddenSize = newVal;
                document.getElementById('hiddenSize').value = newVal;
                document.getElementById('hiddenSizeValue').textContent = newVal;
                document.getElementById('networkSizeDisplay').textContent = newVal;
                reset();
            }
        }, () => ({
            canDecrease: network.hiddenSize > 2,   // Can't go below 2 neurons
            canIncrease: network.hiddenSize < 16   // Can't go above 16 neurons
        }));
        
        // Drag handles for x-range
        // Time-based: each tick changes value by 0.2
        setupDragHandle('xMinHandle', 'horizontal', (delta) => {
            const change = delta > 0 ? 0.2 : -0.2;
            const newVal = config.xMin + change;
            const clampedVal = Math.max(-5, Math.min(config.xMax - 0.5, newVal));
            config.xMin = Math.round(clampedVal * 10) / 10;
            document.getElementById('xMin').value = config.xMin;
            document.getElementById('xMinLabel').textContent = config.xMin.toFixed(1);
            document.getElementById('xMinDisplay').textContent = config.xMin.toFixed(1);
            drawFitPlot();
        }, () => ({
            canDecrease: config.xMin > -5,              // Can't go below -5
            canIncrease: config.xMin < config.xMax - 0.5 // Can't overlap with xMax
        }));
        
        setupDragHandle('xMaxHandle', 'horizontal', (delta) => {
            const change = delta > 0 ? 0.2 : -0.2;
            const newVal = config.xMax + change;
            const clampedVal = Math.max(config.xMin + 0.5, Math.min(5, newVal));
            config.xMax = Math.round(clampedVal * 10) / 10;
            document.getElementById('xMax').value = config.xMax;
            document.getElementById('xMaxLabel').textContent = config.xMax.toFixed(1);
            document.getElementById('xMaxDisplay').textContent = config.xMax.toFixed(1);
            drawFitPlot();
        }, () => ({
            canDecrease: config.xMax > config.xMin + 0.5, // Can't overlap with xMin
            canIncrease: config.xMax < 5                   // Can't go above 5
        }));
        
        // Training Trace view handle - controls how much of the history to show
        setupDragHandle('traceViewHandle', 'horizontal', (delta) => {
            // Get total steps - works for both normal and comparison modes
            let totalSteps;
            const inCompMode = comparisonModeActive && savedRuns.A && savedRuns.B;
            if (inCompMode) {
                totalSteps = Math.max(
                    savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
                    savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
                );
            } else {
                totalSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
            }
            if (totalSteps < 10) return;
            
            // Each tick changes by ~5% of total steps
            const stepChange = Math.max(10, Math.floor(totalSteps * 0.05));
            const change = delta > 0 ? stepChange : -stepChange;
            
            if (traceViewEndStep === null) {
                traceViewEndStep = totalSteps;
            }
            
            traceViewEndStep = Math.max(100, Math.min(totalSteps, traceViewEndStep + change));
            drawTrainingTrace();
        }, () => {
            // Get total steps for bounds check
            let totalSteps;
            const inCompMode = comparisonModeActive && savedRuns.A && savedRuns.B;
            if (inCompMode) {
                totalSteps = Math.max(
                    savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
                    savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
                );
            } else {
                totalSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
            }
            return {
                canDecrease: traceViewEndStep === null || traceViewEndStep > 100,
                canIncrease: traceViewEndStep === null || traceViewEndStep < totalSteps
            };
        });
        
        // Update displays on init
        document.getElementById('networkLayersDisplay').textContent = network.numLayers;
        document.getElementById('networkSizeDisplay').textContent = network.hiddenSize;
        document.getElementById('xMinDisplay').textContent = config.xMin.toFixed(1);
        document.getElementById('xMaxDisplay').textContent = config.xMax.toFixed(1);
    }
    
    function setupDragHandle(elementId, direction, onDrag, getLimits) {
        const handle = document.getElementById(elementId);
        if (!handle) return;
        
        let startX, startY;
        let currentOffset = 0;
        let intervalId = null;
        const DEAD_ZONE = 10;  // pixels before triggering
        const INTERVAL_MS = 200;  // slower rate - 5 changes per second max
        const INCREMENT_PER_TICK = 15;  // pixels worth of change per tick
        
        const startInterval = () => {
            if (intervalId) return;
            intervalId = setInterval(() => {
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    // Check if we can move in this direction
                    const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                    const wantsIncrease = currentOffset > 0;
                    
                    // For vertical handles, up (negative offset) = increase
                    const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                    
                    if ((effectiveIncrease && limits.canIncrease) || (!effectiveIncrease && limits.canDecrease)) {
                        const sign = currentOffset > 0 ? 1 : -1;
                        onDrag(sign * INCREMENT_PER_TICK);
                    }
                }
            }, INTERVAL_MS);
        };
        
        const stopInterval = () => {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        };
        
        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            currentOffset = 0;
            
            // Disable transition during drag for immediate feedback
            handle.style.transition = 'none';
            
            const onMouseMove = (e) => {
                const rawOffset = direction === 'horizontal' ? (e.clientX - startX) : (e.clientY - startY);
                
                // Check limits and prevent visual displacement in blocked direction
                const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                const wantsIncrease = rawOffset > 0;
                const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                
                // Block displacement if at limit
                if (effectiveIncrease && !limits.canIncrease) {
                    currentOffset = direction === 'vertical' ? Math.max(0, rawOffset) : Math.min(0, rawOffset);
                } else if (!effectiveIncrease && !limits.canDecrease) {
                    currentOffset = direction === 'vertical' ? Math.min(0, rawOffset) : Math.max(0, rawOffset);
                } else {
                    currentOffset = rawOffset;
                }
                
                // Clamp visual offset to reasonable range (¬±20px)
                const clampedOffset = Math.max(-20, Math.min(20, currentOffset));
                
                // Visual feedback - move the handle
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = `translateX(calc(-50% + ${clampedOffset}px))`;
                    } else {
                        handle.style.transform = `translateX(${clampedOffset}px)`;
                    }
                } else {
                    handle.style.transform = `translateY(calc(-50% + ${clampedOffset}px))`;
                }
                
                // Start interval if displaced beyond dead zone
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    startInterval();
                } else {
                    stopInterval();
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                stopInterval();
                
                // Re-enable transition for rubberband effect
                handle.style.transition = 'transform 0.15s ease-out';
                
                // Rubberband back to original position
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = 'translateX(-50%)';
                    } else {
                        handle.style.transform = 'translateX(0)';
                    }
                } else {
                    handle.style.transform = 'translateY(-50%)';
                }
                
                currentOffset = 0;
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    // --------------- Init ----------------------------

    function init() {
        try {
            console.log('LearnCurve: initializing...');
            compileTargetFunc();
            initializeNetwork();
            setupControls();
            populateWeightSelectors();
            reset();
            console.log('LearnCurve: reset complete, drawing UI...');
            
            // Force initial draw of all UI components after reset
            requestAnimationFrame(() => {
                try {
                    drawNetwork();
                    drawFitPlot();
                    drawTrainingTrace();
                    updateEquations();
                    console.log('LearnCurve: initial draw complete');
                    
                    // Auto-compute loss surface
                    requestAnimationFrame(() => {
                        try {
                            autoSelectInterestingWeights();
                            computeLossSurface();
                            drawLossSurface();
                            console.log('LearnCurve: loss surface computed');
                        } catch(e) {
                            console.error('Loss surface error:', e);
                        }
                    });
                } catch(e) {
                    console.error('Initial draw error:', e);
                }
            });
        } catch(e) {
            console.error('Init error:', e);
        }
    }

    // Run init immediately since script is at end of body
    console.log('LearnCurve: starting init...');
    init();
</script>
</body>
</html>
