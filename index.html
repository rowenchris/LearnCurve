<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Interactive visualization of neural network learning. Watch a network learn to approximate any function in real-time.">
    <meta name="keywords" content="neural network, machine learning, deep learning, education, visualization, gradient descent">
    <title>LearnCurve - Interactive Neural Network Demo</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 16px;
            background: #f5f5f5;
            color: #333;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .container {
            max-width: 1700px;
            margin: 0 auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 10px 14px 14px 14px;
            min-height: calc(100vh - 20px);
            display: grid;
            grid-template-columns: 1fr 310px;
            gap: 16px;
            align-items: start;
        }

        #mainContent {
            grid-column: 1;
            grid-row: 1;
            min-width: 0;
        }
        
        #guideSidebar {
            grid-column: 2;
            grid-row: 1;
            position: sticky;
            top: 16px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.5;
        }

        h1 {
            font-size: 22px;
            margin: 0 0 8px 0;
        }

        .subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 16px;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 10px;
            width: 100%;
            min-width: 0;
        }
        
        .controls-strip {
            grid-column: 1 / -1;
        }
        
        .viz-grid {
            display: contents;
        }

        .panel {
            background: #fafafa;
            border-radius: 6px;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            min-width: 0;
            overflow: hidden;
        }

        .panel h2 {
            font-size: 14px;
            margin-bottom: 6px;
            color: #444;
            border-bottom: 2px solid #007bff;
            padding-bottom: 3px;
        }

        .panel h3 {
            font-size: 14px;
            margin: 6px 0;
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            font-size: 12px;
            min-width: 150px;
        }

        .control-group label {
            margin-bottom: 2px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 160px;
        }

        .control-group select,
        .control-group input[type="text"] {
            font-size: 13px;
            padding: 2px 4px;
        }

        .value {
            font-size: 11px;
            color: #777;
        }

        button {
            padding: 5px 9px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            opacity: 0.5;
            cursor: default;
        }

        #networkCanvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
        }

        canvas.chart {
            border: 1px solid #ddd;
            background: white;
            display: block;
            width: 100%;
            height: auto;
            touch-action: manipulation;  /* Better touch handling on mobile */
        }
        
        canvas {
            touch-action: manipulation;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
        }

        .stat-value {
            font-size: 13px;
            font-weight: bold;
        }

        .activation-selector {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .activation-option {
            font-size: 11px;
            padding: 3px 7px;
            border-radius: 999px;
            border: 1px solid #ccc;
            cursor: pointer;
            background: #fff;
        }

        .activation-option.selected {
            background: #007bff;
            color: #fff;
            border-color: #007bff;
        }

        .chart-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 6px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }

        /* ===== UNIFIED LABELED SLIDERS ===== */
        .labeled-slider {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            min-width: 0;
        }
        
        .labeled-slider .slider-label {
            font-weight: 600;
            color: #000;
            min-width: 38px;
            flex-shrink: 0;
        }
        
        .labeled-slider .slider-min,
        .labeled-slider .slider-max {
            font-size: 10px;
            color: #000;
            min-width: 14px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .labeled-slider .slider-track {
            position: relative;
            flex: 1 1 auto;
            min-width: 40px;
            height: 22px;
            display: flex;
            align-items: center;
        }
        
        .labeled-slider input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, #0d6efd 0%, #0d6efd var(--fill-percent, 50%), #ddd var(--fill-percent, 50%), #ddd 100%);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        .labeled-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 34px;
            height: 18px;
            background: #0d6efd;
            border-radius: 4px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .labeled-slider input[type="range"]::-moz-range-thumb {
            width: 34px;
            height: 18px;
            background: #0d6efd;
            border-radius: 4px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .labeled-slider input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
            background: #0b5ed7;
        }
        
        .labeled-slider .slider-value {
            position: absolute;
            top: 50%;
            left: var(--thumb-position, 50%);
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            pointer-events: none;
            text-shadow: 0 1px 1px rgba(0,0,0,0.4);
            z-index: 2;
            white-space: nowrap;
            line-height: 1;
        }
        
        /* Two-thumb range slider */
        .range-slider-container {
            position: relative;
            flex: 1;
            min-width: 80px;
            height: 24px;
        }
        
        .range-slider-container .range-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            transform: translateY(-50%);
            background: #ddd;
            border-radius: 3px;
        }
        
        .range-slider-container .range-fill {
            position: absolute;
            top: 50%;
            height: 6px;
            transform: translateY(-50%);
            background: #0d6efd;
            border-radius: 3px;
        }
        
        .range-slider-container input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 24px;
            transform: translateY(-50%);
            background: transparent;
            pointer-events: none;
            z-index: 2;
        }
        
        .range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 34px;
            height: 16px;
            background: #0d6efd;
            border-radius: 3px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .range-slider-container input[type="range"]::-moz-range-thumb {
            width: 34px;
            height: 16px;
            background: #0d6efd;
            border-radius: 3px;
            cursor: grab;
            border: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .range-slider-container .range-value {
            position: absolute;
            top: calc(50% + 2px);
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            pointer-events: none;
            text-shadow: 0 1px 1px rgba(0,0,0,0.4);
            z-index: 3;
            white-space: nowrap;
            width: 34px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        /* Slider control strip layout */
        .slider-controls-strip {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 24px;
            padding: 4px 10px;
            background: transparent;
            margin-top: 4px;
            align-items: center;
        }
        
        .slider-controls-strip .labeled-slider {
            flex: 1;
            min-width: 140px;
            max-width: none;
        }
        
        /* Network sliders - distribute across panel width */
        #networkSliders {
            justify-content: space-between;
            padding: 2px 0;
            margin-top: 12px;
            flex-wrap: nowrap;
        }
        
        #networkSliders .labeled-slider {
            flex: 1 1 45%;
            min-width: 120px;
            max-width: 49%;
        }
        
        /* Train range slider - centered label below, hide min/max (graph shows scale) */
        #trainRangeSliderStrip {
            flex: 1;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            gap: 0;
            /* Match canvas plot area: ~50px margin on each side of 520px canvas = 9.6% */
            /* Adjust for panel padding (6px) and canvas display scaling */
            padding: 0 calc(9.6% - 2px);
            margin-top: 0;
        }
        
        #trainRangeSliderStrip .labeled-slider {
            max-width: 100%;
            flex-direction: column;
            gap: 0;
        }
        
        #trainRangeSliderStrip .slider-min,
        #trainRangeSliderStrip .slider-max {
            display: none;
        }
        
        #trainRangeSliderStrip .range-slider-container {
            width: 100%;
            order: 1;
        }
        
        #trainRangeSliderStrip .slider-label {
            text-align: center;
            min-width: auto;
            order: 2;
            margin-top: 4px;
            color: #333;
            font-weight: bold;
            font-size: 10px;
        }
        
        /* View slider styling - bright blue like others */
        .labeled-slider.view-slider input[type="range"] {
            background: linear-gradient(to right, #0d6efd 0%, #0d6efd var(--fill-percent, 100%), #ddd var(--fill-percent, 100%), #ddd 100%);
        }
        
        .labeled-slider.view-slider input[type="range"]::-webkit-slider-thumb {
            background: #0d6efd;
        }
        
        .labeled-slider.view-slider input[type="range"]::-moz-range-thumb {
            background: linear-gradient(to bottom, #28a745, #1e7e34);
        }
        
        /* Disabled state */
        .labeled-slider.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        /* Mobile touch targets */
        @media (max-width: 768px) {
            .labeled-slider input[type="range"]::-webkit-slider-thumb {
                width: 36px;
                height: 28px;
            }
            .labeled-slider input[type="range"]::-moz-range-thumb {
                width: 36px;
                height: 28px;
            }
            .range-slider-container input[type="range"]::-webkit-slider-thumb {
                width: 40px;
                height: 24px;
            }
            .range-slider-container input[type="range"]::-moz-range-thumb {
                width: 40px;
                height: 24px;
            }
            .slider-controls-strip {
                gap: 8px 12px;
            }
            .slider-controls-strip .labeled-slider {
                min-width: 120px;
            }
        }
        /* ===== END UNIFIED SLIDERS ===== */

        .equations-panel {
            grid-column: 1 / -1;  /* Span all columns */
            flex: 1;  /* Fill remaining height */
            display: flex;
            flex-direction: column;
        }
        
        .equations-panel h2 {
            margin-bottom: 4px;
            flex-shrink: 0;
        }
        
        .equations {
            font-size: 11px;
            line-height: 1.3;
            flex: 1;
            min-height: 150px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;  /* 2 columns: Forward | Backward */
            gap: 12px;
        }

        .equation-block {
            padding: 4px 6px;
        }

        .equation-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .math {
            font-family: "Courier New", monospace;
            color: #333;
            font-size: 13px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #777;
            margin-bottom: 2px;
        }

        /* Tablet and smaller - single column layout */
        @media (max-width: 900px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
                max-width: 100%;
                grid-template-columns: 1fr 220px;
            }
            #guideSidebar {
                font-size: 9px;
                width: 220px;
            }
            .grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            h1 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
            }
            .control-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .control-group {
                flex-wrap: wrap;
            }
            .equations-panel {
                grid-column: 1;  /* Single column on mobile */
            }
            .equations {
                grid-template-columns: 1fr 1fr;  /* 2 columns on tablet */
                font-size: 12px;
                max-height: 220px;
            }
        }
        
        /* Tablet portrait - sidebar moves to bottom */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
            }
            #mainContent {
                grid-row: 1;
            }
            #guideSidebar {
                grid-column: 1;
                grid-row: 2;
                width: 100%;
                max-width: 100%;
                max-height: none;
                position: static;
                margin-top: 16px;
                font-size: 11px;
            }
            #guideSidebar h3 {
                font-size: 15px;
            }
            #guideSidebar h4 {
                font-size: 13px;
            }
            #guideToggle {
                display: none;
            }
            /* Phase panel controls should stack */
            #phase1Panel > div, #phase2Panel > div {
                flex-wrap: wrap;
            }
            /* Smaller fonts for cramped controls */
            #phase1Panel, #phase2Panel, #phase3Panel {
                font-size: 11px;
            }
            #phase1Panel label, #phase2Panel label {
                font-size: 10px;
            }
        }
        
        /* iPhone and small mobile */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            .container {
                padding: 8px;
                max-width: 100%;
                overflow-x: hidden;
                grid-template-columns: 1fr;
            }
            #guideSidebar {
                font-size: 10px;
                padding: 10px;
                max-height: none;
            }
            #guideSidebar h3 {
                font-size: 14px;
            }
            #guideSidebar h4 {
                font-size: 12px;
            }
            h1 {
                font-size: 18px;
            }
            .subtitle {
                font-size: 11px;
                line-height: 1.4;
            }
            .panel {
                padding: 8px;
                overflow-x: auto;
            }
            .panel h2 {
                font-size: 14px;
            }
            #networkCanvas {
                max-width: 100%;
                height: auto;
            }
            canvas.chart {
                max-width: 100%;
                height: auto;
            }
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                width: 100%;
            }
            .control-group input[type="range"] {
                width: 100%;
            }
            .control-group select {
                width: 100%;
            }
            .stats {
                flex-direction: column;
                gap: 4px;
                align-items: flex-start;
            }
            button {
                padding: 8px 12px;
                font-size: 13px;
            }
            .chart-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            .checkbox-group {
                font-size: 12px;
            }
            .equations {
                grid-template-columns: 1fr;  /* Single column on small screens */
                font-size: 11px;
                max-height: 250px;
            }
            /* Old drag handles are now hidden everywhere - replaced by unified sliders */
            /* Mobile slider controls now use same unified sliders as desktop */
            /* Make activation buttons stack */
            #networkActivation {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            #networkActivation > div {
                flex-wrap: wrap;
            }
        }
    </style>
    <!-- GIF library for capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
</head>
<body>
<div class="container">
    <!-- Main Content Area -->
    <div id="mainContent" style="display:flex; flex-direction:column;">
        <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:6px;">
            <div>
                <h1 style="margin-bottom:2px;">LearnCurve</h1>
                <p style="margin:0; font-size:11px; color:#666;">An interactive tool for understanding how neural networks learn. ¬© 2025 Chris Rowen ‚Äî <a href="https://opensource.org/licenses/MIT" style="color:#007bff; text-decoration:none;">MIT License</a></p>
            </div>
            <button id="guideToggle" style="padding:4px 10px; font-size:11px; background:#138496; border:none; border-radius:4px; color:white; cursor:pointer; white-space:nowrap;" title="Show/hide learning guide">Hide Guide ‚óÄ</button>
        </div>

        <div class="grid">
        <!-- PHASE 1: CREATE TRAINING DATA - spans full width -->
        <div class="panel controls-strip" id="phase1Panel" style="padding:8px 12px; border-left:4px solid #28a745;">
            <div id="phase1Header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                <div style="display:flex; align-items:center; gap:8px;">
                    <span style="font-size:12px; font-weight:bold; color:#28a745;">‚ë† CREATE TRAINING DATA</span>
                    <button id="toggleRecipeBtn" style="padding:4px 12px; font-size:11px; background:#28a745; font-weight:bold; display:none;" title="Edit data recipe and regenerate">‚úèÔ∏è Edit Recipe</button>
                </div>
                <span id="dataStatus" style="font-size:10px; color:#555;">Define a data recipe, then generate training data</span>
            </div>
            
            <!-- Recipe Controls - single row -->
            <div id="recipeControls" style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:5px 8px; background:#f8f9fa; border-radius:4px;">
                <!-- Data Recipe -->
                <div style="display:flex; align-items:center; gap:4px;">
                    <label style="font-size:11px; font-weight:600;">Recipe:</label>
                    <input type="text" id="targetFuncInput" value="sin(x)" style="width:90px; font-size:11px; padding:3px 5px;" title="Formula for generating data" />
                </div>
                
                <!-- Data Range -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">x:</label>
                    <input type="number" id="dataXMinInput" value="-3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                    <span style="font-size:9px;">to</span>
                    <input type="number" id="dataXMaxInput" value="3" step="0.5" style="width:38px; font-size:10px; padding:2px;">
                </div>
                
                <!-- Count -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Total number of data points to generate">Samples:</label>
                    <input type="range" id="totalSamples" min="20" max="500" step="10" value="100" style="width:80px;">
                    <span class="value" id="totalSamplesValue" style="font-size:10px; min-width:24px;">100</span>
                </div>
                
                <!-- Noise -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;" title="Noise level - random variation added to y values">Noise:</label>
                    <input type="range" id="noise" min="0" max="1" step="0.01" value="0.02" style="width:80px;">
                    <span class="value" id="noiseValue" style="font-size:10px; min-width:24px;">0.02</span>
                </div>
                
                <!-- Generate Button -->
                <button id="generateDataBtn" style="padding:5px 12px; font-size:11px; background:#28a745; font-weight:bold;">üé≤ Generate</button>
            </div>
            
            <!-- Data Summary (accordion, collapsed by default after generation) -->
            <div id="dataSummary" style="display:none; background:#f0f8f0; border:1px solid #c3e6c3; border-radius:4px;">
                <!-- Summary header (always visible) -->
                <div id="dataSummaryHeader" style="display:flex; align-items:center; gap:8px; padding:4px 10px; cursor:pointer;" title="Click to show/hide data preview">
                    <span id="dataSummaryToggle" style="font-size:10px; color:#28a745;">‚ñ∂</span>
                    <span style="font-size:10px; color:#28a745; font-weight:bold;">‚úì Data Ready:</span>
                    <span style="font-size:10px; color:#333;"><span id="trainCount">80</span> training, <span id="testCount">20</span> held-out</span>
                    <span id="dataSummaryNote" style="flex:1; font-size:10px; color:#444; font-style:italic;"></span>
                    <button id="newDataBtn" style="padding:2px 6px; font-size:9px; background:#6c757d;" title="Generate new random data">‚Üª New</button>
                </div>
                <!-- Expandable data preview -->
                <div id="dataSummaryContent" style="display:none; padding:4px 10px 6px 10px; border-top:1px solid #c3e6c3;">
                    <div style="display:flex; align-items:flex-start; gap:12px;">
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#007bff; margin-bottom:2px;">üìä Training Points</div>
                            <div id="trainDataPreview" style="font-size:9px; font-family:monospace; color:#333; background:#fff; padding:2px 4px; border-radius:2px; border:1px solid #ddd; line-height:1.3;"></div>
                        </div>
                        <div style="min-width:140px;">
                            <div style="font-size:10px; font-weight:bold; color:#ff9800; margin-bottom:2px;">üîí Held-Out Points</div>
                            <div id="testDataPreview" style="font-size:9px; font-family:monospace; color:#666; background:#fafafa; padding:2px 4px; border-radius:2px; border:1px solid #eee; line-height:1.3;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Hidden elements for compatibility -->
            <span id="trainRangeLabel" style="display:none;"></span>
            <span id="testRangeInfo" style="display:none;"></span>
        </div>
        
        <!-- PHASE 2: TRAIN THE MODEL - spans full width -->
        <div class="panel controls-strip" id="phase2Panel" style="padding:6px 12px; border-left:4px solid #007bff; opacity:0.5; pointer-events:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <span style="font-size:12px; font-weight:bold; color:#007bff;">‚ë° TRAIN THE MODEL</span>
                <span id="epochStatus" style="font-size:10px; color:#555;">Generate examples first...</span>
            </div>
            <!-- Row 1: Network and training parameters -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:4px;">
                <!-- Learning Rate -->
                <div style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Learning Rate (Œ∑):</label>
                    <input type="range" id="learningRate" min="-3" max="-0.3" step="0.01" value="-1" style="width:50px;">
                    <span class="value" id="learningRateValue" style="font-size:10px; min-width:32px;">0.100</span>
                </div>
                
                <!-- Optimizer -->
                <div id="optimizerButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Optimizer:</label>
                    <button class="opt-btn" data-opt="sgd" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer;" title="Simple Gradient Descent&#10;&#10;w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw&#10;&#10;Each weight moves opposite to its gradient, proportional to learning rate Œ∑.&#10;&#10;Recommended learning rate: 0.05-0.2&#10;Simple but can be slow or oscillate.">Simple</button>
                    <button class="opt-btn" data-opt="adam" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer;" title="Adam Optimizer&#10;&#10;Combines two ideas:&#10;‚Ä¢ Momentum: smooth out noisy gradients&#10;‚Ä¢ Adaptive rates: bigger steps for rare gradients&#10;&#10;Recommended learning rate: 0.001-0.02&#10;(Lower than Simple because Adam amplifies updates)&#10;&#10;Usually learns faster and more reliably.">Adam</button>
                </div>
                
                <!-- Activation œÉ -->
                <div id="activationButtons" style="display:flex; align-items:center; gap:3px;">
                    <label style="font-size:10px; color:#333;">Activation (œÉ):</label>
                    <button class="act-btn" data-act="relu" style="padding:2px 6px; font-size:10px; border:2px solid #007bff; background:#007bff; color:white; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="14" height="10" viewBox="0 0 20 14"><path d="M1 10 L10 10 L19 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>ReLU
                    </button>
                    <button class="act-btn" data-act="sigmoid" style="padding:2px 6px; font-size:10px; border:2px solid #ccc; background:#fff; color:#333; border-radius:3px; cursor:pointer; display:flex; align-items:center; gap:2px;">
                        <svg width="16" height="10" viewBox="0 0 24 14"><path d="M1 12 L4 12 Q8 12 12 7 Q16 2 20 2 L23 2" stroke="currentColor" stroke-width="2" fill="none"/></svg>Sigmoid
                    </button>
                </div>
                
                <span style="color:#ddd;">|</span>
                
                <!-- Stats -->
                <span style="font-size:11px; color:#28a745;">Train Error: <strong id="trainLossValue">‚Äî</strong></span>
                <span style="font-size:11px; color:#007bff;"><span id="stepsPerSec">‚Äî</span> steps/sec</span>
                <span style="color:#ddd;">|</span>
                <span style="font-size:10px; color:#555;" title="Arithmetic operations this training run">
                    Ops: <span style="color:#28a745;" id="totalAddsDisplay">0</span>+ <span style="color:#dc3545;" id="totalMulsDisplay">0</span>√ó = <strong id="totalOpsDisplay" style="color:#6f42c1;">0</strong>
                </span>
            </div>
            <!-- Hidden elements for backwards compatibility -->
            <span id="epochCount" style="display:none;">0</span>
            <span id="stepCount" style="display:none;">0</span>
            <span id="stepsPerEpoch" style="display:none;">80</span>
            
            <!-- Row 2: Training action buttons -->
            <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <!-- Training buttons -->
                <button id="stepBtn" style="padding:4px 10px; font-size:11px;" title="Train one step (process one training example)">Step</button>
                <button id="runEpochBtn" style="padding:4px 10px; font-size:11px; background:#17a2b8;" title="Run one epoch = process ALL training examples once">Run Epoch</button>
                <button id="runBtn" style="padding:4px 10px; font-size:11px;" title="Run continuous training until stopped">Run</button>
                <button id="restartBtn" style="padding:4px 8px; font-size:10px; background:#6c757d; color:#fff;" title="Restart training from initial position (keeps loss surface)">Reset Training</button>
                <button id="resetModelBtn" style="padding:4px 8px; font-size:10px; background:#ffc107; color:#333;" title="Re-initialize with new random weights (recomputes surface)">Reset Model</button>
                <button id="gifBtn" style="padding:4px 8px; font-size:10px;">Capture</button>
            </div>
            
            <!-- Hidden elements for backwards compatibility -->
            <input type="range" id="xMin" min="-5" max="0" step="0.1" value="-2" style="display:none;">
            <input type="range" id="xMax" min="0" max="5" step="0.1" value="2" style="display:none;">
            <span id="xMinLabel" style="display:none;">-2</span>
            <span id="xMaxLabel" style="display:none;">2</span>
            <span id="runALabel" style="display:none;"></span>
            <span id="runBLabel" style="display:none;"></span>
            <span id="totalAdds" style="display:none;">0</span>
            <span id="totalMuls" style="display:none;">0</span>
            <span id="opsLossAdd" style="display:none">0</span>
            <span id="opsLossMul" style="display:none">0</span>
            <span id="lossValue" style="display:none;">‚Äî</span>
            <button id="resetBtn" style="display:none;">Reset</button>
            <div class="activation-selector" id="activationSelector" style="display:none;">
                <span class="activation-option selected" data-act="relu">ReLU</span>
                <span class="activation-option" data-act="sigmoid">sigmoid</span>
            </div>
            <span id="numLayersValue" style="display:none;">1</span>
            <span id="hiddenSizeValue" style="display:none;">3</span>
        </div>

        <!-- 2x2 VISUALIZATION GRID -->
        <!-- Top Left: Network Design -->
        <div class="panel" style="padding:6px 6px 24px 6px; overflow:visible !important;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Network Design</h2>
                <div id="opsTableHtml" style="font-size:10px; background:#f8f9ff; border:1px solid #007bff; border-radius:3px; padding:2px 6px;">
                    <span style="color:#28a745;">Fwd:</span><span id="opsFwdAdds">0</span>+ <span id="opsFwdMuls">0</span>√ó
                    <span style="color:#dc3545; margin-left:4px;">Back:</span><span id="opsBackAdds">0</span>+ <span id="opsBackMuls">0</span>√ó
                </div>
            </div>
            <div>
                <canvas id="networkCanvas" width="520" height="280" style="width:100%;"></canvas>
            </div>
            <!-- Unified Network Sliders -->
            <div class="slider-controls-strip" id="networkSliders">
                <div class="labeled-slider" title="Number of hidden layers">
                    <span class="slider-label">Layers</span>
                    <span class="slider-min">1</span>
                    <div class="slider-track">
                        <input type="range" id="layersSlider" min="1" max="4" step="1" value="1">
                        <span class="slider-value" id="layersValue">1</span>
                    </div>
                    <span class="slider-max">4</span>
                </div>
                <div class="labeled-slider" title="Neurons per hidden layer">
                    <span class="slider-label">Width</span>
                    <span class="slider-min">1</span>
                    <div class="slider-track">
                        <input type="range" id="widthSlider" min="1" max="16" step="1" value="3">
                        <span class="slider-value" id="widthValue">3</span>
                    </div>
                    <span class="slider-max">16</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="sizeHandle" style="display:none;"></div>
            <div id="layersHandle" style="display:none;"></div>
            <div id="networkMobileControls" style="display:none;"></div>
            <span id="networkLayersDisplay" style="display:none;">1</span>
            <span id="networkSizeDisplay" style="display:none;">3</span>
            <div id="networkActivation" style="display:none;"></div>
        </div>

        <!-- Top Right: Fit Plot -->
        <div class="panel" style="padding:6px; display:flex; flex-direction:column;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Examples vs Model</h2>
                <div id="revealControls" style="display:flex; gap:6px; font-size:10px; opacity:0.5; pointer-events:none;">
                    <label style="display:flex; align-items:center; gap:2px; cursor:pointer;" title="Show held-out examples">
                        <input type="checkbox" id="showHeldOut"> Held-Out
                    </label>
                    <label style="display:flex; align-items:center; gap:2px; cursor:pointer;" title="Show original recipe curve">
                        <input type="checkbox" id="showRecipe"> Recipe
                    </label>
                </div>
            </div>
            <div>
                <canvas id="fitCanvas" class="chart" width="520" height="280" style="width:100%;"></canvas>
            </div>
            <!-- Unified Train Range Slider -->
            <div class="slider-controls-strip" id="trainRangeSliderStrip" style="opacity:0.5; pointer-events:none;">
                <div class="labeled-slider" style="flex:1; max-width:100%;" title="Restrict training data to this x-range. Points outside test extrapolation.">
                    <span class="slider-label">Training Range</span>
                    <span class="slider-min" id="trainRangeMinLabel">-3</span>
                    <div class="range-slider-container" id="trainRangeContainer">
                        <div class="range-track"></div>
                        <div class="range-fill" id="trainRangeFill"></div>
                        <input type="range" id="trainMinSlider" min="-3" max="3" step="0.1" value="-2.8">
                        <input type="range" id="trainMaxSlider" min="-3" max="3" step="0.1" value="2.8">
                        <span class="range-value" id="trainMinValue" style="left:25%;">-2</span>
                        <span class="range-value" id="trainMaxValue" style="left:75%;">2</span>
                    </div>
                    <span class="slider-max" id="trainRangeMaxLabel">3</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="trainMinHandle" style="display:none;"></div>
            <div id="trainMaxHandle" style="display:none;"></div>
            <div id="trainRangeControls" style="display:none;"></div>
            <div id="trainRangeMobileControls" style="display:none;"></div>
            <input type="number" id="trainXMinInput" value="-2.8" style="display:none;">
            <input type="number" id="trainXMaxInput" value="2.8" style="display:none;">
            <span id="xMinDisplay" style="display:none;">-2.0</span>
            <span id="xMaxDisplay" style="display:none;">2.0</span>
            <span id="trainPointCount" style="display:none;">‚Äî</span>
        </div>

        <!-- Bottom Left: Training Trace -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:3px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Training Trace</h2>
                <div style="display:flex; gap:5px; font-size:10px; align-items:center; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:1px;" title="Show error curve"><input type="checkbox" id="traceLoss" checked>Error</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Show weight trajectories"><input type="checkbox" id="traceWeights" checked>Weights</label>
                    <label style="display:flex; align-items:center; gap:1px;" title="Logarithmic scale"><input type="checkbox" id="traceLogScale">Log</label>
                    <span style="color:#ddd;">|</span>
                    <label style="display:flex; align-items:center; gap:1px;" title="Rolling average error"><input type="checkbox" id="traceAvgLoss" checked>Average</label>
                    <input type="range" id="avgWindowSlider" min="10" max="1000" step="10" value="100" style="width:35px;" title="Averaging window size"><span id="avgWindowValue" style="color:#007bff; min-width:22px;">100</span>
                    <span style="color:#ddd;">|</span>
                    <span style="white-space:nowrap;" title="Error change from start to now">ŒîError:<strong id="deltaLossValue" style="color:#28a745; min-width:45px;">‚Äî</strong></span>
                </div>
            </div>
            <div>
                <canvas id="traceCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
            </div>
            <!-- Unified View Slider -->
            <div class="slider-controls-strip" id="viewSliderStrip" style="opacity:0.5; pointer-events:none;">
                <div class="labeled-slider view-slider" style="flex:1; max-width:300px;" title="Show training steps from 0 to this value. Slide left to focus on initial convergence.">
                    <span class="slider-label" style="min-width:35px;">View</span>
                    <span class="slider-min">10</span>
                    <div class="slider-track">
                        <input type="range" id="viewSlider" min="10" max="1000" step="10" value="1000">
                        <span class="slider-value" id="viewValue">All</span>
                    </div>
                    <span class="slider-max">All</span>
                </div>
            </div>
            <!-- Hidden elements for backward compatibility -->
            <div id="traceViewHandle" style="display:none;"></div>
            <div id="zoomMobileControls" style="display:none;"></div>
        </div>

        <!-- Bottom Right: Error Landscape -->
        <div class="panel" style="padding:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px; flex-wrap:wrap; gap:4px;">
                <h2 style="margin:0; font-size:13px; border:none; padding:0;">Error Landscape</h2>
                <div style="display:flex; gap:3px; font-size:10px; align-items:center;">
                    <span id="weightSelectContainer" style="display:flex; gap:2px; align-items:center; opacity:0.5;" title="Click to manually select weights">
                        <select id="weightXSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="0">w‚ÇÅ</option></select>
                        <span style="font-size:9px;">vs</span>
                        <select id="weightYSelect" style="font-size:9px; padding:1px; max-width:70px;"><option value="1">w‚ÇÇ</option></select>
                    </span>
                    <button id="autoSelectBtn" style="font-size:10px; padding:1px 4px; background:#007bff; border:2px solid #007bff; color:white;" title="Auto-select interesting weights">Auto</button>
                </div>
            </div>
            <div>
                <canvas id="lossCanvas" class="chart" width="520" height="340" style="width:100%;"></canvas>
            </div>
            <div id="lossLegend" style="font-size:9px; color:#333; font-weight:500; text-align:center; margin-top:2px;">üü¢ Start üî¥ Current ‚Ä¢ <span style="background:linear-gradient(to right, #00f, #0aa, #0a0, #aa0, #f00); padding:1px 20px; border-radius:2px; margin-right:8px;"></span>Error: <span id="lossScaleMin">low</span> ‚Üí <span id="lossScaleMax">high</span></div>
        </div>
    </div>
    
    <!-- STEP 3: EVALUATE - spans full width -->
    <div class="panel controls-strip" id="phase3Panel" style="padding:6px 12px; border-left:4px solid #ff9800; opacity:0.5; pointer-events:none; margin-top:10px;">
        <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center;">
            <span style="font-size:12px; font-weight:bold; color:#ff9800;">‚ë¢ EVALUATE & COMPARE</span>
            
            <button id="evaluateBtn" style="padding:5px 14px; font-size:11px; background:#ff9800; font-weight:bold;" title="Test model on held-out data to measure generalization">üîç Evaluate on Held-Out</button>
            
            <span id="evalResults" style="font-size:10px; color:#555; display:none;"></span>
            
            <span style="color:#ddd;">|</span>
            
            <button id="saveRunA" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run A</button>
            <button id="saveRunB" style="padding:4px 10px; font-size:10px; background:#6c757d;">Save as Run B</button>
            <button id="compareBtn" style="padding:4px 10px; font-size:10px; background:#6c757d;" disabled>Compare A vs B</button>
        </div>
    </div>
    
    <!-- THE MATH - spans full width, collapsible -->
    <div class="panel equations-panel" style="padding:6px 10px; margin-top:10px;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="equationsHeader">
            <h2 style="margin:0; font-size:13px; border:none; padding:0;">üìê Equations</h2>
            <button id="toggleEquationsBtn" style="padding:2px 8px; font-size:10px; background:#6c757d;">‚ñº Collapse</button>
        </div>
        <div class="equations" id="equationsDiv" style="margin-top:6px;"></div>
    </div>
    </div><!-- end main content -->
    
    <!-- Learning Guide Sidebar -->
    <div id="guideSidebar" style="background:#f8f9fa; border:1px solid #dee2e6; border-radius:6px; padding:12px 14px;">
        <div style="margin-bottom:8px; border-bottom:2px solid #17a2b8; padding-bottom:4px;">
            <span style="font-size:16px; font-weight:bold; color:#17a2b8;">üìñ How Neural Networks Learn</span>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Big Picture</h4>
        <p style="margin:0 0 6px 0;">We use <strong>machine learning</strong> to build equations that serve as <strong>predictive models</strong>‚Äîestimating the next word in a composition or identifying objects in a picture. You have <strong>data</strong> representing typical inputs and desired outputs, but don't know the <strong>pattern</strong>. A <strong>neural network</strong> finds a <strong>function that fits</strong> the data‚Äîlike recreating a curve from scattered dots, but for arbitrarily complex functions.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Three Phases</h4>
        <p style="margin:0 0 3px 0;"><span style="color:#28a745; font-weight:bold;">‚ë†</span> <strong>Create Data</strong> ‚Äî Generate examples from a hidden "recipe."</p>
        <p style="margin:0 0 3px 0;"><span style="color:#007bff; font-weight:bold;">‚ë°</span> <strong>Train</strong> ‚Äî Measure error, adjust parameters, repeat.</p>
        <p style="margin:0 0 6px 0;"><span style="color:#6f42c1; font-weight:bold;">‚ë¢</span> <strong>Evaluate</strong> ‚Äî Test on held-out data to verify learning.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Key Terms</h4>
        <div style="font-size:12px; line-height:1.4;">
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Data Recipe</strong> ‚Äî Function that generates data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Training Data</strong> ‚Äî Examples the model learns from</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Held-Out Data</strong> ‚Äî Reserved to test real learning</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#007bff;">Noise</strong> ‚Äî Random variation (real data is messy)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Step</strong> ‚Äî Update from one example</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Epoch</strong> ‚Äî Full pass through training data</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Error (E)</strong> ‚Äî Prediction error (lower = better)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Learning Rate (Œ∑)</strong> ‚Äî Step size for updates</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#28a745;">Activation (œÉ)</strong> ‚Äî Nonlinear function (ReLU/Sigmoid)</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Weights (w)</strong> ‚Äî Multipliers on connections</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Biases (b<sub>ij</sub>, b)</strong> ‚Äî Offset added at each neuron</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#6f42c1;">Gradient (‚àÇE/‚àÇw)</strong> ‚Äî Steepest uphill direction</p>
            <p style="margin:0 0 2px 0;"><strong style="color:#dc3545;">Overfitting</strong> ‚Äî Memorizing instead of learning</p>
            <p style="margin:0 0 6px 0;"><strong style="color:#dc3545;">Extrapolation</strong> ‚Äî Predicting outside training range</p>
        </div>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">The Math</h4>
        <p style="margin:0 0 3px 0;"><strong>Forward:</strong> z = w¬∑x + b ‚Üí h = œÉ(z) ‚Üí y</p>
        <p style="margin:0 0 3px 0;"><strong>Error:</strong> E = ¬Ω(y ‚àí t)¬≤ where t = target</p>
        <p style="margin:0 0 3px 0;"><strong>Backward:</strong> Chain rule finds ‚àÇE/‚àÇw</p>
        <p style="margin:0 0 3px 0; font-size:11px; color:#666; font-style:italic; padding-left:6px;">‚àÇ[f(g(x))]/‚àÇx = f'(g(x)) ¬∑ g'(x)</p>
        <p style="margin:0 0 6px 0;"><strong>Update:</strong> w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw (downhill step)</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Optimizers</h4>
        <p style="margin:0 0 3px 0;"><strong>Simple (SGD)</strong> ‚Äî w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw</p>
        <p style="margin:0 0 6px 0;"><strong>Adam</strong> ‚Äî Adapts Œ∑ per-weight. Usually faster.</p>
        
        <h4 style="margin:0 0 4px 0; color:#333; font-size:14px; border-bottom:1px solid #ddd; padding-bottom:2px;">Try These</h4>
        <p style="margin:0 0 2px 0;">üìà <strong>Simple:</strong> <code>x</code>, <code>x^2</code>, <code>x^3-3*x</code></p>
        <p style="margin:0 0 2px 0;">üåä <strong>Waves:</strong> <code>sin(x)</code>, <code>sin(x)+sin(3*x)</code></p>
        <p style="margin:0 0 2px 0;">üìê <strong>Sharp:</strong> <code>abs(x)</code>, <code>sign(x)</code>, <code>floor(x)</code></p>
        <p style="margin:0 0 2px 0;">üî¨ Restrict training range ‚Üí extrapolation fails</p>
        <p style="margin:0 0 2px 0;">‚ö° Compare SGD vs Adam</p>
        <p style="margin:0;">üìä Increase noise ‚Üí learning breaks down</p>
        
        <div style="margin-top:8px; padding-top:6px; border-top:1px solid #ddd; font-size:12px; color:#888; text-align:center;">
            üí° <em>ML = adjusting w to minimize E!</em>
        </div>
    </div>
</div><!-- end container -->

<script>
    // ---------------- Config & State ----------------

    let config = {
        learningRate: 0.1,
        activation: 'relu',
        // Data generation range (full range)
        dataXMin: -3,
        dataXMax: 3,
        // Training range (can be subset of data range) - default to ~95% of data range
        trainXMin: -2.8,
        trainXMax: 2.8,
        // Legacy compatibility
        xMin: -3,
        xMax: 3,
        noise: 0.02,
        targetFunc: null,
        targetFuncStr: 'sin(x)',
        optimizer: 'sgd',
        avgWindow: 100,
        // Dataset configuration
        totalSamples: 100,      // Total number of samples to generate
        trainTestSplit: 0.8,    // 80% train, 20% test
        testEvalInterval: 10    // Legacy - test loss now evaluated at epoch boundaries
    };

    // Training dataset - fixed points generated from target function
    let dataset = {
        generated: false,       // Has data been generated?
        allTrain: [],           // All training points (full data range)
        allTest: [],            // All test points (full data range)
        train: [],              // Training points within trainXMin..trainXMax
        test: [],               // Test points (all held-out, for evaluation)
        epoch: 0,               // Current epoch number
        stepInEpoch: 0,         // Current step within epoch
        shuffleOrder: [],       // Randomized order for current epoch
        totalEpochs: 0          // Total epochs completed
    };
    
    // Reveal controls for assessment
    let revealOptions = {
        showHeldOut: false,     // Show held-out (test) examples
        showRecipe: false,      // Show original data recipe curve
        evaluated: false        // Has evaluation been run?
    };
    
    // Evaluation results
    let evaluationResults = {
        testLossInRange: null,    // MSE for test points within training range
        testLossOutRange: null,   // MSE for test points outside training range
        testLossTotal: null,      // Total test MSE
        pointsInRange: 0,
        pointsOutRange: 0
    };
    
    // Loss landscape color scale calibration
    // Calibrated at start of training for consistent colors throughout the run
    let lossColorScale = {
        calibrated: false,
        minLoss: 0.0001,    // Best expected loss (blue)
        maxLoss: 10         // Worst expected loss (red)
    };
    
    // Trace view state - controls which steps are visible
    let traceViewState = {
        maxStep: Infinity   // Show steps 0 to this value, Infinity = show all
    };

    let network = {
        numLayers: 1,
        hiddenSize: 3,
        weights: [],
        biases: []
    };

    let grads = {
        weights: [],
        biases: []
    };
    
    // Pre-allocated arrays for backward pass (avoids allocations in hot loop)
    let backwardCache = {
        deltaNext: null,
        deltaPrev: null,
        delta: null,
        actPrime: null  // Cached activation derivative
    };

    let history = {
        steps: [],
        loss: [],           // Training loss per step
        testLoss: [],       // Test loss evaluated periodically [{step, loss}, ...]
        avgLoss: [],
        weights: []
    };

    let trainingState = {
        running: false,
        animating: false,
        step: 0,
        totalAdds: 0,
        totalMuls: 0,
        lastUpdateTime: performance.now(),
        stepsSinceLastUpdate: 0,
        recentSamples: []
    };
    
    // Old variable - now replaced by traceViewState.maxStep
    // let traceViewEndStep = null;

    let gifCapture = {
        recording: false,
        gif: null,
        framesRemaining: 0
    };
    
    // Embedded gif.worker.js to avoid CORS issues (from gif.js 0.2.0)
    const gifWorkerCode = `(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);`;
    
    // Create Blob URL for worker (avoids CORS issues)
    const gifWorkerBlob = new Blob([gifWorkerCode], { type: 'application/javascript' });
    const gifWorkerUrl = URL.createObjectURL(gifWorkerBlob);

    let optimizerState = {
        m: [],
        v: [],
        r: [],
        t: 0
    };

    let savedRuns = {
        A: null,
        B: null
    };

    let comparisonModeActive = false;

    function exitComparisonMode() {
        if (!comparisonModeActive) return;
        comparisonModeActive = false;
        const compareBtn = document.getElementById('compareBtn');
        if (compareBtn && savedRuns.A && savedRuns.B) {
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
            compareBtn.textContent = 'Compare A vs B';
        }
    }

    const activationFns = {
        relu: {
            fn: (z) => Math.max(0, z),
            dfn: (z) => z > 0 ? 1 : 0
        },
        tanh: {
            fn: (z) => Math.tanh(z),
            dfn: (z) => {
                const t = Math.tanh(z);
                return 1 - t * t;
            }
        },
        sigmoid: {
            fn: (z) => 1 / (1 + Math.exp(-z)),
            dfn: (z) => {
                const s = 1 / (1 + Math.exp(-z));
                return s * (1 - s);
            }
        }
    };

    // --------------- Utility Functions ---------------
    
    // Fix fuzzy text on HiDPI displays
    function setupHiDPICanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return ctx;
    }

    function gaussianNoise(mean=0, std=1) {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const n = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + std * n;
    }
    
    // Generate nice round tick values for axes
    function getNiceTicks(min, max, targetCount = 5) {
        const range = max - min;
        if (range <= 0) return [min];
        
        // Find a nice step size
        const roughStep = range / targetCount;
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const normalized = roughStep / magnitude;
        
        let niceStep;
        if (normalized <= 1) niceStep = magnitude;
        else if (normalized <= 2) niceStep = 2 * magnitude;
        else if (normalized <= 5) niceStep = 5 * magnitude;
        else niceStep = 10 * magnitude;
        
        // Generate ticks
        const ticks = [];
        const start = Math.ceil(min / niceStep) * niceStep;
        for (let tick = start; tick <= max; tick += niceStep) {
            ticks.push(tick);
        }
        
        // Ensure we have at least start and end
        if (ticks.length === 0 || ticks[0] > min) ticks.unshift(Math.floor(min / niceStep) * niceStep);
        if (ticks[ticks.length - 1] < max) ticks.push(Math.ceil(max / niceStep) * niceStep);
        
        return ticks;
    }
    
    // Generate nice tick values for log scale (powers of 10)
    function getLogTicks(logMin, logMax) {
        const ticks = [];
        const startPow = Math.floor(logMin);
        const endPow = Math.ceil(logMax);
        
        for (let p = startPow; p <= endPow; p++) {
            if (p >= logMin && p <= logMax) {
                ticks.push(p);
            }
        }
        
        // If range is very small, add intermediate ticks
        if (ticks.length < 3 && (logMax - logMin) < 2) {
            const midTicks = [];
            for (let p = startPow; p <= endPow; p++) {
                midTicks.push(p);
                // Add 0.5 log step (sqrt(10) ‚âà 3.16x)
                if (p + 0.5 <= logMax && p + 0.5 >= logMin) {
                    midTicks.push(p + 0.5);
                }
            }
            return midTicks.filter(t => t >= logMin && t <= logMax);
        }
        
        return ticks;
    }

    function createCompositeCanvas() {
        // Get all four canvases (2x2 grid)
        const networkCanvas = document.getElementById('networkCanvas');
        const fitCanvas = document.getElementById('fitCanvas');
        const traceCanvas = document.getElementById('traceCanvas');
        const lossCanvas = document.getElementById('lossCanvas');
        
        // Create composite canvas: 2x2 grid layout
        // Top row: Network Design | Examples vs Model
        // Bottom row: Training Trace | Error Landscape
        const padding = 10;
        const titleHeight = 18;
        const leftWidth = Math.max(networkCanvas.width, traceCanvas.width);
        const rightWidth = Math.max(fitCanvas.width, lossCanvas.width);
        const topHeight = Math.max(networkCanvas.height, fitCanvas.height);
        const bottomHeight = Math.max(traceCanvas.height, lossCanvas.height);
        
        const totalWidth = leftWidth + rightWidth + padding * 3;
        const totalHeight = topHeight + bottomHeight + titleHeight * 2 + padding * 4;
        
        const composite = document.createElement('canvas');
        composite.width = totalWidth;
        composite.height = totalHeight;
        const ctx = composite.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, totalWidth, totalHeight);
        
        // Add titles
        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        
        // Top-left: Network Design
        ctx.fillText('Network Design', padding, padding + 12);
        ctx.drawImage(networkCanvas, padding, padding + titleHeight);
        
        // Top-right: Examples vs Model
        ctx.fillText('Examples vs Model', leftWidth + padding * 2, padding + 12);
        ctx.drawImage(fitCanvas, leftWidth + padding * 2, padding + titleHeight);
        
        // Bottom-left: Training Trace
        const bottomY = padding + titleHeight + topHeight + padding;
        ctx.fillText('Training Trace', padding, bottomY + 12);
        ctx.drawImage(traceCanvas, padding, bottomY + titleHeight);
        
        // Bottom-right: Error Landscape
        ctx.fillText('Error Landscape', leftWidth + padding * 2, bottomY + 12);
        ctx.drawImage(lossCanvas, leftWidth + padding * 2, bottomY + titleHeight);
        
        return composite;
    }
    
    // Check if GIF capture with workers is available
    function canUseGifWorkers() {
        // With embedded worker blob, GIF capture works everywhere except file:// 
        // (file:// still has issues with blob workers in some browsers)
        return window.location.protocol !== 'file:';
    }
    
    // Fallback: capture a single screenshot as PNG
    function captureScreenshot() {
        const composite = createCompositeCanvas();
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        
        composite.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `learncurve_${timestamp}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 'image/png');
    }
    
    // Adaptive GIF capture - scans training to find interesting convergence region
    function startGifCapture() {
        if (gifCapture.recording) return;
        
        // Check if training data exists
        if (!dataset.generated || dataset.train.length === 0) {
            alert('Please generate training data first before capturing a GIF.');
            return;
        }
        
        // Check if we can use web workers (required for GIF.js)
        if (!canUseGifWorkers()) {
            const useScreenshot = confirm(
                'Animated GIF capture requires running from a web server.\n\n' +
                'Options:\n' +
                '‚Ä¢ Click OK to download a PNG screenshot instead\n' +
                '‚Ä¢ Click Cancel, then run: python3 -m http.server 8000\n' +
                '  and open http://localhost:8000/index.html for GIF capture'
            );
            if (useScreenshot) {
                captureScreenshot();
            }
            return;
        }
        
        
        trainingState.running = false;
        document.getElementById('runBtn').textContent = 'Run';
        
        // Show status
        const gifBtn = document.getElementById('gifBtn');
        const originalText = gifBtn.textContent;
        gifBtn.textContent = 'Scanning...';
        gifBtn.disabled = true;
        
        // Phase 1: Scan training to find convergence
        setTimeout(() => {
            const scanResult = scanForConvergence();
            gifBtn.textContent = 'Recording...';
            
            // Phase 2: Reset model and record with adaptive keyframes
            // (scanResult already restored state, startAdaptiveCapture will reset model)
            setTimeout(() => {
                startAdaptiveCapture(scanResult, () => {
                    gifBtn.textContent = originalText;
                    gifBtn.disabled = false;
                });
            }, 100);
        }, 50);
    }
    
    function scanForConvergence() {
        // Save current state
        const savedNetwork = JSON.parse(JSON.stringify(network));
        const savedHistory = JSON.parse(JSON.stringify(history));
        const savedTrainingState = JSON.parse(JSON.stringify(trainingState));
        const savedDataset = JSON.parse(JSON.stringify(dataset));
        
        // Reset model only (preserve dataset)
        resetModel();
        
        const losses = [];
        const maxScanSteps = 500;
        const targetFrames = 80;
        
        // Run silent training to collect loss data
        for (let i = 0; i < maxScanSteps; i++) {
            trainStep();
            losses.push(history.loss[history.loss.length - 1]);
            
            // Check for early convergence
            if (losses.length > 50) {
                const recent = losses.slice(-30);
                const variance = computeVariance(recent);
                const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
                if (variance < 0.0001 * mean * mean) {
                    break; // Converged early
                }
            }
        }
        
        // Analyze loss curve to find interesting region
        const L0 = losses[0];
        const Lmin = Math.min(...losses);
        const totalDrop = L0 - Lmin;
        
        // Find key milestones
        let start5pct = 0, start50pct = 0, end90pct = losses.length - 1, convergencePoint = losses.length - 1;
        
        for (let i = 0; i < losses.length; i++) {
            const drop = L0 - losses[i];
            if (start5pct === 0 && drop >= 0.05 * totalDrop) start5pct = i;
            if (start50pct === 0 && drop >= 0.50 * totalDrop) start50pct = i;
            if (drop >= 0.90 * totalDrop) { end90pct = i; break; }
        }
        
        // Detect convergence (low variance)
        for (let i = 50; i < losses.length; i++) {
            const window = losses.slice(i - 30, i);
            const variance = computeVariance(window);
            const mean = window.reduce((a, b) => a + b, 0) / window.length;
            if (variance < 0.0001 * mean * mean) {
                convergencePoint = i;
                break;
            }
        }
        
        // Compute |dL/dt| for each step
        const derivatives = losses.map((L, i) => 
            i === 0 ? 0 : Math.abs(losses[i-1] - L)
        );
        
        // Select keyframes adaptively
        const keyframes = selectKeyframes(losses, derivatives, {
            start5pct, start50pct, end90pct, convergencePoint
        }, targetFrames);
        
        // Restore original state
        network = savedNetwork;
        history = savedHistory;
        trainingState = savedTrainingState;
        dataset = savedDataset;
        
        return { losses, keyframes, convergencePoint };
    }
    
    function computeVariance(arr) {
        if (arr.length === 0) return 0;
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        return arr.reduce((sum, val) => sum + (val - mean) ** 2, 0) / arr.length;
    }
    
    function selectKeyframes(losses, derivatives, milestones, targetFrames) {
        const frames = new Set([0]); // Always include first
        
        // Always include milestone frames
        frames.add(milestones.start5pct);
        frames.add(milestones.start50pct);
        frames.add(milestones.end90pct);
        frames.add(Math.min(milestones.convergencePoint, losses.length - 1));
        frames.add(losses.length - 1); // Always include last
        
        // Score each step by "interestingness" (derivative magnitude)
        const maxDeriv = Math.max(...derivatives.slice(1)) || 1;
        const scores = derivatives.map(d => d / maxDeriv);
        
        // Add frames based on derivative (more change = more frames)
        const numSegments = 20;
        const segmentSize = Math.ceil(losses.length / numSegments);
        
        for (let seg = 0; seg < numSegments; seg++) {
            const segStart = seg * segmentSize;
            const segEnd = Math.min((seg + 1) * segmentSize, losses.length);
            
            // Find max derivative in this segment
            let maxIdx = segStart;
            let maxScore = 0;
            for (let i = segStart; i < segEnd; i++) {
                if (scores[i] > maxScore) {
                    maxScore = scores[i];
                    maxIdx = i;
                }
            }
            
            // Add more frames for high-derivative segments
            if (maxScore > 0.1) {
                frames.add(maxIdx);
                // Add extra frames around high-action areas
                if (maxScore > 0.3 && seg < numSegments - 1) {
                    frames.add(Math.min(maxIdx + 2, losses.length - 1));
                }
            } else {
                // Low derivative - just sample the segment sparsely
                frames.add(Math.floor((segStart + segEnd) / 2));
            }
        }
        
        // Convert to sorted array and limit to targetFrames
        let result = [...frames].sort((a, b) => a - b);
        
        // If we have too many, subsample evenly
        while (result.length > targetFrames) {
            // Remove every other frame except first/last
            const newResult = [result[0]];
            for (let i = 2; i < result.length - 1; i += 2) {
                newResult.push(result[i]);
            }
            newResult.push(result[result.length - 1]);
            result = newResult;
        }
        
        return result;
    }
    
    function startAdaptiveCapture(scanResult, onComplete) {
        const { keyframes } = scanResult;
        
        // Reset model to fresh state (preserve dataset)
        resetModel();
        
        const composite = createCompositeCanvas();
        
        try {
            gifCapture.gif = new GIF({
                workers: 2,
                quality: 10,
                width: composite.width,
                height: composite.height,
                workerScript: gifWorkerUrl  // Embedded worker to avoid CORS issues
            });
        } catch (e) {
            console.error('Failed to create GIF:', e);
            alert('GIF capture failed: ' + e.message);
            if (onComplete) onComplete();
            return;
        }
        
        gifCapture.recording = true;
        gifCapture.keyframes = keyframes;
        gifCapture.keyframeIndex = 0;
        gifCapture.currentStep = 0;
        
        gifCapture.gif.on('finished', function (blob) {
            // Clear timeout since we finished normally
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `convergence_${timestamp}.gif`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            gifCapture.recording = false;
            if (onComplete) onComplete();
        });
        
        // Timeout safety - force complete after 30 seconds
        gifCapture.timeout = setTimeout(() => {
            if (gifCapture.recording) {
                console.warn('GIF capture timeout - forcing completion');
                gifCapture.recording = false;
                gifCapture.gif = null;
                if (onComplete) onComplete();
            }
        }, 30000);
        
        adaptiveCaptureLoop();
    }
    
    function adaptiveCaptureLoop() {
        if (!gifCapture.recording || gifCapture.keyframeIndex >= gifCapture.keyframes.length) {
            if (gifCapture.gif) {
                gifCapture.gif.render();
            }
            return;
        }
        
        const targetStep = gifCapture.keyframes[gifCapture.keyframeIndex];
        
        // Train until we reach the target step (with safety limit)
        let safetyCounter = 0;
        const maxIterations = 10000;
        while (gifCapture.currentStep < targetStep && safetyCounter < maxIterations) {
            const prevStep = trainingState.step;
            trainStep();
            gifCapture.currentStep++;
            safetyCounter++;
            
            // If trainStep didn't actually train (NaN or other issue), break out
            if (trainingState.step === prevStep || !Number.isFinite(history.loss[history.loss.length - 1])) {
                console.warn('GIF capture: training issue detected, finishing early');
                gifCapture.keyframeIndex = gifCapture.keyframes.length; // Force finish
                break;
            }
        }
        
        updateUI();
        
        // Calculate delay based on next keyframe distance (variable speed)
        let delay = 100;
        if (gifCapture.keyframeIndex < gifCapture.keyframes.length - 1) {
            const gap = gifCapture.keyframes[gifCapture.keyframeIndex + 1] - targetStep;
            // Bigger gaps = less action = shorter delay (faster playback)
            delay = gap > 20 ? 50 : gap > 5 ? 100 : 150;
        } else {
            delay = 200; // Pause at end
        }
        
        // Capture frame
        const composite = createCompositeCanvas();
        gifCapture.gif.addFrame(composite, {copy: true, delay});
        
        gifCapture.keyframeIndex++;
        setTimeout(adaptiveCaptureLoop, 30);
    }

    function initializeOptimizerState() {
        optimizerState.m = [];
        optimizerState.v = [];
        optimizerState.r = [];
        optimizerState.t = 0;

        // For each weight matrix/vector
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            if (Array.isArray(w[0])) {
                optimizerState.m.push(w.map(row => row.map(() => 0)));
                optimizerState.v.push(w.map(row => row.map(() => 0)));
                optimizerState.r.push(w.map(row => row.map(() => 0)));
            } else {
                optimizerState.m.push(w.map(() => 0));
                optimizerState.v.push(w.map(() => 0));
                optimizerState.r.push(w.map(() => 0));
            }
        }

        // Biases
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            optimizerState.m.push(b.map(() => 0));
            optimizerState.v.push(b.map(() => 0));
            optimizerState.r.push(b.map(() => 0));
        }
    }
function updateParameters() {
    const lr = config.learningRate;
    const beta1 = 0.9;
    const beta2 = 0.999;
    const epsilon = 1e-8;
    const rho = 0.9;
    const momentumCoeff = 0.9;
    const gradClip = 5.0;  // Gradient clipping threshold

    // Clip gradients to prevent explosion
    function clipGrad(g) {
        if (!Number.isFinite(g)) return 0;
        return Math.max(-gradClip, Math.min(gradClip, g));
    }
    
    // Apply gradient clipping to all gradients
    for (let l = 0; l < grads.weights.length; l++) {
        const gw = grads.weights[l];
        if (Array.isArray(gw[0])) {
            for (let i = 0; i < gw.length; i++) {
                for (let j = 0; j < gw[i].length; j++) {
                    gw[i][j] = clipGrad(gw[i][j]);
                }
            }
        } else {
            for (let i = 0; i < gw.length; i++) {
                gw[i] = clipGrad(gw[i]);
            }
        }
    }
    for (let l = 0; l < grads.biases.length; l++) {
        const gb = grads.biases[l];
        for (let i = 0; i < gb.length; i++) {
            gb[i] = clipGrad(gb[i]);
        }
    }

    let idx = 0;

    // Plain SGD
    if (config.optimizer === 'sgd') {
        for (let l = 0; l < network.weights.length; l++) {
            const w = network.weights[l];
            const gw = grads.weights[l];
            if (Array.isArray(w[0])) {
                // matrix
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        w[i][j] -= lr * gw[i][j];
                    }
                }
            } else {
                // vector
                for (let i = 0; i < w.length; i++) {
                    w[i] -= lr * gw[i];
                }
            }
        }
        for (let l = 0; l < network.biases.length; l++) {
            const b = network.biases[l];
            const gb = grads.biases[l];
            for (let i = 0; i < b.length; i++) {
                b[i] -= lr * gb[i];
            }
        }
        return;
    }

    // Momentum / RMSProp / Adam
    optimizerState.t += 1;

    // Weights
    for (let l = 0; l < network.weights.length; l++) {
        const w = network.weights[l];
        const gw = grads.weights[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;

            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        v[i][j] = vCoeff * v[i][j] + oneMinus * gw[i][j];
                        w[i][j] -= lr * v[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    v[i] = vCoeff * v[i] + oneMinus * gw[i];
                    w[i] -= lr * v[i];
                }
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        r[i][j] = rho * r[i][j] + oneMinusRho * gw[i][j] * gw[i][j];
                        const step = lr / Math.sqrt(r[i][j] + epsilon);
                        w[i][j] -= step * gw[i][j];
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    r[i] = rho * r[i] + oneMinusRho * gw[i] * gw[i];
                    const step = lr / Math.sqrt(r[i] + epsilon);
                    w[i] -= step * gw[i];
                }
            }
        } else if (config.optimizer === 'adam') {
            if (Array.isArray(w[0])) {
                for (let i = 0; i < w.length; i++) {
                    for (let j = 0; j < w[i].length; j++) {
                        m[i][j] = beta1 * m[i][j] + (1 - beta1) * gw[i][j];
                        v[i][j] = beta2 * v[i][j] + (1 - beta2) * gw[i][j] * gw[i][j];
                        const mHat = m[i][j] / (1 - Math.pow(beta1, optimizerState.t));
                        const vHat = v[i][j] / (1 - Math.pow(beta2, optimizerState.t));
                        w[i][j] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                    }
                }
            } else {
                for (let i = 0; i < w.length; i++) {
                    m[i] = beta1 * m[i] + (1 - beta1) * gw[i];
                    v[i] = beta2 * v[i] + (1 - beta2) * gw[i] * gw[i];
                    const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                    const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                    w[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
                }
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }

    // Biases
    for (let l = 0; l < network.biases.length; l++) {
        const b = network.biases[l];
        const gb = grads.biases[l];
        let m = optimizerState.m[idx];
        let v = optimizerState.v[idx];
        let r = optimizerState.r[idx];

        if (config.optimizer === 'momentum') {
            const vCoeff = momentumCoeff;
            const oneMinus = 1 - vCoeff;
            for (let i = 0; i < b.length; i++) {
                v[i] = vCoeff * v[i] + oneMinus * gb[i];
                b[i] -= lr * v[i];
            }
        } else if (config.optimizer === 'rmsprop') {
            const oneMinusRho = 1 - rho;
            for (let i = 0; i < b.length; i++) {
                r[i] = rho * r[i] + oneMinusRho * gb[i] * gb[i];
                const step = lr / Math.sqrt(r[i] + epsilon);
                b[i] -= step * gb[i];
            }
        } else if (config.optimizer === 'adam') {
            for (let i = 0; i < b.length; i++) {
                m[i] = beta1 * m[i] + (1 - beta1) * gb[i];
                v[i] = beta2 * v[i] + (1 - beta2) * gb[i] * gb[i];
                const mHat = m[i] / (1 - Math.pow(beta1, optimizerState.t));
                const vHat = v[i] / (1 - Math.pow(beta2, optimizerState.t));
                b[i] -= lr * mHat / (Math.sqrt(vHat) + epsilon);
            }
        }

        optimizerState.m[idx] = m;
        optimizerState.v[idx] = v;
        optimizerState.r[idx] = r;
        idx++;
    }
}

    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }

    function makeRunLabel(slot) {
        const optName = config.optimizer === 'sgd' ? 'Simple' : config.optimizer;
        return `${slot}: ${config.activation}, L=${network.numLayers}, H=${network.hiddenSize}, Œ∑=${config.learningRate.toFixed(3)}, ${optName}`;
    }

    function saveRun(slot) {
        if (history.steps.length < 2) {
            alert('Train the network for a few steps before saving a run.');
            return;
        }

        const run = {
            label: makeRunLabel(slot),
            steps: history.steps.slice(),
            loss: history.loss.slice(),
            avgLoss: history.avgLoss.slice(),
            network: deepClone(network),
            config: {
                activation: config.activation,
                learningRate: config.learningRate,
                numLayers: network.numLayers,
                hiddenSize: network.hiddenSize,
                targetFuncStr: config.targetFuncStr,
                optimizer: config.optimizer
            },
            // Save loss landscape trail for comparison visualization
            lossSurfaceTrail: lossSurfaceTrail.slice(),
            lossSurfaceWeightIndices: lossSurfaceWeightIndices.slice()
        };

        savedRuns[slot] = run;

        const labelEl = document.getElementById(slot === 'A' ? 'runALabel' : 'runBLabel');
        if (labelEl) {
            labelEl.textContent = run.label;
        }

        // Style the save button to show it has saved data (subtle indicator - thicker border)
        const saveBtn = document.getElementById(slot === 'A' ? 'saveRunA' : 'saveRunB');
        if (saveBtn) {
            saveBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:8px; border:2px solid #28a745; box-shadow:0 0 3px rgba(40,167,69,0.3);';
        }

        // Enable and style compare button when both A and B are saved
        const compareBtn = document.getElementById('compareBtn');
        if (savedRuns.A && savedRuns.B) {
            compareBtn.disabled = false;
            compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
        }

        updateUI();
    }

    function forwardWithNetwork(x, net, activationName) {
        const actFn = activationFns[activationName].fn;
        const h = net.hiddenSize;
        const numLayers = net.numLayers;

        let activations = [];
        let zValues = [];

        activations.push([x]);

        // Hidden layer 1
        let z = new Array(h);
        let a = new Array(h);
        const w0 = net.weights[0]; // shape [h, 1] represented as [h]
        const b0 = net.biases[0];  // shape [h]
        for (let i = 0; i < h; i++) {
            let zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = actFn(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let layer = 1; layer < numLayers; layer++) {
            const prev = activations[activations.length - 1];
            const w = net.weights[layer];  // shape [h, h]
            const b = net.biases[layer];   // shape [h]

            z = new Array(h);
            a = new Array(h);

            for (let i = 0; i < h; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < h; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = actFn(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output layer
        const lastLayer = activations[activations.length - 1];
        const wOut = net.weights[net.weights.length - 1];       // shape [h]
        const bOut = net.biases[net.biases.length - 1][0];      // shape [1]
        let yhat = bOut;
        for (let i = 0; i < h; i++) {
            yhat += wOut[i] * lastLayer[i];
        }

        return yhat;
    }

    // -------------- Network, Target & Ops --------------

    function compileTargetFunc() {
        const input = document.getElementById('targetFuncInput');
        let originalStr = input.value.trim() || 'x^2';
        
        // Make case-insensitive by converting to lowercase for function matching
        let fStr = originalStr;
        
        // Allow ^ as power operator (convert to **)
        fStr = fStr.replace(/\^/g, '**');
        
        // Convert shorthand functions to Math.* (case-insensitive)
        // Order matters - longer names first
        fStr = fStr.replace(/\blog10\b/gi, 'Math.log10');  // log base 10
        fStr = fStr.replace(/\bsqrt\b/gi, 'Math.sqrt');
        fStr = fStr.replace(/\babs\b/gi, 'Math.abs');
        fStr = fStr.replace(/\bsin\b/gi, 'Math.sin');
        fStr = fStr.replace(/\bcos\b/gi, 'Math.cos');
        fStr = fStr.replace(/\btan\b/gi, 'Math.tan');
        fStr = fStr.replace(/\bexp\b/gi, 'Math.exp');      // e^x (natural exponential)
        fStr = fStr.replace(/\blog\b/gi, 'Math.log');      // natural log (ln)
        fStr = fStr.replace(/\bfloor\b/gi, 'Math.floor');
        fStr = fStr.replace(/\bceil\b/gi, 'Math.ceil');
        fStr = fStr.replace(/\bround\b/gi, 'Math.round');
        fStr = fStr.replace(/\bsign\b/gi, 'Math.sign');
        fStr = fStr.replace(/\bmin\b/gi, 'Math.min');
        fStr = fStr.replace(/\bmax\b/gi, 'Math.max');
        fStr = fStr.replace(/\bpow\b/gi, 'Math.pow');
        
        // Convert constants (case-insensitive)
        fStr = fStr.replace(/\bPI\b/gi, 'Math.PI');        // œÄ ‚âà 3.14159
        fStr = fStr.replace(/\bE\b/gi, 'Math.E');          // e ‚âà 2.71828
        
        // Make x case-insensitive (X -> x)
        fStr = fStr.replace(/\bX\b/g, 'x');

        // Get or create error display elements
        let errorSpan = document.getElementById('targetFuncError');
        if (!errorSpan) {
            errorSpan = document.createElement('span');
            errorSpan.id = 'targetFuncError';
            errorSpan.style.cssText = 'color:#dc3545; font-size:11px; margin-left:8px; display:block;';
            input.parentNode.appendChild(errorSpan);
        }

        try {
            const fn = new Function('x', 'return ' + fStr + ';');
            // Test it at a few points
            fn(0);
            fn(1);
            fn(-1);
            config.targetFunc = fn;
            config.targetFuncStr = fStr;
            input.style.borderColor = '#28a745';  // Green border for valid
            input.style.backgroundColor = '#fff';
            errorSpan.textContent = '';
            errorSpan.innerHTML = '';
        } catch (e) {
            // Highlight input in red but DON'T revert - let user continue editing
            input.style.borderColor = '#dc3545';
            input.style.backgroundColor = '#fff0f0';
            
            // Try to extract position info from error message
            const errorMsg = e.message;
            let highlightedError = errorMsg;
            
            // Try to find problematic tokens
            const unexpectedMatch = errorMsg.match(/Unexpected token '?([^']*)'?/i);
            const identifierMatch = errorMsg.match(/(\w+) is not defined/i);
            
            if (unexpectedMatch && unexpectedMatch[1]) {
                const badToken = unexpectedMatch[1];
                const pos = originalStr.indexOf(badToken);
                if (pos >= 0) {
                    // Show the input with the bad part highlighted
                    const before = originalStr.substring(0, pos);
                    const bad = originalStr.substring(pos, pos + badToken.length);
                    const after = originalStr.substring(pos + badToken.length);
                    highlightedError = `Error at "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>": ${errorMsg}`;
                }
            } else if (identifierMatch && identifierMatch[1]) {
                const badId = identifierMatch[1];
                // Find case-insensitive match in original
                const regex = new RegExp('\\b' + badId + '\\b', 'i');
                const match = originalStr.match(regex);
                if (match) {
                    const pos = originalStr.search(regex);
                    const before = originalStr.substring(0, pos);
                    const bad = match[0];
                    const after = originalStr.substring(pos + bad.length);
                    highlightedError = `Unknown: "<span style="background:#ffcccc;padding:0 2px;border-radius:2px;font-weight:bold;">${bad}</span>" - did you mean a function like sin, cos, exp?`;
                }
            }
            
            errorSpan.innerHTML = '‚ö† ' + highlightedError;
            // Keep the previous valid function running - don't change config.targetFunc
        }
    }

    function initializeNetwork() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        network.weights = [];
        network.biases = [];
        grads.weights = [];
        grads.biases = [];

        function randnScaled(scale) {
            return scale * gaussianNoise(0, 1);
        }

        // Input -> Layer 1: weights shape [H, 1]
        const w0 = new Array(H);
        const b0 = new Array(H);
        const scale0 = 1 / Math.sqrt(1);
        for (let i = 0; i < H; i++) {
            w0[i] = randnScaled(scale0);
            b0[i] = 0;
        }
        network.weights.push(w0);
        network.biases.push(b0);
        grads.weights.push(new Array(H).fill(0));
        grads.biases.push(new Array(H).fill(0));

        // Hidden ‚Üí Hidden
        for (let l = 1; l < L; l++) {
            const w = new Array(H);
            const b = new Array(H);
            const scale = 1 / Math.sqrt(H);
            for (let i = 0; i < H; i++) {
                w[i] = new Array(H);
                for (let j = 0; j < H; j++) {
                    w[i][j] = randnScaled(scale);
                }
                b[i] = 0;
            }
            network.weights.push(w);
            network.biases.push(b);

            const gw = new Array(H);
            for (let i = 0; i < H; i++) {
                gw[i] = new Array(H).fill(0);
            }
            grads.weights.push(gw);
            grads.biases.push(new Array(H).fill(0));
        }

        // Output layer: weights [H], bias [1]
        const wOut = new Array(H);
        const bOut = [0];
        const scaleOut = 1 / Math.sqrt(H);
        for (let i = 0; i < H; i++) {
            wOut[i] = randnScaled(scaleOut);
        }
        network.weights.push(wOut);
        network.biases.push(bOut);

        grads.weights.push(new Array(H).fill(0));
        grads.biases.push([0]);
        
        // Initialize pre-allocated arrays for backward pass
        backwardCache.deltaNext = new Float64Array(H);
        backwardCache.deltaPrev = new Float64Array(H);
        backwardCache.delta = new Float64Array(H);
        backwardCache.actPrime = activationFns[config.activation].dfn;

        initializeOptimizerState();
        computeOpsPerStep();
    }

    function computeOpsPerStep() {
        const L = network.numLayers;
        const H = network.hiddenSize;

        let fwdAdds = 0, fwdMuls = 0;
        let backAdds = 0, backMuls = 0;
        let lossAdds = 0, lossMuls = 0;

        // Forward ops: each neuron does sum of inputs + bias + activation
        // Layer 1: H neurons, each 1 multiply + 1 add + (bias add)
        fwdMuls += H;  // w*x
        fwdAdds += H;  // plus bias

        // Hidden layers
        for (let l = 1; l < L; l++) {
            // each H neuron: H multiplies + H adds + 1 add for bias
            fwdMuls += H * H;
            fwdAdds += H * (H + 1);
        }

        // Output layer: H multiplies + H adds + 1 bias
        fwdMuls += H;
        fwdAdds += H + 1;

        // Loss = 1/2 (yhat - y)^2 -> 1 sub, 1 mul
        lossAdds += 1;
        lossMuls += 1;

        // Backward (rough estimate, symmetrical to forward)
        backMuls += fwdMuls * 2;
        backAdds += fwdAdds * 2;

        // Ops are now drawn on the Network Design canvas
        // Keep these for backwards compatibility if elements exist
        const setIfExists = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
        setIfExists('opsFwdAdd', fwdAdds);
        setIfExists('opsFwdMul', fwdMuls);
        setIfExists('opsLossAdd', lossAdds);
        setIfExists('opsLossMul', lossMuls);
        setIfExists('opsBackAdd', backAdds);
        setIfExists('opsBackMul', backMuls);
        setIfExists('opsTotAdd', fwdAdds + lossAdds + backAdds);
        setIfExists('opsTotMul', fwdMuls + lossMuls + backMuls);

        return { fwdAdds, fwdMuls, lossAdds, lossMuls, backAdds, backMuls };
    }

    // Generate a single point from the target function (used for visualization)
    function sampleTargetPoint() {
        const x = config.xMin + Math.random() * (config.xMax - config.xMin);
        let y;
        try {
            y = config.targetFunc(x);
        } catch {
            y = 0;
        }
        if (config.noise > 0) {
            y += gaussianNoise(0, config.noise);
        }
        return { x, y };
    }
    
    // Legacy function - now gets next point from dataset
    function sampleTrainingPoint() {
        if (!dataset.generated || dataset.train.length === 0) {
            // Fallback to random sampling if no dataset
            return sampleTargetPoint();
        }
        
        // Get the current training sample based on shuffle order
        const idx = dataset.shuffleOrder[dataset.stepInEpoch % dataset.train.length];
        return dataset.train[idx];
    }
    
    // Generate fixed training and test datasets
    function generateDataset() {
        const totalSamples = config.totalSamples;
        const trainRatio = config.trainTestSplit;
        
        // Generate all points across the FULL data range
        const allPoints = [];
        const dataRange = config.dataXMax - config.dataXMin;
        
        for (let i = 0; i < totalSamples; i++) {
            // Use stratified sampling for better coverage
            const x = config.dataXMin + (i + Math.random()) * dataRange / totalSamples;
            let y;
            try {
                y = config.targetFunc(x);
            } catch {
                y = 0;
            }
            if (config.noise > 0) {
                y += gaussianNoise(0, config.noise);
            }
            // Mark if point is within training range
            const inTrainRange = x >= config.trainXMin && x <= config.trainXMax;
            allPoints.push({ x, y, inTrainRange });
        }
        
        // Shuffle all points
        for (let i = allPoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allPoints[i], allPoints[j]] = [allPoints[j], allPoints[i]];
        }
        
        // Split into train candidates and test
        const trainCount = Math.floor(totalSamples * trainRatio);
        const allTrainCandidates = allPoints.slice(0, trainCount);
        const allTestPoints = allPoints.slice(trainCount);
        
        // Store all points
        dataset.allTrain = allTrainCandidates;
        dataset.allTest = allTestPoints;
        
        // Filter training points to only those within training range
        dataset.train = allTrainCandidates.filter(p => p.inTrainRange);
        
        // Test set includes ALL held-out points (both in and out of range)
        dataset.test = allTestPoints;
        
        // Count test points in/out of training range
        const testInRange = allTestPoints.filter(p => p.inTrainRange).length;
        const testOutRange = allTestPoints.length - testInRange;
        
        dataset.generated = true;
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        
        // Reset evaluation
        revealOptions.evaluated = false;
        evaluationResults = {
            testLossInRange: null,
            testLossOutRange: null,
            testLossTotal: null,
            pointsInRange: testInRange,
            pointsOutRange: testOutRange
        };
        
        // Initialize shuffle order for first epoch
        shuffleTrainingOrder();
        
        // Update x range for Fit Plot to show full data range
        config.xMin = config.dataXMin;
        config.xMax = config.dataXMax;
        
        // Update UI
        updatePhaseUI();
        updateTrainingHandlePositions();
        updateTrainRangeSliderBounds();
        
        const outsideCount = allTrainCandidates.filter(p => !p.inTrainRange).length;
        console.log(`Generated ${totalSamples} total points:`);
        console.log(`  Training: ${dataset.train.length} in range (${outsideCount} excluded outside train range)`);
        console.log(`  Held-out: ${testInRange} in range, ${testOutRange} outside (extrapolation test)`);
        
        // Set rolling average window to at least 2 epochs (2√ó training set size)
        const minAvgWindow = dataset.train.length * 2;
        if (config.avgWindow < minAvgWindow) {
            config.avgWindow = minAvgWindow;
            const avgWindowSlider = document.getElementById('avgWindowSlider');
            const avgWindowValue = document.getElementById('avgWindowValue');
            if (avgWindowSlider) {
                // Extend slider max if needed
                if (minAvgWindow > parseInt(avgWindowSlider.max)) {
                    avgWindowSlider.max = Math.ceil(minAvgWindow / 100) * 100;
                }
                avgWindowSlider.value = config.avgWindow;
            }
            if (avgWindowValue) avgWindowValue.textContent = config.avgWindow;
            console.log(`  Rolling avg window set to ${config.avgWindow} (2 epochs)`);
        }
        
        return { 
            trainCount: dataset.train.length, 
            testCount: dataset.test.length,
            testInRange,
            testOutRange
        };
    }
    
    // Run evaluation on held-out data
    function runEvaluation() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let lossInRange = 0;
        let lossOutRange = 0;
        let countInRange = 0;
        let countOutRange = 0;
        
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            const loss = 0.5 * error * error;
            
            if (point.inTrainRange) {
                lossInRange += loss;
                countInRange++;
            } else {
                lossOutRange += loss;
                countOutRange++;
            }
        }
        
        evaluationResults = {
            testLossInRange: countInRange > 0 ? lossInRange / countInRange : null,
            testLossOutRange: countOutRange > 0 ? lossOutRange / countOutRange : null,
            testLossTotal: (lossInRange + lossOutRange) / dataset.test.length,
            pointsInRange: countInRange,
            pointsOutRange: countOutRange
        };
        
        revealOptions.evaluated = true;
        revealOptions.showHeldOut = true;  // Automatically reveal held-out points
        
        // Update the checkbox
        const showHeldOutCheckbox = document.getElementById('showHeldOut');
        if (showHeldOutCheckbox) showHeldOutCheckbox.checked = true;
        
        // Record in history
        history.testLoss.push({ 
            step: trainingState.step, 
            loss: evaluationResults.testLossTotal,
            inRange: evaluationResults.testLossInRange,
            outRange: evaluationResults.testLossOutRange
        });
        
        return evaluationResults;
    }
    
    // Shuffle the training order for a new epoch
    function shuffleTrainingOrder() {
        dataset.shuffleOrder = [];
        for (let i = 0; i < dataset.train.length; i++) {
            dataset.shuffleOrder.push(i);
        }
        // Fisher-Yates shuffle
        for (let i = dataset.shuffleOrder.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [dataset.shuffleOrder[i], dataset.shuffleOrder[j]] = [dataset.shuffleOrder[j], dataset.shuffleOrder[i]];
        }
    }
    
    // Compute loss over the entire test set
    function computeTestLoss() {
        if (!dataset.generated || dataset.test.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.test) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.test.length;
    }
    
    // Compute loss over the entire training set
    function computeTrainLoss() {
        if (!dataset.generated || dataset.train.length === 0) return null;
        
        let totalLoss = 0;
        for (const point of dataset.train) {
            const fwd = forward(point.x);
            const error = fwd.yhat - point.y;
            totalLoss += 0.5 * error * error;
        }
        return totalLoss / dataset.train.length;
    }
    
    // Update training range from config and re-filter dataset
    function updateTrainingRangeFromConfig() {
        if (!dataset.generated) return;
        if (!dataset.allTrain || !dataset.allTest) return;
        
        // Re-filter training points based on new training range
        // (allTrain and allTest are preserved from original generation)
        dataset.train = dataset.allTrain.filter(p => 
            p.x >= config.trainXMin && p.x <= config.trainXMax
        );
        
        // Update test points' inTrainRange status
        dataset.test = dataset.allTest.map(p => ({
            ...p,
            inTrainRange: p.x >= config.trainXMin && p.x <= config.trainXMax
        }));
        
        // Reset training state (new dataset means starting fresh)
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        shuffleTrainingOrder();
        
        updatePhaseUI();
    }
    
    // Update training handle positions based on training range
    function updateTrainingHandlePositions() {
        const fitCanvas = document.getElementById('fitCanvas');
        const trainMinHandle = document.getElementById('trainMinHandle');
        const trainMaxHandle = document.getElementById('trainMaxHandle');
        
        if (!fitCanvas || !trainMinHandle || !trainMaxHandle) return;
        
        // Calculate plot area (must match drawFitPlot padding)
        const paddingLeft = 50;
        const paddingRight = 50;
        const canvasWidth = fitCanvas.offsetWidth || 520;
        const plotWidth = canvasWidth - paddingLeft - paddingRight;
        
        const dataRange = config.xMax - config.xMin;
        if (dataRange <= 0) return;
        
        // Calculate handle positions based on training range relative to data range
        const minFrac = (config.trainXMin - config.xMin) / dataRange;
        const maxFrac = (config.trainXMax - config.xMin) / dataRange;
        
        // Position handles (12px handle width, so offset by 12 to center)
        const minPx = paddingLeft + (minFrac * plotWidth) - 12;
        const maxPx = paddingLeft + (maxFrac * plotWidth) - 12;
        
        trainMinHandle.style.left = minPx + 'px';
        trainMinHandle.style.right = 'auto';
        trainMaxHandle.style.left = maxPx + 'px';
        trainMaxHandle.style.right = 'auto';
        
        // Enable handles if data is generated
        if (dataset.generated) {
            trainMinHandle.style.opacity = '1';
            trainMinHandle.style.pointerEvents = 'auto';
            trainMaxHandle.style.opacity = '1';
            trainMaxHandle.style.pointerEvents = 'auto';
        } else {
            trainMinHandle.style.opacity = '0.5';
            trainMinHandle.style.pointerEvents = 'none';
            trainMaxHandle.style.opacity = '0.5';
            trainMaxHandle.style.pointerEvents = 'none';
        }
    }
    
    // Update train range slider bounds when data is generated
    function updateTrainRangeSliderBounds() {
        const trainMinSlider = document.getElementById('trainMinSlider');
        const trainMaxSlider = document.getElementById('trainMaxSlider');
        const trainRangeSliderStrip = document.getElementById('trainRangeSliderStrip');
        const trainRangeMinLabel = document.getElementById('trainRangeMinLabel');
        const trainRangeMaxLabel = document.getElementById('trainRangeMaxLabel');
        
        if (!trainMinSlider || !trainMaxSlider) return;
        
        // Set slider bounds to data range
        trainMinSlider.min = config.dataXMin.toString();
        trainMinSlider.max = config.dataXMax.toString();
        trainMaxSlider.min = config.dataXMin.toString();
        trainMaxSlider.max = config.dataXMax.toString();
        
        // Set slider values to current training range
        trainMinSlider.value = config.trainXMin.toString();
        trainMaxSlider.value = config.trainXMax.toString();
        
        // Update labels
        if (trainRangeMinLabel) trainRangeMinLabel.textContent = config.dataXMin.toString();
        if (trainRangeMaxLabel) trainRangeMaxLabel.textContent = config.dataXMax.toString();
        
        // Enable/disable based on data state
        if (trainRangeSliderStrip) {
            if (dataset.generated) {
                trainRangeSliderStrip.style.opacity = '1';
                trainRangeSliderStrip.style.pointerEvents = 'auto';
            } else {
                trainRangeSliderStrip.style.opacity = '0.5';
                trainRangeSliderStrip.style.pointerEvents = 'none';
            }
        }
        
        // Trigger UI update
        const trainMinValue = document.getElementById('trainMinValue');
        const trainMaxValue = document.getElementById('trainMaxValue');
        const trainRangeFill = document.getElementById('trainRangeFill');
        
        if (trainMinValue && trainMaxValue && trainRangeFill) {
            const min = parseFloat(trainMinSlider.min);
            const max = parseFloat(trainMinSlider.max);
            const minVal = parseFloat(trainMinSlider.value);
            const maxVal = parseFloat(trainMaxSlider.value);
            
            trainMinValue.textContent = minVal.toFixed(1);
            trainMaxValue.textContent = maxVal.toFixed(1);
            
            // Use consistent positioning formula accounting for thumb width (34px)
            const minPercent = (minVal - min) / (max - min);
            const maxPercent = (maxVal - min) / (max - min);
            trainMinValue.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            trainMaxValue.style.left = `calc(17px + (100% - 34px) * ${maxPercent})`;
            trainRangeFill.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            trainRangeFill.style.width = `calc((100% - 34px) * ${maxPercent - minPercent})`;
        }
    }
    
    // Update view slider max based on training progress
    function updateViewSliderMax() {
        const viewSlider = document.getElementById('viewSlider');
        const viewValue = document.getElementById('viewValue');
        const viewSliderStrip = document.getElementById('viewSliderStrip');
        
        if (!viewSlider) return;
        
        const totalSteps = history.steps.length;
        
        // Enable slider when we have enough data
        if (viewSliderStrip) {
            if (totalSteps > 50) {
                viewSliderStrip.style.opacity = '1';
                viewSliderStrip.style.pointerEvents = 'auto';
            } else {
                viewSliderStrip.style.opacity = '0.5';
                viewSliderStrip.style.pointerEvents = 'none';
            }
        }
        
        // Update max to current step count (minimum 100 for usability)
        const newMax = Math.max(100, totalSteps);
        viewSlider.max = newMax.toString();
        
        // If slider is at max (showing "All"), keep it at max
        if (traceViewState.maxStep === Infinity || parseInt(viewSlider.value, 10) >= newMax - 10) {
            viewSlider.value = newMax.toString();
            if (viewValue) viewValue.textContent = 'All';
        }
    }
    
    // Update loss scale legend based on calibrated values
    function updateLossScaleLegend() {
        const minEl = document.getElementById('lossScaleMin');
        const maxEl = document.getElementById('lossScaleMax');
        
        if (minEl && lossColorScale.calibrated && isFinite(lossColorScale.minLoss)) {
            if (lossColorScale.minLoss < 0.001) {
                minEl.textContent = lossColorScale.minLoss.toExponential(0);
            } else {
                minEl.textContent = lossColorScale.minLoss.toFixed(3);
            }
        } else if (minEl) {
            minEl.textContent = '...';
        }
        
        if (maxEl && lossColorScale.calibrated && isFinite(lossColorScale.maxLoss)) {
            if (lossColorScale.maxLoss >= 10) {
                maxEl.textContent = lossColorScale.maxLoss.toFixed(0);
            } else {
                maxEl.textContent = lossColorScale.maxLoss.toFixed(1);
            }
        } else if (maxEl) {
            maxEl.textContent = '...';
        }
    }
    
    // Update phase UI based on data state
    function updatePhaseUI() {
        const phase1 = document.getElementById('phase1Panel');
        const phase2 = document.getElementById('phase2Panel');
        const dataStatus = document.getElementById('dataStatus');
        const epochStatus = document.getElementById('epochStatus');
        const generateBtn = document.getElementById('generateDataBtn');
        const newDataBtn = document.getElementById('newDataBtn');
        const stepsPerEpoch = document.getElementById('stepsPerEpoch');
        const revealControls = document.getElementById('revealControls');
        const recipeControls = document.getElementById('recipeControls');
        const dataSummary = document.getElementById('dataSummary');
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        
        if (dataset.generated) {
            // Phase 1: Data is ready - keep header bright, show Edit Recipe button
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Hide recipe controls (they get dulled when shown again after collapse)
            recipeControls.style.display = 'none';
            recipeControls.style.opacity = '0.6';
            toggleRecipeBtn.style.display = 'inline-block';
            toggleRecipeBtn.textContent = '‚úèÔ∏è Edit Recipe';
            
            // Show data summary (bright)
            dataSummary.style.display = 'block';
            dataSummary.style.opacity = '1';
            
            // Update data counts
            document.getElementById('trainCount').textContent = dataset.train.length;
            document.getElementById('testCount').textContent = dataset.test.length;
            
            // Show training range info
            const trainRangeLabel = document.getElementById('trainRangeLabel');
            if (trainRangeLabel) {
                trainRangeLabel.textContent = `[${config.trainXMin} to ${config.trainXMax}]`;
            }
            
            // Show test range breakdown
            const testInRange = dataset.test.filter(p => p.inTrainRange).length;
            const testOutRange = dataset.test.length - testInRange;
            const testRangeInfo = document.getElementById('testRangeInfo');
            if (testRangeInfo) {
                if (testOutRange > 0) {
                    testRangeInfo.innerHTML = `<span style="color:#ff9800;">${testInRange} in</span> / <span style="color:#dc3545;">${testOutRange} out</span>`;
                } else {
                    testRangeInfo.textContent = `(all in range)`;
                }
            }
            
            // Update summary note
            const dataSummaryNote = document.getElementById('dataSummaryNote');
            if (dataSummaryNote) {
                if (testOutRange > 0) {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points in range [${config.trainXMin}, ${config.trainXMax}]. ` +
                        `<span style="color:#dc3545;"><strong>${testOutRange}</strong> held-out points are outside this range</span> ‚Äî testing <strong>extrapolation</strong> (can the model generalize beyond its training?).</em>`;
                } else {
                    dataSummaryNote.innerHTML = `<em>Model trains on <strong>${dataset.train.length}</strong> points. Held-out data tests if it learned the pattern vs. memorized points.</em>`;
                }
            }
            
            // Populate data previews (show first 4 points each, compact format)
            const formatPoint = (p) => `${p.x.toFixed(1)}‚Üí${p.y.toFixed(2)}`;
            
            const trainPreview = document.getElementById('trainDataPreview');
            const testPreview = document.getElementById('testDataPreview');
            
            // Sort by x for display
            const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
            const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
            
            trainPreview.innerHTML = sortedTrain.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTrain.length > 4 ? `<br><span style="color:#888;">+${sortedTrain.length - 4} more</span>` : '');
            testPreview.innerHTML = sortedTest.slice(0, 4).map(formatPoint).join('<br>') + 
                (sortedTest.length > 4 ? `<br><span style="color:#888;">+${sortedTest.length - 4} more</span>` : '');
            
            // Update train point count in Fit Plot header
            const trainPointCount = document.getElementById('trainPointCount');
            if (trainPointCount) trainPointCount.textContent = dataset.train.length;
            
            // Enable training range controls
            const trainRangeControls = document.getElementById('trainRangeControls');
            if (trainRangeControls) {
                trainRangeControls.style.opacity = '1';
                trainRangeControls.style.pointerEvents = 'auto';
            }
            
            // Sync mobile training range inputs
            const trainXMinMobile = document.getElementById('trainXMinMobile');
            const trainXMaxMobile = document.getElementById('trainXMaxMobile');
            if (trainXMinMobile) trainXMinMobile.value = config.trainXMin;
            if (trainXMaxMobile) trainXMaxMobile.value = config.trainXMax;
            
            // Enable Phase 3
            const phase3 = document.getElementById('phase3Panel');
            if (phase3) {
                phase3.style.opacity = '1';
                phase3.style.pointerEvents = 'auto';
            }
            
            dataStatus.innerHTML = `‚úì Training data ready`;
            dataStatus.style.color = '#28a745';
            
            // Phase 2: Enable
            phase2.style.opacity = '1';
            phase2.style.pointerEvents = 'auto';
            epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            epochStatus.style.color = '#007bff';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = dataset.train.length;
            
            // Enable reveal controls (Assessment)
            if (revealControls) {
                revealControls.style.opacity = '1';
                revealControls.style.pointerEvents = 'auto';
            }
        } else {
            // Phase 1: Active - show recipe controls (bright)
            phase1.style.opacity = '1';
            phase1.style.borderLeftColor = '#28a745';
            
            // Show recipe controls (bright), hide toggle and summary
            recipeControls.style.display = 'flex';
            recipeControls.style.opacity = '1';
            toggleRecipeBtn.style.display = 'none';
            dataSummary.style.display = 'none';
            
            // Enable Phase 1 inputs
            document.getElementById('targetFuncInput').disabled = false;
            document.getElementById('dataXMinInput').disabled = false;
            document.getElementById('dataXMaxInput').disabled = false;
            document.getElementById('trainXMinInput').disabled = false;
            document.getElementById('trainXMaxInput').disabled = false;
            document.getElementById('totalSamples').disabled = false;
            document.getElementById('noise').disabled = false;
            
            dataStatus.textContent = 'Define a data recipe, then generate training data';
            dataStatus.style.color = '#888';
            
            // Phase 2: Disabled
            phase2.style.opacity = '0.5';
            phase2.style.pointerEvents = 'none';
            epochStatus.textContent = 'Generate training data first...';
            epochStatus.style.color = '#888';
            
            if (stepsPerEpoch) stepsPerEpoch.textContent = '‚Äî';
            
            // Disable reveal controls
            if (revealControls) {
                revealControls.style.opacity = '0.5';
                revealControls.style.pointerEvents = 'none';
            }
            
            // Reset reveal options
            revealOptions.showHeldOut = false;
            revealOptions.showRecipe = false;
            const showHeldOutCheckbox = document.getElementById('showHeldOut');
            const showRecipeCheckbox = document.getElementById('showRecipe');
            if (showHeldOutCheckbox) showHeldOutCheckbox.checked = false;
            if (showRecipeCheckbox) showRecipeCheckbox.checked = false;
        }
    }
    
    // Show full data in a popup/modal
    function showFullDataView() {
        if (!dataset.generated) return;
        
        const formatPoint = (p, i) => `${(i+1).toString().padStart(3, ' ')}. x = ${p.x.toFixed(4).padStart(8, ' ')}  ‚Üí  y = ${p.y.toFixed(4)}`;
        
        // Sort by x for display
        const sortedTrain = [...dataset.train].sort((a, b) => a.x - b.x);
        const sortedTest = [...dataset.test].sort((a, b) => a.x - b.x);
        
        const trainText = sortedTrain.map((p, i) => formatPoint(p, i)).join('\n');
        const testText = sortedTest.map((p, i) => formatPoint(p, i)).join('\n');
        
        const fullText = `TRAINING DATA (${dataset.train.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${trainText}\n\n` +
            `HELD-OUT DATA (${dataset.test.length} points)\n` +
            `${'='.repeat(40)}\n` +
            `${testText}`;
        
        // Create a simple modal
        const modal = document.createElement('div');
        modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:1000;';
        modal.innerHTML = `
            <div style="background:white; border-radius:8px; padding:16px; max-width:600px; max-height:80vh; overflow:auto; box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
                    <h3 style="margin:0; font-size:16px;">Generated Data (input ‚Üí output)</h3>
                    <button id="closeDataModal" style="padding:4px 12px; font-size:12px;">Close</button>
                </div>
                <pre style="font-size:11px; background:#f5f5f5; padding:12px; border-radius:4px; overflow:auto; max-height:60vh; margin:0;">${fullText}</pre>
                <div style="margin-top:12px; font-size:10px; color:#666;">
                    <strong>Note:</strong> The model only sees the training data. Held-out data is used to test if the model learned the underlying pattern (generalization) vs. just memorizing the training points (overfitting).
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target.id === 'closeDataModal') {
                document.body.removeChild(modal);
            }
        });
    }
    
    // Clear dataset and return to Phase 1
    function clearDataset() {
        dataset.generated = false;
        dataset.train = [];
        dataset.test = [];
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.shuffleOrder = [];
        dataset.totalEpochs = 0;
        
        // Also reset the model
        resetModel();
        updatePhaseUI();
    }
    
    // Reset just the model (keep data)
    // Reset training state only (keeps loss surface, for optimizer/LR changes)
    function resetTraining() {
        trainingState.running = false;
        trainingState.animating = false;
        trainingState.step = 0;
        trainingState.totalAdds = 0;
        trainingState.totalMuls = 0;
        trainingState.lastUpdateTime = performance.now();
        trainingState.stepsSinceLastUpdate = 0;
        trainingState.recentSamples = [];
        
        const runBtn = document.getElementById('runBtn');
        if (runBtn) runBtn.textContent = 'Run';
        
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        if (dataset.generated) {
            shuffleTrainingOrder();
        }
        
        history.steps = [];
        history.loss = [];
        history.testLoss = [];
        history.avgLoss = [];
        history.weights = [];
        
        traceViewState.maxStep = Infinity;
        const resetViewSlider = document.getElementById('viewSlider');
        if (resetViewSlider) {
            resetViewSlider.value = resetViewSlider.max;
            const viewValue = document.getElementById('viewValue');
            if (viewValue) viewValue.textContent = 'All';
        }
        
        revealOptions.evaluated = false;
        exitComparisonMode();
        
        // Reset optimizer state but keep network weights structure
        initializeOptimizerState();
        
        // Restore weights to base (same starting point)
        if (lossSurfaceBaseWeights && lossSurfaceBaseBiases) {
            network.weights = lossSurfaceBaseWeights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            network.biases = lossSurfaceBaseBiases.map(layer => layer.slice());
        }
        
        // Reset trail but keep the loss surface
        if (lossSurfaceCache && lossSurfaceCache.startPos) {
            const startPos = lossSurfaceCache.startPos;
            setWeightByIndex(lossSurfaceWeightIndices[0], startPos.wx);
            setWeightByIndex(lossSurfaceWeightIndices[1], startPos.wy);
            lossSurfaceStartPosition = { x: startPos.wx, y: startPos.wy };
        } else {
            lossSurfaceStartPosition = {
                x: getWeightByIndex(lossSurfaceWeightIndices[0]),
                y: getWeightByIndex(lossSurfaceWeightIndices[1])
            };
        }
        lossSurfaceTrail = [lossSurfaceStartPosition];
        
        // Reset view bounds to full grid
        if (lossSurfaceCache) {
            const { minX, maxX, minY, maxY } = lossSurfaceCache;
            lossSurfaceViewBounds = { minX, maxX, minY, maxY };
        }
        
        // Restore original loss surface (remove any refinements)
        if (lossSurfaceOriginalGrid && lossSurfaceCache) {
            lossSurfaceCache.grid = lossSurfaceOriginalGrid.map(row => 
                row.map(cell => ({ loss: cell.loss, wx: cell.wx, wy: cell.wy }))
            );
        }
        
        // Compute initial losses
        if (dataset.generated) {
            const trainLoss = computeTrainLoss();
            const testLoss = computeTestLoss();
            history.steps = [0];
            history.loss = [trainLoss];
            history.avgLoss = [null];
            history.testLoss = [{ step: 0, loss: testLoss }];
            
            const flatWeights = [];
            network.weights.forEach(layer => {
                if (Array.isArray(layer[0])) {
                    layer.forEach(row => row.forEach(w => flatWeights.push(w)));
                } else {
                    layer.forEach(w => flatWeights.push(w));
                }
            });
            history.weights = [flatWeights];
        }
        
        updateUI();
        drawLossSurface();
        drawTrainingTrace();
    }
    
    // Full model reset (recomputes loss surface, for network structure changes)
    function resetModel() {
        trainingState.running = false;
        trainingState.animating = false;
        trainingState.step = 0;
        trainingState.totalAdds = 0;
        trainingState.totalMuls = 0;
        trainingState.lastUpdateTime = performance.now();
        trainingState.stepsSinceLastUpdate = 0;
        trainingState.recentSamples = [];
        
        // Reset Run button text
        const runBtn = document.getElementById('runBtn');
        if (runBtn) runBtn.textContent = 'Run';
        
        // Reset epoch tracking
        dataset.epoch = 0;
        dataset.stepInEpoch = 0;
        dataset.totalEpochs = 0;
        if (dataset.generated) {
            shuffleTrainingOrder();
        }
        
        history.steps = [];
        history.loss = [];
        history.testLoss = [];
        history.avgLoss = [];
        history.weights = [];
        
        // Reset trace view to show all
        traceViewState.maxStep = Infinity;
        const resetViewSlider = document.getElementById('viewSlider');
        if (resetViewSlider) {
            resetViewSlider.value = resetViewSlider.max;
            const viewValue = document.getElementById('viewValue');
            if (viewValue) viewValue.textContent = 'All';
        }
        
        // Reset evaluation state - must re-evaluate after model reset
        revealOptions.evaluated = false;
        
        exitComparisonMode();
        initializeNetwork();
        
        // Save initial weights as base for mini-training (ensures consistency)
        lossSurfaceBaseWeights = network.weights.map(layer => 
            Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
        );
        lossSurfaceBaseBiases = network.biases.map(layer => layer.slice());
        
        // Repopulate weight selectors and recompute loss surface
        populateWeightSelectors();
        lossSurfaceCache = null;
        lossSurfaceOriginalGrid = null;  // Clear original grid backup
        lossSurfaceTrail = [];
        lossSurfaceViewBounds = null;  // Reset view bounds for slow zoom
        
        // Reset color scale calibration - will recalibrate on next computeLossSurface
        lossColorScale.calibrated = false;
        
        if (lossLandscapeAutoMode) {
            autoSelectInterestingWeights();
        }
        
        // Debounce the expensive loss surface computation
        // Only compute if training data has been generated
        if (lossSurfaceComputeTimeout) {
            clearTimeout(lossSurfaceComputeTimeout);
        }
        // Abort any ongoing computation
        lossSurfaceAbort = true;
        
        if (dataset.generated) {
            lossSurfaceComputeTimeout = setTimeout(() => {
                lossSurfaceAbort = false;  // Reset abort flag for new computation
                computeLossSurface();
                
                // After computing surface, set weights to random high-loss position
                if (lossSurfaceCache && lossSurfaceCache.startPos && lossSurfaceCache.minLossPos) {
                    const startPos = lossSurfaceCache.startPos;
                    const minPos = lossSurfaceCache.minLossPos;
                    
                    // Set w1, w2 to random high-loss position (other weights stay random)
                    setWeightByIndex(lossSurfaceWeightIndices[0], startPos.wx);
                    setWeightByIndex(lossSurfaceWeightIndices[1], startPos.wy);
                    
                    // Update start position and trail
                    lossSurfaceStartPosition = { x: startPos.wx, y: startPos.wy };
                    lossSurfaceTrail = [lossSurfaceStartPosition];
                    
                    // Start with FULL grid view (centered on origin)
                    // Slow zoom will gradually zoom IN to focus on the trail
                    const { minX: gridMinX, maxX: gridMaxX, minY: gridMinY, maxY: gridMaxY } = lossSurfaceCache;
                    lossSurfaceViewBounds = {
                        minX: gridMinX,
                        maxX: gridMaxX,
                        minY: gridMinY,
                        maxY: gridMaxY
                    };
                    
                    // Recompute initial losses with new weights
                    const trainLoss = computeTrainLoss();
                    const testLoss = computeTestLoss();
                    history.steps = [0];
                    history.loss = [trainLoss];
                    history.avgLoss = [null];
                    history.testLoss = [{ step: 0, loss: testLoss }];
                    
                    // Record initial weights
                    const flatWeights = [];
                    network.weights.forEach(layer => {
                        if (Array.isArray(layer[0])) {
                            layer.forEach(row => row.forEach(w => flatWeights.push(w)));
                        } else {
                            layer.forEach(w => flatWeights.push(w));
                        }
                    });
                    history.weights = [flatWeights];
                    
                    console.log(`Starting at random high-loss: (${startPos.wx.toFixed(2)}, ${startPos.wy.toFixed(2)}) loss=${startPos.loss?.toFixed(4) || 'N/A'}`);
                    console.log(`Goal at min-loss: (${minPos.wx.toFixed(2)}, ${minPos.wy.toFixed(2)}) loss=${lossSurfaceCache.minLoss.toExponential(2)}`);
                }
                
                updateLossScaleLegend();
                drawLossSurface();  // Render the computed surface
                drawTrainingTrace();
                updateUI();
            }, 400);  // 400ms delay - user can keep dragging sliders
        }
        
        // Draw immediately with whatever we have (will show empty/stale surface briefly)
        drawLossSurface();
        
        // Temporary start position (will be updated after loss surface computation)
        lossSurfaceStartPosition = {
            x: getWeightByIndex(lossSurfaceWeightIndices[0]),
            y: getWeightByIndex(lossSurfaceWeightIndices[1])
        };
        lossSurfaceTrail = [lossSurfaceStartPosition];
        
        // Compute initial losses if data exists (will be recomputed after surface with max-loss position)
        if (dataset.generated) {
            const trainLoss = computeTrainLoss();
            const testLoss = computeTestLoss();
            
            history.steps.push(0);
            history.loss.push(trainLoss);
            history.avgLoss.push(null);
            history.testLoss.push({ step: 0, loss: testLoss });
            
            // Record initial weights
            const flatWeights = [];
            network.weights.forEach(layer => {
                if (Array.isArray(layer[0])) {
                    layer.forEach(row => row.forEach(w => flatWeights.push(w)));
                } else {
                    layer.forEach(w => flatWeights.push(w));
                }
            });
            history.weights.push(flatWeights);
        }
        
        updatePhaseUI();
        updateUI();
        
        // Force redraw all charts to initial state
        drawNetwork();
        drawFitPlot();
        drawTrainingTrace();
        drawLossSurface();
    }

    function forward(x) {
        const act = activationFns[config.activation].fn;
        const L = network.numLayers;
        const H = network.hiddenSize;

        const activations = [];
        const zValues = [];

        activations.push([x]);

        // Layer 1
        const w0 = network.weights[0];   // [H]
        const b0 = network.biases[0];    // [H]
        let z = new Array(H);
        let a = new Array(H);
        for (let i = 0; i < H; i++) {
            const zi = w0[i] * x + b0[i];
            z[i] = zi;
            a[i] = act(zi);
        }
        zValues.push(z);
        activations.push(a);

        // Hidden layers 2..L
        for (let l = 1; l < L; l++) {
            const w = network.weights[l];  // [H,H]
            const b = network.biases[l];   // [H]
            const prev = activations[activations.length - 1];

            z = new Array(H);
            a = new Array(H);
            for (let i = 0; i < H; i++) {
                let zi = b[i];
                const wi = w[i];
                for (let j = 0; j < H; j++) {
                    zi += wi[j] * prev[j];
                }
                z[i] = zi;
                a[i] = act(zi);
            }
            zValues.push(z);
            activations.push(a);
        }

        // Output
        const last = activations[activations.length - 1];
        const wOut = network.weights[network.weights.length - 1]; // [H]
        const bOut = network.biases[network.biases.length - 1][0];
        let yhat = bOut;
        for (let i = 0; i < H; i++) {
            yhat += wOut[i] * last[i];
        }

        return { yhat, activations, zValues };
    }

    function backward(x, y, forwardResult) {
        const activations = forwardResult.activations;
        const zValues = forwardResult.zValues;
        const H = network.hiddenSize;
        const L = network.numLayers;
        
        // Use cached arrays and activation derivative
        const deltaNext = backwardCache.deltaNext;
        const deltaPrev = backwardCache.deltaPrev;
        const delta = backwardCache.delta;
        const actPrime = backwardCache.actPrime;

        const error = forwardResult.yhat - y;
        const loss = 0.5 * error * error;

        // Initialize grads
        for (let l = 0; l < grads.weights.length; l++) {
            const gwl = grads.weights[l];
            if (Array.isArray(gwl[0])) {
                for (let i = 0; i < gwl.length; i++) gwl[i].fill(0);
            } else {
                gwl.fill(0);
            }
            grads.biases[l].fill(0);
        }

        // Output layer
        const deltaOut = error;
        const hL = activations[activations.length - 1];
        const outGrads = grads.weights[grads.weights.length - 1];
        const outWeights = network.weights[network.weights.length - 1];

        for (let i = 0; i < H; i++) {
            outGrads[i] = deltaOut * hL[i];
            deltaNext[i] = outWeights[i] * deltaOut;
        }
        grads.biases[grads.biases.length - 1][0] = deltaOut;

        for (let l = L - 1; l >= 0; l--) {
            const z = zValues[l];
            for (let i = 0; i < H; i++) {
                delta[i] = deltaNext[i] * actPrime(z[i]);
            }

            const gW = grads.weights[l];
            const gB = grads.biases[l];

            if (l === 0) {
                // First layer: input is x (scalar)
                for (let i = 0; i < H; i++) {
                    gW[i] = delta[i] * x;
                    gB[i] = delta[i];
                }
            } else {
                // Hidden layers: input is previous layer's activations
                const prev = activations[l];
                for (let i = 0; i < H; i++) {
                    const gWi = gW[i];
                    const di = delta[i];
                    for (let j = 0; j < H; j++) {
                        gWi[j] = di * prev[j];
                    }
                    gB[i] = di;
                }
            }

            if (l > 0) {
                const w = network.weights[l];
                for (let j = 0; j < H; j++) deltaPrev[j] = 0;
                for (let i = 0; i < H; i++) {
                    const wi = w[i];
                    const di = delta[i];
                    for (let j = 0; j < H; j++) {
                        deltaPrev[j] += wi[j] * di;
                    }
                }
                for (let j = 0; j < H; j++) deltaNext[j] = deltaPrev[j];
            }
        }

        return loss;
    }

    // --------------- Training Loop ------------------

    function trainStep() {
        trainingState.stepsSinceLastUpdate++;
        trainingState.step++;
        
        // Advance through the dataset
        if (dataset.generated) {
            dataset.stepInEpoch++;
            
            // Check if we've completed an epoch
            if (dataset.stepInEpoch >= dataset.train.length) {
                dataset.epoch++;
                dataset.totalEpochs++;
                dataset.stepInEpoch = 0;
                shuffleTrainingOrder();  // Reshuffle for next epoch
                
                // Update epoch display
                const epochCount = document.getElementById('epochCount');
                if (epochCount) epochCount.textContent = dataset.epoch;
            }
        }

        const sample = sampleTrainingPoint();
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);

        // Check for NaN - if detected, stop training and warn
        if (!Number.isFinite(loss) || !Number.isFinite(fwd.yhat)) {
            console.warn('NaN detected in training - stopping. Try reducing learning rate or resetting.');
            trainingState.running = false;
            return;
        }

        updateParameters();

        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Accumulate gradients for epoch averaging
        if (lossSurfaceWeightIndices && grads) {
            const g1 = getGradByIndex(lossSurfaceWeightIndices[0]);
            const g2 = getGradByIndex(lossSurfaceWeightIndices[1]);
            if (!trainingState.epochGradSum) {
                trainingState.epochGradSum = { w1: 0, w2: 0, count: 0 };
            }
            trainingState.epochGradSum.w1 += g1;
            trainingState.epochGradSum.w2 += g2;
            trainingState.epochGradSum.count++;
        }
        
        // Note: Color scale is fixed after initial calibration to avoid jarring changes
        // The refinement process will add detail without changing the overall color mapping
        
        // Evaluate test loss at epoch boundaries (smoother curve)
        if (dataset.generated && dataset.stepInEpoch === 0) {
            const testLoss = computeTestLoss();
            history.testLoss.push({ step: trainingState.step, loss: testLoss, epoch: dataset.epoch });
            
            // Report epoch-averaged gradient on (w1, w2) plane
            if (trainingState.epochGradSum && trainingState.epochGradSum.count > 0) {
                const avgG1 = trainingState.epochGradSum.w1 / trainingState.epochGradSum.count;
                const avgG2 = trainingState.epochGradSum.w2 / trainingState.epochGradSum.count;
                const avgMag = Math.sqrt(avgG1*avgG1 + avgG2*avgG2);
                const angle = Math.atan2(-avgG2, -avgG1) * 180 / Math.PI;
                
                // Store for arrow display
                trainingState.lastEpochGrad = { w1: avgG1, w2: avgG2, mag: avgMag, angle };
                
                // Maintain running average over last 20 epochs
                if (!trainingState.epochGradHistory) {
                    trainingState.epochGradHistory = [];
                }
                trainingState.epochGradHistory.push({ w1: avgG1, w2: avgG2 });
                if (trainingState.epochGradHistory.length > 20) {
                    trainingState.epochGradHistory.shift();
                }
                
                // Compute long-term average
                let longAvgG1 = 0, longAvgG2 = 0;
                for (const g of trainingState.epochGradHistory) {
                    longAvgG1 += g.w1;
                    longAvgG2 += g.w2;
                }
                longAvgG1 /= trainingState.epochGradHistory.length;
                longAvgG2 /= trainingState.epochGradHistory.length;
                const longAvgMag = Math.sqrt(longAvgG1*longAvgG1 + longAvgG2*longAvgG2);
                
                // Log every 20 epochs
                if (dataset.epoch % 20 === 0) {
                    console.log(`Epoch ${dataset.epoch}: grad=[${avgG1.toExponential(2)}, ${avgG2.toExponential(2)}], loss=${testLoss.toExponential(2)}`);
                }
                
                // Reset accumulator for next epoch
                trainingState.epochGradSum = { w1: 0, w2: 0, count: 0 };
            }
        }
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);

        const window = config.avgWindow;
        let sum = 0;
        let count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < window; i--, count++) {
            sum += history.loss[i];
        }
        // Only show meaningful average after we have at least 10 data points
        const minPointsForAvg = 10;
        if (history.loss.length >= minPointsForAvg) {
            history.avgLoss.push(sum / count);
        } else {
            history.avgLoss.push(null);  // Will be skipped when drawing
        }

        const maxSamples = 500;
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > maxSamples) {
            trainingState.recentSamples.shift();
        }

        // Accumulate actual ops count
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        // Update loss surface trail - adaptive sampling for full history
        // Record more frequently at start, less frequently as training progresses
        const trailInterval = trainingState.step < 100 ? 2 : 
                             trainingState.step < 1000 ? 5 : 
                             trainingState.step < 5000 ? 10 : 20;
        if (trainingState.step % trailInterval === 0 && lossSurfaceCache) {
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            lossSurfaceTrail.push({ x: wx, y: wy });
            // No limit - keep full history for complete path visualization
        }
        
        // Loss surface display with "slow zoom" - view bounds expand to keep trail visible
        if (lossSurfaceAutoUpdate && lossSurfaceCache && trainingState.step % lossSurfaceUpdateInterval === 0) {
            // Periodically refine loss surface (every 500 steps for smoother transitions)
            if (trainingState.step % 500 === 0 && trainingState.step > 0) {
                // Run async to avoid blocking training
                setTimeout(() => {
                    try {
                        refineLowLossRegions();
                    } catch (e) {
                        console.error('Refinement error:', e);
                    }
                }, 0);
            }
            
            // Debug: log zoom state every 2000 steps
            if (trainingState.step % 2000 === 0 && lossSurfaceViewBounds) {
                const vw = (lossSurfaceViewBounds.maxX - lossSurfaceViewBounds.minX).toFixed(2);
                const vh = (lossSurfaceViewBounds.maxY - lossSurfaceViewBounds.minY).toFixed(2);
                console.log(`Step ${trainingState.step}: view ${vw}√ó${vh}, trail points: ${lossSurfaceTrail.length}`);
            }
            const wx = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const wy = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const { minX: gridMinX, maxX: gridMaxX, minY: gridMinY, maxY: gridMaxY } = lossSurfaceCache;
            
            // Initialize view bounds if needed
            if (!lossSurfaceViewBounds) {
                lossSurfaceViewBounds = {
                    minX: gridMinX,
                    maxX: gridMaxX,
                    minY: gridMinY,
                    maxY: gridMaxY
                };
            }
            
            if (lossSurfaceViewBounds) {
                // "Slow zoom IN" - gradually shrink view to focus on trail
                const trailPad = 0.2;     // Minimum padding around trail
                const shrinkRate = 0.02;  // How fast to zoom in (per update)
                const centerRate = 0.03;  // How fast center follows trail
                const minViewSize = 0.8;  // Don't zoom in smaller than this
                
                // Calculate trail bounding box (including start position)
                let trailMinX = wx, trailMaxX = wx, trailMinY = wy, trailMaxY = wy;
                if (lossSurfaceStartPosition) {
                    trailMinX = Math.min(trailMinX, lossSurfaceStartPosition.x);
                    trailMaxX = Math.max(trailMaxX, lossSurfaceStartPosition.x);
                    trailMinY = Math.min(trailMinY, lossSurfaceStartPosition.y);
                    trailMaxY = Math.max(trailMaxY, lossSurfaceStartPosition.y);
                }
                for (const pt of lossSurfaceTrail) {
                    trailMinX = Math.min(trailMinX, pt.x);
                    trailMaxX = Math.max(trailMaxX, pt.x);
                    trailMinY = Math.min(trailMinY, pt.y);
                    trailMaxY = Math.max(trailMaxY, pt.y);
                }
                
                // Calculate target view: trail bounding box + padding, at least minViewSize
                const trailW = trailMaxX - trailMinX;
                const trailH = trailMaxY - trailMinY;
                const targetW = Math.max(minViewSize, trailW + trailPad * 2);
                const targetH = Math.max(minViewSize, trailH + trailPad * 2);
                const targetCenterX = (trailMinX + trailMaxX) / 2;
                const targetCenterY = (trailMinY + trailMaxY) / 2;
                
                // Current view dimensions
                let viewW = lossSurfaceViewBounds.maxX - lossSurfaceViewBounds.minX;
                let viewH = lossSurfaceViewBounds.maxY - lossSurfaceViewBounds.minY;
                let viewCenterX = (lossSurfaceViewBounds.minX + lossSurfaceViewBounds.maxX) / 2;
                let viewCenterY = (lossSurfaceViewBounds.minY + lossSurfaceViewBounds.maxY) / 2;
                
                // Move center toward target
                viewCenterX += (targetCenterX - viewCenterX) * centerRate;
                viewCenterY += (targetCenterY - viewCenterY) * centerRate;
                
                // Shrink dimensions toward target (but never expand - that happens instantly if needed)
                if (viewW > targetW) {
                    viewW = Math.max(targetW, viewW * (1 - shrinkRate));
                } else if (viewW < targetW) {
                    viewW = targetW; // Expand instantly if trail goes outside
                }
                if (viewH > targetH) {
                    viewH = Math.max(targetH, viewH * (1 - shrinkRate));
                } else if (viewH < targetH) {
                    viewH = targetH; // Expand instantly if trail goes outside
                }
                
                // Apply new bounds
                lossSurfaceViewBounds.minX = viewCenterX - viewW / 2;
                lossSurfaceViewBounds.maxX = viewCenterX + viewW / 2;
                lossSurfaceViewBounds.minY = viewCenterY - viewH / 2;
                lossSurfaceViewBounds.maxY = viewCenterY + viewH / 2;
                
                // SHIFT (not clamp) view bounds to stay within grid
                // This keeps the ball centered while staying in bounds
                const currentW = lossSurfaceViewBounds.maxX - lossSurfaceViewBounds.minX;
                const currentH = lossSurfaceViewBounds.maxY - lossSurfaceViewBounds.minY;
                
                // Shift X if needed
                if (lossSurfaceViewBounds.minX < gridMinX) {
                    lossSurfaceViewBounds.minX = gridMinX;
                    lossSurfaceViewBounds.maxX = gridMinX + currentW;
                }
                if (lossSurfaceViewBounds.maxX > gridMaxX) {
                    lossSurfaceViewBounds.maxX = gridMaxX;
                    lossSurfaceViewBounds.minX = gridMaxX - currentW;
                }
                
                // Shift Y if needed
                if (lossSurfaceViewBounds.minY < gridMinY) {
                    lossSurfaceViewBounds.minY = gridMinY;
                    lossSurfaceViewBounds.maxY = gridMinY + currentH;
                }
                if (lossSurfaceViewBounds.maxY > gridMaxY) {
                    lossSurfaceViewBounds.maxY = gridMaxY;
                    lossSurfaceViewBounds.minY = gridMaxY - currentH;
                }
                
                // Final safety clamp (in case view is larger than grid)
                lossSurfaceViewBounds.minX = Math.max(lossSurfaceViewBounds.minX, gridMinX);
                lossSurfaceViewBounds.maxX = Math.min(lossSurfaceViewBounds.maxX, gridMaxX);
                lossSurfaceViewBounds.minY = Math.max(lossSurfaceViewBounds.minY, gridMinY);
                lossSurfaceViewBounds.maxY = Math.min(lossSurfaceViewBounds.maxY, gridMaxY);
            }
            
            // Keep color scale locked to initial surface range
            // (Don't extend it during training - this makes the surface look uniformly "high")
            // The training point may achieve lower loss than shown on surface because
            // the surface is computed with fixed other weights, while training optimizes all.
            
            drawLossSurface();
        }
        
        // Update epoch status display
        if (dataset.generated) {
            const epochStatus = document.getElementById('epochStatus');
            if (epochStatus) {
                epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
            }
        }
    }

    function runLoop() {
        if (!trainingState.running) return;

        const now = performance.now();
        const stepsPerFrame = 10;
        for (let i = 0; i < stepsPerFrame; i++) {
            trainStep();
        }

        const elapsed = now - trainingState.lastUpdateTime;
        if (elapsed > 0) {
            const stepsPerSec = (stepsPerFrame * 1000) / elapsed;
            document.getElementById('stepsPerSec').textContent = stepsPerSec.toFixed(0);
        }

        trainingState.lastUpdateTime = now;

        updateUI();

        // Auto-pause if no improvement in last 1000 steps
        if (shouldAutoPause()) {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            console.log('Auto-paused: no improvement in last 1000 steps (< 1%)');
            return;
        }

        if (trainingState.running) {
            requestAnimationFrame(runLoop);
        }
    }

    // Full reset - clears data and returns to Phase 1
    function reset() {
        // Stop any ongoing GIF recording
        if (gifCapture.recording || gifCapture.timeout) {
            gifCapture.recording = false;
            gifCapture.gif = null;
            if (gifCapture.timeout) {
                clearTimeout(gifCapture.timeout);
                gifCapture.timeout = null;
            }
            const gifBtn = document.getElementById('gifBtn');
            if (gifBtn) {
                gifBtn.textContent = 'Capture GIF';
                gifBtn.disabled = false;
            }
        }
        
        // Clear dataset and reset model
        clearDataset();
        
        // Compile target function
        compileTargetFunc();
        
        updateUI();
    }

    // --------------- Drawing -----------------------

    function drawNetwork(animState = null) {
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        
        ctx.clearRect(0, 0, w, h);
        
        const numLayers = network.numLayers;
        const hiddenSize = network.hiddenSize;
        
        // Animation state
        const isAnimating = animState !== null;
        const animPhase = animState?.phase;
        const animLayer = animState?.layer;
        
        // Layout calculations - input/output gaps are 50% of hidden layer spacing
        const marginLeft = 50;   // Increased for weight labels
        const marginRight = 80;  // Larger to fit y-hat node and weight labels
        const usableWidth = w - marginLeft - marginRight;
        
        // Calculate spacing: input-to-hidden and hidden-to-output are 0.5x the hidden-to-hidden spacing
        // Total segments: 0.5 + (numLayers-1) + 0.5 = numLayers for numLayers >= 1
        // For 1 hidden layer: 0.5 + 0.5 = 1 segment
        // For 2 hidden layers: 0.5 + 1 + 0.5 = 2 segments
        // For 3 hidden layers: 0.5 + 2 + 0.5 = 3 segments
        const totalSegments = numLayers;
        const hiddenLayerSpacing = usableWidth / totalSegments;
        const inputOutputGap = hiddenLayerSpacing * 0.5;  // 50% of hidden layer spacing
        
        const nodeRadius = 20;
        const fontSize = 14;
        const smallFont = 11;
        const weightFont = 9;  // Smaller font for weights
        
        // Calculate positions for each layer
        const layers = [];
        
        // Vertical center offset - move network up slightly to avoid caption overlap
        const yCenter = h/2 - 8;
        
        // Input layer - at left margin
        layers.push({x: marginLeft, nodes: [{y: yCenter}]});
        
        // Hidden layers - spread across the middle
        const hiddenStartX = marginLeft + inputOutputGap;
        for (let l = 0; l < numLayers; l++) {
            const x = hiddenStartX + hiddenLayerSpacing * l;
            const nodes = [];
            const spacing = Math.min(70, (h - 80) / (hiddenSize - 1 || 1));
            const startY = yCenter - (hiddenSize - 1) * spacing / 2;
            for (let i = 0; i < hiddenSize; i++) {
                nodes.push({y: startY + i * spacing});
            }
            layers.push({x, nodes});
        }
        
        // Output layer - at right margin
        layers.push({x: w - marginRight, nodes: [{y: yCenter}]});
        
        // Draw connections with weights
        ctx.font = `${weightFont}px sans-serif`;
        ctx.textAlign = 'center';
        
        // Helper to compute flat weight index for loss landscape highlighting
        function getWeightFlatIndex(layerIdx, fromIdx, toIdx) {
            let idx = 0;
            const H = hiddenSize;
            // Input to first hidden
            if (layerIdx === 0) return toIdx;
            idx += H;
            // Hidden to hidden
            for (let l = 1; l < layerIdx; l++) {
                idx += H * H;
            }
            if (layerIdx < numLayers) {
                return idx + fromIdx * H + toIdx;
            }
            idx += (numLayers - 1) * H * H;
            // Output layer
            return idx + fromIdx;
        }
        
        for (let l = 0; l < layers.length - 1; l++) {
            const fromLayer = layers[l];
            const toLayer = layers[l + 1];
            
            // Highlight during forward animation
            const shouldHighlight = isAnimating && animPhase === 'forward' && animLayer === l + 1;
            
            // Count total connections for offset calculation
            const totalConnections = fromLayer.nodes.length * toLayer.nodes.length;
            let connectionIdx = 0;
            
            // Check for backward pass highlighting
            const shouldHighlightBack = isAnimating && animPhase === 'backward' && animLayer === l + 1;
            
            fromLayer.nodes.forEach((fromNode, fromIdx) => {
                toLayer.nodes.forEach((toNode, toIdx) => {
                    // Check if this weight is selected for loss landscape
                    const flatIdx = getWeightFlatIndex(l, fromIdx, toIdx);
                    const isLossLandscapeWeight = (flatIdx === lossSurfaceWeightIndices[0] || flatIdx === lossSurfaceWeightIndices[1]);
                    
                    // Use green for forward pass, red for backward pass (matches Ops/Step table)
                    if (shouldHighlight) {
                        ctx.strokeStyle = '#28a745';  // Green for forward
                        ctx.lineWidth = 3;
                    } else if (shouldHighlightBack) {
                        ctx.strokeStyle = '#dc3545';  // Red for backward
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#007bff';
                        ctx.lineWidth = 1;
                    }
                    ctx.beginPath();
                    ctx.moveTo(fromLayer.x, fromNode.y);
                    ctx.lineTo(toLayer.x, toNode.y);
                    ctx.stroke();
                    
                    // Draw weight value on connection with horizontal offset to prevent overlap
                    // Offset based on connection index, spreading weights along the line
                    // Use narrower range (0.35-0.65) to keep weights away from edges
                    const t = totalConnections > 1 ? 0.35 + 0.3 * (connectionIdx / (totalConnections - 1)) : 0.5;
                    let labelX = fromLayer.x + (toLayer.x - fromLayer.x) * t;
                    let labelY = fromNode.y + (toNode.y - fromNode.y) * t;
                    
                    // Clamp to canvas bounds with padding
                    const textPadding = 20;
                    labelX = Math.max(textPadding, Math.min(w - textPadding, labelX));
                    labelY = Math.max(12, Math.min(h - 12, labelY));
                    
                    let weight;
                    if (l === 0) {
                        weight = network.weights[0][toIdx];
                    } else if (l < numLayers) {
                        weight = network.weights[l][fromIdx] ? network.weights[l][fromIdx][toIdx] : network.weights[l][toIdx];
                    } else {
                        weight = network.weights[network.weights.length - 1][fromIdx];
                    }
                    
                    if (weight !== undefined) {
                        // Draw small background for readability
                        const textWidth = ctx.measureText(weight.toFixed(2)).width;
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillRect(labelX - textWidth/2 - 2, labelY - 8, textWidth + 4, 11);
                        ctx.fillStyle = '#007bff';
                        ctx.fillText(weight.toFixed(2), labelX, labelY);
                        
                        // Subtle blue box for loss landscape weights
                        if (isLossLandscapeWeight) {
                            ctx.strokeStyle = '#007bff';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(labelX - textWidth/2 - 3, labelY - 9, textWidth + 6, 13);
                        }
                    }
                    connectionIdx++;
                });
            });
        }
        
        // Draw nodes - always use œÉ for activation symbol (standard ML notation)
        const actSymbol = 'œÉ';
        
        // Determine if we can show full equations (small networks only)
        const canShowFullEq = numLayers <= 2 && hiddenSize <= 4;
        const wideRadius = canShowFullEq ? nodeRadius * 2.2 : nodeRadius * 1.15;
        
        // Helper to format weight with sign
        const fmtW = (w) => {
            if (w === undefined || w === null) return '?';
            const val = w.toFixed(2);
            return w >= 0 ? `+${val}` : val;
        };
        const fmtWFirst = (w) => {
            if (w === undefined || w === null) return '?';
            return w.toFixed(2);
        };
        
        layers.forEach((layer, layerIdx) => {
            layer.nodes.forEach((node, nodeIdx) => {
                const nodeHighlight = isAnimating && animPhase === 'forward' && animLayer === layerIdx;
                const showGradients = isAnimating && animPhase === 'backward' && animLayer === layerIdx;
                
                if (layerIdx === 0) {
                    // Input node - small dot
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#333';
                    ctx.beginPath();
                    ctx.arc(layer.x, node.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (layerIdx === layers.length - 1) {
                    // Output node - wider oval
                    const outRadius = canShowFullEq ? wideRadius : nodeRadius * 1.3;
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#f0f8ff';
                    ctx.strokeStyle = '#6f42c1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, outRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Helper for subscript digits in output equation
                    const toSubOut = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
                    
                    if (canShowFullEq) {
                        // Full equation: y = w‚ÇÅ¬∑h‚ÇÅ + w‚ÇÇ¬∑h‚ÇÇ + ... + c (output weights use single subscript w_j)
                        const outputWeights = network.weights[network.weights.length - 1];
                        const outputBias = network.biases[network.biases.length - 1][0];
                        let eqParts = [];
                        for (let i = 0; i < hiddenSize && i < 4; i++) {
                            const wt = outputWeights[i];
                            // For single hidden layer: h_j
                            // For multiple layers: h_ij where i=numLayers (last layer), j=neuron
                            const hRef = numLayers === 1 
                                ? `h${toSubOut(i+1)}`
                                : `h${toSubOut(numLayers)}${toSubOut(i+1)}`;
                            if (i === 0) {
                                eqParts.push(`${fmtWFirst(wt)}¬∑${hRef}`);
                            } else {
                                eqParts.push(`${fmtW(wt)}¬∑${hRef}`);
                            }
                        }
                        if (hiddenSize > 4) eqParts.push('...');
                        
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('y', layer.x, node.y - 8);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Show equation on two lines if needed
                        const eq1 = eqParts.slice(0, 2).join('');
                        const eq2 = eqParts.slice(2).join('') + fmtW(outputBias);
                        ctx.fillText(eq1, layer.x, node.y + 4);
                        if (eq2.length > 3) {
                            ctx.fillText(eq2, layer.x, node.y + 13);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px sans-serif';
                        ctx.fillText('y', layer.x, node.y - 6);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText('Œ£w‚±º¬∑h‚±º+b', layer.x, node.y + 8);
                    }
                } else {
                    // Hidden node - oval with equation
                    ctx.fillStyle = nodeHighlight ? '#90EE90' : '#e3f2fd';
                    ctx.strokeStyle = '#007bff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(layer.x, node.y, wideRadius, nodeRadius, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Helper for subscript digits
                    const toSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
                    
                    // Notation: h_ij where i=layer, j=neuron (both subscripts)
                    // For single hidden layer, just h_j (neuron position only)
                    const hLabel = numLayers === 1 
                        ? `h${toSub(nodeIdx + 1)}`
                        : `h${toSub(layerIdx)}${toSub(nodeIdx + 1)}`;
                    
                    if (canShowFullEq) {
                        // Full equation: œÉ(w¬∑x + b) for first layer
                        // or œÉ(w‚ÇÅ¬∑h‚ÇÅ‚ÇÅ + w‚ÇÇ¬∑h‚ÇÅ‚ÇÇ + ... + b) for subsequent layers
                        let eqStr = '';
                        if (layerIdx === 1) {
                            // First hidden layer: input is x
                            const w = network.weights[0][nodeIdx];
                            const b = network.biases[0][nodeIdx];
                            eqStr = `${actSymbol}(${fmtWFirst(w)}¬∑x${fmtW(b)})`;
                        } else {
                            // Subsequent hidden layers - reference previous layer's h values (h_ij notation)
                            const prevLayerSize = hiddenSize;
                            const layerWeights = network.weights[layerIdx - 1];
                            const bias = network.biases[layerIdx - 1][nodeIdx];
                            let terms = [];
                            for (let i = 0; i < prevLayerSize && i < 3; i++) {
                                const w = layerWeights[i] ? layerWeights[i][nodeIdx] : layerWeights[nodeIdx];
                                // Previous layer h values: h_ij where i=layerIdx-1, j=neuron
                                const prevH = numLayers === 1 ? `h${toSub(i+1)}` : `h${toSub(layerIdx-1)}${toSub(i+1)}`;
                                if (i === 0) {
                                    terms.push(`${fmtWFirst(w)}¬∑${prevH}`);
                                } else {
                                    terms.push(`${fmtW(w)}¬∑${prevH}`);
                                }
                            }
                            if (prevLayerSize > 3) terms.push('...');
                            eqStr = `${actSymbol}(${terms.join('')}${fmtW(bias)})`;
                        }
                        
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize - 1}px sans-serif`;
                        ctx.fillText(hLabel, layer.x, node.y - 6);
                        ctx.font = `${smallFont - 1}px sans-serif`;
                        ctx.fillStyle = '#333';
                        // Truncate if too long
                        if (eqStr.length > 20) {
                            ctx.fillText(eqStr.substring(0, 20), layer.x, node.y + 5);
                            ctx.fillText(eqStr.substring(20), layer.x, node.y + 14);
                        } else {
                            ctx.fillText(eqStr, layer.x, node.y + 6);
                        }
                    } else {
                        ctx.fillStyle = '#000';
                        ctx.font = `bold ${fontSize}px sans-serif`;
                        ctx.fillText(hLabel, layer.x, node.y - 4);
                        ctx.font = `${smallFont}px sans-serif`;
                        ctx.fillStyle = '#555';
                        ctx.fillText(`${actSymbol}(z)`, layer.x, node.y + 8);
                    }
                }
            });
        });
        
        // Draw bias values for all non-input nodes
        // Helper for subscript digits in bias labels
        const toBiasSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
        
        ctx.font = '8px sans-serif';
        ctx.textAlign = 'center';
        layers.forEach((layer, layerIdx) => {
            if (layerIdx === 0) return;  // Skip input layer
            
            layer.nodes.forEach((node, nodeIdx) => {
                let bias = 0;
                let biasLabel = 'b';
                
                if (layerIdx < layers.length - 1) {
                    // Hidden layer bias: b_ij (layer, neuron)
                    bias = network.biases[layerIdx - 1] ? network.biases[layerIdx - 1][nodeIdx] : 0;
                    // For single layer: b_j, for multi-layer: b_ij
                    biasLabel = numLayers === 1 
                        ? `b${toBiasSub(nodeIdx + 1)}`
                        : `b${toBiasSub(layerIdx)}${toBiasSub(nodeIdx + 1)}`;
                } else {
                    // Output layer bias: just b (single bias for output)
                    bias = network.biases[network.biases.length - 1] ? network.biases[network.biases.length - 1][0] : 0;
                    biasLabel = 'b';
                }
                
                // Draw bias value below node (closer to bubble)
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                const biasText = `${biasLabel}=${bias.toFixed(1)}`;
                const textW = ctx.measureText(biasText).width;
                ctx.fillRect(layer.x - textW/2 - 1, node.y + nodeRadius - 1, textW + 2, 10);
                ctx.fillStyle = '#e67e22';
                ctx.fillText(biasText, layer.x, node.y + nodeRadius + 7);
            });
        });
        
        // Input label - larger and bolder
        ctx.fillStyle = '#333';
        ctx.font = 'bold 18px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('x', layers[0].x, layers[0].nodes[0].y - 12);
        
        // Show current values: x, t (target), y (prediction), and E (error)
        if (trainingState.recentSamples.length > 0) {
            const lastSample = trainingState.recentSamples[trainingState.recentSamples.length - 1];
            const lastLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : null;
            
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#333';
            
            // Left side: input and target (t for target)
            ctx.fillText(`x = ${lastSample.x.toFixed(3)}`, 8, 18);
            ctx.fillText(`t = ${lastSample.y.toFixed(3)}`, 8, 32);
            
            // Right side: prediction (y) and error (E)
            ctx.textAlign = 'right';
            if (history.loss.length > 0) {
                const fwd = forward(lastSample.x);
                ctx.fillText(`y = ${fwd.yhat.toFixed(3)}`, w - 8, 18);
                ctx.fillStyle = lastLoss < 0.01 ? '#28a745' : '#dc3545';
                ctx.fillText(`E = ¬Ω(y‚àít)¬≤ = ${lastLoss.toFixed(4)}`, w - 8, 32);
            }
        }
        
        // Bottom: architecture info - larger font for readability
        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        const optName = config.optimizer === 'sgd' ? 'Simple' : 'Adam';
        const actName = config.activation === 'relu' ? 'ReLU' : 'Sigmoid';
        // Count total weights: first layer (H) + hidden layers ((L-1)*H*H) + output layer (H)
        const totalWeights = hiddenSize + (numLayers - 1) * hiddenSize * hiddenSize + hiddenSize;
        const totalBiases = numLayers * hiddenSize + 1;
        const totalParams = totalWeights + totalBiases;
        ctx.fillText(`${numLayers} hidden layer${numLayers > 1 ? 's' : ''} √ó ${hiddenSize} neurons  ‚Ä¢  ${totalParams} params  ‚Ä¢  œÉ = ${actName}  ‚Ä¢  ${optName}`, w/2, h - 6);
        
        // Update HTML Ops/Step table (check elements exist first)
        const ops = computeOpsPerStep();
        const opsFwdAdds = document.getElementById('opsFwdAdds');
        const opsFwdMuls = document.getElementById('opsFwdMuls');
        const opsBackAdds = document.getElementById('opsBackAdds');
        const opsBackMuls = document.getElementById('opsBackMuls');
        const opsTotAdds = document.getElementById('opsTotAdds');
        const opsTotMuls = document.getElementById('opsTotMuls');
        
        if (opsFwdAdds) opsFwdAdds.textContent = ops.fwdAdds;
        if (opsFwdMuls) opsFwdMuls.textContent = ops.fwdMuls;
        if (opsBackAdds) opsBackAdds.textContent = ops.backAdds;
        if (opsBackMuls) opsBackMuls.textContent = ops.backMuls;
        if (opsTotAdds) opsTotAdds.textContent = ops.fwdAdds + ops.backAdds;
        if (opsTotMuls) opsTotMuls.textContent = ops.fwdMuls + ops.backMuls;
    }
    
    // Animated step function
    async function animatedStep() {
        if (trainingState.animating) return;
        trainingState.animating = true;
        
        // Sample data
        const sample = sampleTrainingPoint();
        trainingState.recentSamples.push(sample);
        if (trainingState.recentSamples.length > 500) {
            trainingState.recentSamples.shift();
        }
        
        const numLayers = network.numLayers;
        const delayPerLayer = 300; // 0.3 seconds per layer
        
        // Animate forward pass
        drawNetwork({phase: 'forward', layer: 0});
        await sleep(delayPerLayer);
        
        for (let i = 1; i <= numLayers; i++) {
            drawNetwork({phase: 'forward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'forward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        // Compute forward and backward
        const fwd = forward(sample.x);
        const loss = backward(sample.x, sample.y, fwd);
        
        // Animate backward pass
        drawNetwork({phase: 'backward', layer: numLayers + 1});
        await sleep(delayPerLayer);
        
        for (let i = numLayers; i >= 1; i--) {
            drawNetwork({phase: 'backward', layer: i});
            await sleep(delayPerLayer);
        }
        
        drawNetwork({phase: 'backward', layer: 0});
        await sleep(delayPerLayer);
        
        // Update parameters
        updateParameters();
        
        // Update history
        trainingState.step++;
        history.steps.push(trainingState.step);
        history.loss.push(loss);
        
        // Record current weights (flatten all weights into a single array)
        const flatWeights = [];
        network.weights.forEach(layer => {
            if (Array.isArray(layer[0])) {
                layer.forEach(row => row.forEach(w => flatWeights.push(w)));
            } else {
                layer.forEach(w => flatWeights.push(w));
            }
        });
        history.weights.push(flatWeights);
        
        const windowSize = config.avgWindow;
        let sum = 0, count = 0;
        for (let i = history.loss.length - 1; i >= 0 && count < windowSize; i--, count++) {
            sum += history.loss[i];
        }
        history.avgLoss.push(sum / Math.max(1, count));
        
        // Update ops
        const ops = computeOpsPerStep();
        trainingState.totalAdds += ops.fwdAdds + ops.lossAdds + ops.backAdds;
        trainingState.totalMuls += ops.fwdMuls + ops.lossMuls + ops.backMuls;
        
        trainingState.animating = false;
        updateUI();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function updateEquations() {
        const L = network.numLayers;
        const H = network.hiddenSize;
        const act = config.activation;
        const actName = act === 'relu' ? 'ReLU' : 'Sigmoid';
        
        // Subscript numbers for cleaner notation
        const sub = (n) => ['‚ÇÄ','‚ÇÅ','‚ÇÇ','‚ÇÉ','‚ÇÑ'][n] || n;
        
        // Activation derivative in calculus terms (using œÉ for activation)
        const actDeriv = {
            'relu': "œÉ'(z) = 1 if z > 0, else 0  <em style='color:#888'>(no saturation!)</em>",
            'sigmoid': "œÉ'(z) = œÉ(z) ¬∑ (1 ‚àí œÉ(z))  <em style='color:#888'>(can vanish near 0 or 1)</em>"
        };
        
        let forwardHtml = `
            <strong>Setup:</strong> ${L} hidden layer${L>1?'s':''}, ${H} neurons each<br>
            <strong>Activation:</strong> œÉ = ${actName}<br><br>
        `;
        
        // Layer-by-layer forward with subscripts (using scalar notation)
        // Hidden layer: b_ij (layer i, neuron j), Output layer: b_j
        forwardHtml += `<span style="color:#F18F01">z</span><sub>ij</sub> = w<sub>ij</sub>¬∑x + b<sub>ij</sub>  <em style="color:#888">(weighted sum)</em><br>`;
        forwardHtml += `<span style="color:#28a745">h</span><sub>ij</sub> = œÉ(z<sub>ij</sub>)  <em style="color:#888">(activation)</em><br>`;
        forwardHtml += `<br><span style="color:#6f42c1">y</span> = w‚ÇÅh‚ÇÅ + w‚ÇÇh‚ÇÇ + ... + b  <em style="color:#888">(output)</em><br>`;
        forwardHtml += `<span style="color:#dc3545">E</span> = ¬Ω(y ‚àí t)¬≤  <em style="color:#888">(error)</em>`;
        
        // Backward pass with calculus notation (using E for error, y for prediction, t for target)
        let backwardHtml = `
            <strong>Loss derivative:</strong><br>
            <span style="color:#dc3545">‚àÇE/‚àÇy</span> = y ‚àí t<br><br>
            <strong>Output layer:</strong><br>
            ‚àÇE/‚àÇw<sub>j</sub> = (‚àÇE/‚àÇy) ¬∑ h<sub>j</sub><br>
            ‚àÇE/‚àÇb = ‚àÇE/‚àÇy<br><br>
            <strong>Hidden layer:</strong><br>
            ‚àÇE/‚àÇh<sub>ij</sub> = (‚àÇE/‚àÇy) ¬∑ w<sub>j</sub><br>
            ‚àÇh<sub>ij</sub>/‚àÇz<sub>ij</sub> = œÉ'(z<sub>ij</sub>)<br>
            <span style="color:#dc3545">‚àÇE/‚àÇz<sub>ij</sub></span> = (‚àÇE/‚àÇh<sub>ij</sub>)(‚àÇh<sub>ij</sub>/‚àÇz<sub>ij</sub>)<br><br>
            <strong>Hidden weights:</strong><br>
            ‚àÇE/‚àÇw<sub>ij</sub> = (‚àÇE/‚àÇz<sub>ij</sub>) ¬∑ x<br>
            ‚àÇE/‚àÇb<sub>ij</sub> = ‚àÇE/‚àÇz<sub>ij</sub><br>
        `;
        
        backwardHtml += `<br><strong>Activation derivative:</strong><br>${actDeriv[act]}`;
        
        // Optimizer explanation
        const optName = config.optimizer === 'sgd' ? 'Simple (SGD)' : 'Adam';
        const optExplain = config.optimizer === 'sgd' 
            ? `<strong>Weight Update:</strong><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ ‚àÇE/‚àÇw<br>
               <em style="color:#888">Each weight takes a small downhill step.</em>`
            : `<strong>Weight Update:</strong><br>
               m ‚Üê 0.9¬∑m + 0.1¬∑‚àáE <em style="color:#888">(momentum)</em><br>
               v ‚Üê 0.999¬∑v + 0.001¬∑(‚àáE)¬≤ <em style="color:#888">(adapt)</em><br>
               w ‚Üê w ‚àí Œ∑ ¬∑ m / ‚àöv<br>
               <em style="color:#888">Momentum smooths updates; adaptive rates help rare gradients.</em>`;
        
        const html = `
            <div class="equation-block">
                <div class="equation-title">Forward</div>
                <div class="math">${forwardHtml}</div>
            </div>
            <div class="equation-block">
                <div class="equation-title">Backward (Gradients)</div>
                <div class="math">${backwardHtml}</div>
                <br>
                <div class="equation-title" style="margin-top:8px;">Update: ${optName}</div>
                <div class="math">${optExplain}</div>
            </div>
        `;
        
        document.getElementById('equationsDiv').innerHTML = html;
    }


    function drawFitPlot() {
        const canvas = document.getElementById('fitCanvas');
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 60;
        const paddingRight = 60;
        const paddingTop = 40;
        const paddingBottom = 40;

        ctx.clearRect(0, 0, w, h);

        const xMin = config.xMin;
        const xMax = config.xMax;
        const xRange = xMax - xMin;

        const hasRunA = !!savedRuns.A;
        const hasRunB = !!savedRuns.B;
        const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

        // Generate model prediction curve
        const numPoints = 200;
        const modelPoints = [];
        let modelPointsA = null;
        let modelPointsB = null;

        for (let i = 0; i <= numPoints; i++) {
            const x = xMin + (i / numPoints) * xRange;
            if (comparisonMode) {
                if (!modelPointsA) modelPointsA = [];
                if (!modelPointsB) modelPointsB = [];
                const netA = savedRuns.A.network;
                const cfgA = savedRuns.A.config;
                const netB = savedRuns.B.network;
                const cfgB = savedRuns.B.config;
                modelPointsA.push({ x, y: forwardWithNetwork(x, netA, cfgA.activation) });
                modelPointsB.push({ x, y: forwardWithNetwork(x, netB, cfgB.activation) });
            } else {
                modelPoints.push({ x, y: forward(x).yhat });
            }
        }

        // Collect all Y values for axis range calculation
        let allY = [];
        
        // Always include target function range for consistent axis
        for (let i = 0; i <= 50; i++) {
            const x = xMin + (i / 50) * xRange;
            try { allY.push(config.targetFunc(x)); } catch { /* ignore */ }
        }
        
        // Include training and test data points in range
        if (dataset.generated) {
            dataset.train.forEach(p => allY.push(p.y));
            dataset.test.forEach(p => allY.push(p.y));
        }
        
        // Include model predictions if they're not too extreme
        const modelYs = comparisonMode 
            ? [...modelPointsA.map(p => p.y), ...modelPointsB.map(p => p.y)]
            : modelPoints.map(p => p.y);
        const dataYMin = allY.length > 0 ? Math.min(...allY) : -1;
        const dataYMax = allY.length > 0 ? Math.max(...allY) : 1;
        const dataYRange = dataYMax - dataYMin || 1;
        
        // Only include model Y values if they're within reasonable range (5x data range)
        modelYs.forEach(y => {
            if (Number.isFinite(y) && y >= dataYMin - dataYRange * 2 && y <= dataYMax + dataYRange * 2) {
                allY.push(y);
            }
        });

        let yMin = Math.min(...allY);
        let yMax = Math.max(...allY);
        if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
            yMin = -1;
            yMax = 1;
        }
        // Add 10% padding
        const yPad = (yMax - yMin) * 0.1 || 0.5;
        yMin -= yPad;
        yMax += yPad;
        const yRange = yMax - yMin || 1;

        const plotWidth = w - paddingLeft - paddingRight;
        const plotHeight = h - paddingTop - paddingBottom;
        const toCanvasX = (x) => paddingLeft + (x - xMin) / xRange * plotWidth;
        const toCanvasY = (y) => h - paddingBottom - (y - yMin) / yRange * plotHeight;

        // Draw plot border
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotWidth, plotHeight);

        // Draw X axis tick marks and labels
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        const numXTicks = 5;
        for (let i = 0; i <= numXTicks; i++) {
            const xVal = xMin + (i / numXTicks) * xRange;
            const cx = toCanvasX(xVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(cx, h - paddingBottom);
            ctx.lineTo(cx, h - paddingBottom + 5);
            ctx.stroke();
            ctx.fillText(xVal.toFixed(1), cx, h - paddingBottom + 16);
        }

        // Draw Y axis tick marks and labels
        ctx.textAlign = 'right';
        const numYTicks = 5;
        for (let i = 0; i <= numYTicks; i++) {
            const yVal = yMin + (i / numYTicks) * yRange;
            const cy = toCanvasY(yVal);
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(paddingLeft - 5, cy);
            ctx.lineTo(paddingLeft, cy);
            ctx.stroke();
            ctx.fillText(yVal.toFixed(2), paddingLeft - 8, cy + 3);
        }

        // Draw data recipe curve (only if revealing or no data yet)
        if (!dataset.generated || revealOptions.showRecipe) {
            const recipeAlpha = dataset.generated ? 0.4 : 0.3;
            ctx.strokeStyle = `rgba(40, 167, 69, ${recipeAlpha})`;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const x = xMin + (i / 100) * xRange;
                let y;
                try { y = config.targetFunc(x); } catch { y = 0; }
                const cx = toCanvasX(x);
                const cy = toCanvasY(y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw training examples (filled circles) - always shown when data exists
        if (dataset.generated && dataset.train.length > 0) {
            ctx.fillStyle = '#007bff';
            dataset.train.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Draw training range indicator (vertical bands showing where model was trained)
        if (dataset.generated && (config.trainXMin > config.dataXMin || config.trainXMax < config.dataXMax)) {
            ctx.fillStyle = 'rgba(0, 123, 255, 0.05)';
            const trainLeft = toCanvasX(config.trainXMin);
            const trainRight = toCanvasX(config.trainXMax);
            ctx.fillRect(trainLeft, paddingTop, trainRight - trainLeft, plotHeight);
            
            // Draw dashed vertical lines at training boundaries
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(trainLeft, paddingTop);
            ctx.lineTo(trainLeft, h - paddingBottom);
            ctx.moveTo(trainRight, paddingTop);
            ctx.lineTo(trainRight, h - paddingBottom);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw held-out examples - only if revealed
        if (dataset.generated && dataset.test.length > 0 && revealOptions.showHeldOut) {
            dataset.test.forEach((p) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                
                if (p.inTrainRange) {
                    // In-range test points: orange diamonds (interpolation test)
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                } else {
                    // Out-of-range test points: red diamonds (extrapolation test)
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 2;
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                }
                
                // Draw diamond shape
                ctx.beginPath();
                ctx.moveTo(cx, cy - 5);
                ctx.lineTo(cx + 4, cy);
                ctx.lineTo(cx, cy + 5);
                ctx.lineTo(cx - 4, cy);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
        }

        // Draw model prediction curve - clipped to plot area
        ctx.save();
        ctx.beginPath();
        ctx.rect(paddingLeft, paddingTop, plotWidth, plotHeight);
        ctx.clip();
        
        if (comparisonMode) {
            // Model A - blue
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsA.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();

            // Model B - orange
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            ctx.beginPath();
            modelPointsB.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        } else {
            // Single model - purple
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            modelPoints.forEach((p, i) => {
                const cx = toCanvasX(p.x);
                const cy = toCanvasY(p.y);
                if (i === 0) ctx.moveTo(cx, cy);
                else ctx.lineTo(cx, cy);
            });
            ctx.stroke();
        }
        ctx.restore();  // Remove clipping

        // Axis labels
        ctx.font = '11px sans-serif';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('x', w / 2, h - 8);
        ctx.save();
        ctx.translate(10, h / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('y', 0, 0);
        ctx.restore();

        // Legend
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'left';
        const legendY = 14;
        let legendX = w - 350;

        if (dataset.generated) {
            // Training examples - blue circle
            ctx.fillStyle = '#007bff';
            ctx.beginPath();
            ctx.arc(legendX + 4, legendY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillText(`Training (${dataset.train.length})`, legendX + 12, legendY + 3);
            legendX += 75;

            // Held-out examples (only if revealed)
            if (revealOptions.showHeldOut) {
                // In-range test points (interpolation)
                const inRangeCount = dataset.test.filter(p => p.inTrainRange).length;
                const outRangeCount = dataset.test.length - inRangeCount;
                
                if (inRangeCount > 0) {
                    ctx.strokeStyle = '#ff9800';
                    ctx.lineWidth = 1.5;
                    ctx.fillStyle = 'rgba(255, 152, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(legendX + 4, legendY - 4);
                    ctx.lineTo(legendX + 8, legendY);
                    ctx.lineTo(legendX + 4, legendY + 4);
                    ctx.lineTo(legendX, legendY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillText(`Held (${inRangeCount})`, legendX + 12, legendY + 3);
                    legendX += 55;
                }
                
                // Out-of-range test points (extrapolation)
                if (outRangeCount > 0) {
                    ctx.strokeStyle = '#dc3545';
                    ctx.lineWidth = 1.5;
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(legendX + 4, legendY - 4);
                    ctx.lineTo(legendX + 8, legendY);
                    ctx.lineTo(legendX + 4, legendY + 4);
                    ctx.lineTo(legendX, legendY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#333';
                    ctx.fillText(`Extrap (${outRangeCount})`, legendX + 12, legendY + 3);
                    legendX += 60;
                }
            }
            
            // Data recipe - green dashed (only if revealed)
            if (revealOptions.showRecipe) {
                ctx.strokeStyle = 'rgba(40, 167, 69, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 2]);
                ctx.beginPath();
                ctx.moveTo(legendX, legendY);
                ctx.lineTo(legendX + 16, legendY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#333';
                ctx.fillText('Recipe', legendX + 20, legendY + 3);
                legendX += 55;
            }
        } else {
            // No data yet - show recipe preview
            ctx.strokeStyle = 'rgba(40, 167, 69, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#333';
            ctx.fillText('Recipe preview', legendX + 20, legendY + 3);
            legendX += 95;
        }

        // Model prediction - purple line
        if (dataset.generated) {
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model', legendX + 20, legendY + 3);
        }

        if (comparisonMode) {
            legendX += 55;
            ctx.strokeStyle = '#ff9800';
            ctx.beginPath();
            ctx.moveTo(legendX, legendY);
            ctx.lineTo(legendX + 16, legendY);
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Model B', legendX + 20, legendY + 3);
        }
    }

    function drawTrainingTraceComparison(ctx, w, h,
                                     paddingLeft, paddingRight,
                                     paddingTop, paddingBottom,
                                     runA, runB,
                                     showLoss, showAvgLoss, useLogScale = false,
                                     viewEndStep = null) {
    if (!runA || !runB) return;

    // Apply view filtering if specified
    let filteredRunA = runA;
    let filteredRunB = runB;
    if (viewEndStep !== null) {
        // Find index where step exceeds viewEndStep
        const idxA = runA.steps.findIndex(s => s > viewEndStep);
        const endIdxA = idxA === -1 ? runA.steps.length : idxA;
        filteredRunA = {
            steps: runA.steps.slice(0, endIdxA),
            loss: runA.loss.slice(0, endIdxA),
            avgLoss: runA.avgLoss.slice(0, endIdxA)
        };
        
        const idxB = runB.steps.findIndex(s => s > viewEndStep);
        const endIdxB = idxB === -1 ? runB.steps.length : idxB;
        filteredRunB = {
            steps: runB.steps.slice(0, endIdxB),
            loss: runB.loss.slice(0, endIdxB),
            avgLoss: runB.avgLoss.slice(0, endIdxB)
        };
    }

    const series = [];

    if (showLoss) {
        series.push({
            name: 'Error A',
            steps: filteredRunA.steps,
            data: filteredRunA.loss,
            color: '#dc3545',
            lineWidth: 2
        });
        series.push({
            name: 'Error B',
            steps: filteredRunB.steps,
            data: filteredRunB.loss,
            color: '#ff9800',
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Loss A',
            steps: filteredRunA.steps,
            data: filteredRunA.avgLoss,
            color: '#007bff',
            lineWidth: 3
        });
        series.push({
            name: 'Avg Loss B',
            steps: filteredRunB.steps,
            data: filteredRunB.avgLoss,
            color: '#00bcd4',
            lineWidth: 3
        });
    }

    if (series.length === 0) return;

    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X (steps)
    let stepMin = Infinity;
    let stepMax = -Infinity;
    series.forEach(s => {
        if (s.steps.length > 0) {
            stepMin = Math.min(stepMin, s.steps[0]);
            stepMax = Math.max(stepMax, s.steps[s.steps.length - 1]);
        }
    });
    if (!Number.isFinite(stepMin) || !Number.isFinite(stepMax)) return;
    const stepRange = stepMax - stepMin || 1;

    // Y (loss, linear)
    let yMin = Infinity;
    let yMax = -Infinity;
    series.forEach(s => {
        s.data.forEach(v => {
            if (!Number.isFinite(v)) return;
            yMin = Math.min(yMin, v);
            yMax = Math.max(yMax, v);
        });
    });
    if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
        yMin = 0;
        yMax = 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(1e-6, Math.abs(yMin) * 0.1);
        yMin -= eps;
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMin -= pad;
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) =>
        h - paddingBottom - ((val - yMin) / yRange) * plotHeight;

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicksComp = getNiceTicks(stepMin, stepMax, 5);
    xTicksComp.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values
    ctx.textAlign = 'right';
    const yTicksComp = getNiceTicks(yMin, yMax, 5);
    yTicksComp.forEach(val => {
        if (val < yMin || val > yMax) return;
        const y = toY(val);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        ctx.fillText(val.toPrecision(3), paddingLeft - 4, y + 3);
    });

    // Axis labels - moved further left to avoid overlap with tick labels
    ctx.save();
    ctx.translate(10, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 11px sans-serif';
    ctx.fillText(useLogScale ? 'Error (log‚ÇÅ‚ÇÄ)' : 'Error (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        for (let i = 0; i < s.data.length; i++) {
            const x = toX(s.steps[i]);
            const y = toY(s.data[i]);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    });

    // Legend - 2 columns to avoid overlap
    const legendStartX = w / 2 - 120;
    const legendColWidth = 110;
    const legendStartY = 12;
    const legendRowHeight = 14;
    
    series.forEach((s, i) => {
        const col = i % 2;  // 0 or 1
        const row = Math.floor(i / 2);  // 0, 1, ...
        const x = legendStartX + col * legendColWidth;
        const y = legendStartY + row * legendRowHeight;
        
        ctx.fillStyle = s.color;
        ctx.fillRect(x, y, 20, s.lineWidth);
        ctx.fillStyle = '#333';
        ctx.font = s.lineWidth === 3 ? 'bold 10px sans-serif' : '10px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(s.name, x + 24, y + 4);
    });
}

function drawTrainingTrace() {
    const canvas = document.getElementById('traceCanvas');
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const paddingLeft = 60;
    const paddingRight = 60;
    const paddingTop = 40;
    const paddingBottom = 40;

    ctx.clearRect(0, 0, w, h);

    const showLoss = document.getElementById('traceLoss').checked;
    const showAvgLoss = document.getElementById('traceAvgLoss').checked;
    const showWeights = document.getElementById('traceWeights').checked;
    const useLogScale = document.getElementById('traceLogScale').checked;

    const hasRunA = !!savedRuns.A;
    const hasRunB = !!savedRuns.B;
    const comparisonMode = hasRunA && hasRunB && comparisonModeActive;

    // Determine max steps for zoom handle (works for both normal and comparison modes)
    let maxSteps;
    if (comparisonMode) {
        maxSteps = Math.max(
            savedRuns.A.steps.length > 0 ? savedRuns.A.steps[savedRuns.A.steps.length - 1] : 0,
            savedRuns.B.steps.length > 0 ? savedRuns.B.steps[savedRuns.B.steps.length - 1] : 0
        );
    } else {
        maxSteps = history.steps.length > 0 ? history.steps[history.steps.length - 1] : 0;
    }
    
    // Show view handle when we have enough data to zoom
    const viewHandle = document.getElementById('traceViewHandle');
    const hasEnoughData = comparisonMode ? maxSteps > 50 : history.steps.length > 50;
    if (viewHandle) {
        if (hasEnoughData) {
            viewHandle.style.display = 'flex';
            viewHandle.style.opacity = '0.9';
        } else {
            viewHandle.style.display = 'none';
        }
        
        // Reset view when running (show all)
        if (trainingState.running) {
            traceViewState.maxStep = Infinity;
        }
    }

    if (comparisonMode) {
        drawTrainingTraceComparison(
            ctx, w, h,
            paddingLeft, paddingRight,
            paddingTop, paddingBottom,
            savedRuns.A, savedRuns.B,
            showLoss, showAvgLoss, useLogScale,
            traceViewState.maxStep  // Pass the view end step
        );
        return;
    }

    // Draw axes even when no data yet
    const hasData = history.steps.length > 0;
    
    // Calculate view window: always start from 0, end based on traceViewState.maxStep
    let viewStartIdx = 0;
    let viewEndIdx = history.steps.length;
    
    // If we have a view max step set (not Infinity), use it
    if (traceViewState.maxStep !== Infinity && traceViewState.maxStep < history.steps.length) {
        viewEndIdx = Math.max(10, traceViewState.maxStep);
    }
    
    // Get sliced data for the view
    const viewSteps = hasData ? history.steps.slice(viewStartIdx, viewEndIdx) : [];
    const viewLoss = hasData ? history.loss.slice(viewStartIdx, viewEndIdx) : [];
    const viewAvgLoss = hasData ? history.avgLoss.slice(viewStartIdx, viewEndIdx) : [];
    
    const series = [];

    if (showLoss) {
        series.push({
            name: 'Train Error',
            steps: viewSteps,
            data: viewLoss,
            color: '#28a745',  // Green for training (matches train points)
            lineWidth: 2
        });
    }

    if (showAvgLoss) {
        series.push({
            name: 'Avg Error',
            steps: viewSteps,
            data: viewAvgLoss,
            color: '#007bff',
            lineWidth: 3
        });
    }
    
    const plotWidth  = w - paddingLeft - paddingRight;
    const plotHeight = h - paddingTop - paddingBottom;

    // X axis range (use defaults if no data) - declare early so test loss filter can use it
    const stepMin = viewSteps.length > 0 ? viewSteps[0] : 0;
    const stepMax = viewSteps.length > 0 ? viewSteps[viewSteps.length - 1] : 100;
    const stepRange = stepMax - stepMin || 100;

    // Add test loss series if evaluated (only show after clicking Evaluate button)
    if (showLoss && history.testLoss.length > 0 && revealOptions.evaluated) {
        // Filter test loss to view window
        const viewTestLoss = history.testLoss.filter(t => 
            t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)
        );
        if (viewTestLoss.length > 0) {
            series.push({
                name: 'Test Error',
                steps: viewTestLoss.map(t => t.step),
                data: viewTestLoss.map(t => t.loss),
                color: '#ff9800',  // Orange for test (matches test points)
                lineWidth: 2,
                dashed: true  // Dashed line to distinguish from train
            });
        }
    }

    // Y axis range for loss (supports log scale) - ALWAYS based on ALL loss data for stable axis
    // Calculate from raw data, not just displayed series, so toggling curves doesn't change axis
    let yMin = 0;  // Loss always starts from 0 in linear mode
    let yMax = -Infinity;
    
    // Always include training loss in axis calculation
    viewLoss.forEach(v => {
        if (!Number.isFinite(v) || (useLogScale && v <= 0)) return;
        const val = useLogScale ? Math.log10(v) : v;
        yMax = Math.max(yMax, val);
    });
    
    // Always include average loss in axis calculation
    viewAvgLoss.forEach(v => {
        if (!Number.isFinite(v) || v === null || (useLogScale && v <= 0)) return;
        const val = useLogScale ? Math.log10(v) : v;
        yMax = Math.max(yMax, val);
    });
    
    // Include test loss if available
    if (history.testLoss.length > 0) {
        history.testLoss.forEach(t => {
            if (t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)) {
                if (!Number.isFinite(t.loss) || (useLogScale && t.loss <= 0)) return;
                const val = useLogScale ? Math.log10(t.loss) : t.loss;
                yMax = Math.max(yMax, val);
            }
        });
    }
    
    if (useLogScale) {
        // For log scale, find the minimum non-zero value
        yMin = Infinity;
        viewLoss.forEach(v => { if (v > 0) yMin = Math.min(yMin, Math.log10(v)); });
        viewAvgLoss.forEach(v => { if (v > 0 && v !== null) yMin = Math.min(yMin, Math.log10(v)); });
        history.testLoss.forEach(t => {
            if (t.step >= stepMin && (traceViewState.maxStep === Infinity || t.step <= traceViewState.maxStep)) {
                if (t.loss > 0) yMin = Math.min(yMin, Math.log10(t.loss));
            }
        });
        if (!Number.isFinite(yMin)) yMin = -4;
    }
    if (!Number.isFinite(yMax)) {
        yMax = useLogScale ? 0 : 1;
    }
    if (yMin === yMax) {
        const eps = Math.max(0.1, Math.abs(yMin) * 0.1);
        yMax += eps;
    } else {
        const pad = 0.1 * (yMax - yMin);
        yMax += pad;
    }
    const yRange = yMax - yMin || 1;
    
    // Get sliced weights for the view
    const viewWeights = hasData ? history.weights.slice(viewStartIdx, viewEndIdx) : [];
    
    // Y axis range for weights (separate right axis)
    let wMin = Infinity;
    let wMax = -Infinity;
    if (showWeights && viewWeights.length > 0) {
        viewWeights.forEach(wArr => {
            wArr.forEach(v => {
                if (Number.isFinite(v)) {
                    wMin = Math.min(wMin, v);
                    wMax = Math.max(wMax, v);
                }
            });
        });
    }
    if (!Number.isFinite(wMin) || !Number.isFinite(wMax)) {
        wMin = -2;
        wMax = 2;
    }
    if (wMin === wMax) {
        wMin -= 1;
        wMax += 1;
    } else {
        const wPad = 0.1 * (wMax - wMin);
        wMin -= wPad;
        wMax += wPad;
    }
    const wRange = wMax - wMin || 1;

    const toX = (step) =>
        paddingLeft + ((step - stepMin) / stepRange) * plotWidth;
    const toY = (val) => {
        const v = useLogScale ? Math.log10(Math.max(val, 1e-10)) : val;
        return h - paddingBottom - ((v - yMin) / yRange) * plotHeight;
    };

    // Axes box
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop);
    ctx.lineTo(paddingLeft, h - paddingBottom);
    ctx.lineTo(w - paddingRight, h - paddingBottom);
    ctx.lineTo(w - paddingRight, paddingTop);
    ctx.closePath();
    ctx.stroke();

    // X ticks - use nice round values
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const xTicks = getNiceTicks(stepMin, stepMax, 5);
    xTicks.forEach(s => {
        if (s < stepMin || s > stepMax) return;
        const x = toX(s);
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(x, paddingTop);
        ctx.lineTo(x, h - paddingBottom);
        ctx.stroke();
        ctx.fillStyle = '#666';
        ctx.fillText(Math.round(s).toString(), x, h - paddingBottom + 13);
    });

    // Y ticks - use nice round values (log scale uses powers of 10)
    ctx.textAlign = 'right';
    const yTicks = useLogScale ? getLogTicks(yMin, yMax) : getNiceTicks(yMin, yMax, 5);
    yTicks.forEach(yVal => {
        if (yVal < yMin || yVal > yMax) return;
        const y = h - paddingBottom - ((yVal - yMin) / yRange) * plotHeight;
        ctx.strokeStyle = '#e0e0e0';
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(w - paddingRight, y);
        ctx.stroke();
        ctx.fillStyle = '#dc3545';
        if (useLogScale) {
            const realVal = Math.pow(10, yVal);
            // Format as power of 10: 10^-2 shows as "0.01", 10^-3 as "0.001" etc.
            if (Number.isInteger(yVal)) {
                ctx.fillText(realVal.toExponential(0), paddingLeft - 4, y + 3);
            } else {
                ctx.fillText(realVal.toPrecision(2), paddingLeft - 4, y + 3);
            }
        } else {
            ctx.fillText(yVal.toPrecision(3), paddingLeft - 4, y + 3);
        }
    });

    // Axis labels
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.fillStyle = '#dc3545';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText(useLogScale ? 'Error (log‚ÇÅ‚ÇÄ)' : 'Error (linear)', 0, 0);
    ctx.restore();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Training Step', w - paddingRight, h - 8);

    // Draw loss series
    series.forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        if (s.dashed) {
            ctx.setLineDash([5, 3]);
        } else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        let started = false;
        for (let i = 0; i < s.data.length; i++) {
            const val = s.data[i];
            if (!Number.isFinite(val) || (useLogScale && val <= 0)) continue;
            const x = toX(s.steps[i]);
            const y = toY(val);
            if (!started) { ctx.moveTo(x, y); started = true; }
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    });

    // Draw weight traces (on right Y axis)
    if (showWeights && viewWeights && viewWeights.length > 0) {
        const numWeights = viewWeights[0].length;
        const weightColors = ['#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf', '#ff7f0e', '#2ca02c'];
        
        // Use pre-calculated weight range from earlier
        const toWY = (val) => h - paddingBottom - ((val - wMin) / wRange) * plotHeight;
        
        // Draw right axis tick marks and labels for weights - use nice values
        ctx.textAlign = 'left';
        ctx.font = '9px sans-serif';
        const wTicks = getNiceTicks(wMin, wMax, 5);
        wTicks.forEach(wVal => {
            if (wVal < wMin || wVal > wMax) return;
            const y = h - paddingBottom - ((wVal - wMin) / wRange) * plotHeight;
            // Tick mark
            ctx.strokeStyle = '#9467bd';
            ctx.beginPath();
            ctx.moveTo(w - paddingRight, y);
            ctx.lineTo(w - paddingRight + 5, y);
            ctx.stroke();
            // Label
            ctx.fillStyle = '#9467bd';
            ctx.fillText(wVal.toFixed(1), w - paddingRight + 8, y + 3);
        });
        
        // Draw weight lines
        for (let wi = 0; wi < Math.min(numWeights, 8); wi++) {
            ctx.strokeStyle = weightColors[wi % weightColors.length];
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < viewWeights.length; i++) {
                const x = toX(viewSteps[i]);
                const y = toWY(viewWeights[i][wi]);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
        
        // Right axis label
        ctx.save();
        ctx.translate(w - 5, h / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillStyle = '#9467bd';
        ctx.font = 'bold 10px sans-serif';
        ctx.fillText('Weights', 0, 0);
        ctx.restore();
    }
    
    // Draw legend above the plot area (in the top margin)
    const legendY = 20;  // Above the plot, in the margin
    let legendX = paddingLeft;
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    
    // Train Loss (green solid line)
    ctx.strokeStyle = '#28a745';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 14, legendY);
    ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.fillText('Train', legendX + 17, legendY + 4);
    legendX += 52;
    
    // Average Loss (blue solid line)
    ctx.strokeStyle = '#007bff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY);
    ctx.lineTo(legendX + 14, legendY);
    ctx.stroke();
    ctx.fillStyle = '#333';
    ctx.fillText('Avg', legendX + 17, legendY + 4);
    legendX += 42;
    
    // Test Loss (orange dashed line) - only if evaluated
    if (revealOptions.evaluated && history.testLoss.length > 0) {
        ctx.strokeStyle = '#ff9800';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 14, legendY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#333';
        ctx.fillText('Test', legendX + 17, legendY + 4);
        legendX += 42;
    }
    
    // Weights (purple line) - only if showing weights
    if (showWeights) {
        ctx.strokeStyle = '#9467bd';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 14, legendY);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#333';
        ctx.fillText('Weights (first 8)', legendX + 17, legendY + 4);
    }
}

    // Loss surface visualization
    let lossSurfaceCache = null;
    let lossSurfaceOriginalGrid = null;  // Backup of original mini-training results (before refinement)
    let lossSurfaceWeightIndices = [0, 1];
    let lossSurfaceTrail = [];  // Trail of weight positions during training
    let lossSurfaceStartPosition = null;  // Store starting position separately
    let lossSurfaceAutoUpdate = true;  // Auto-update every N steps
    let lossSurfaceUpdateInterval = 50;  // Update every 50 steps
    let lossSurfaceBaseWeights = null;  // Fixed initial weights for consistent mini-training
    let lossSurfaceBaseBiases = null;
    let lossSurfaceComputeTimeout = null;  // Debounce timer for expensive computation
    let lossSurfaceAbort = false;  // Flag to abort ongoing computation
    let lossLandscapeAutoMode = true;  // Auto-select weights by default
    
    // View bounds for "slow zoom" - separate from grid bounds
    // View can be smaller than grid, and gradually expands to keep trail visible
    let lossSurfaceViewBounds = null;  // {minX, maxX, minY, maxY} - current display region
    
    function populateWeightSelectors() {
        const selectX = document.getElementById('weightXSelect');
        const selectY = document.getElementById('weightYSelect');
        if (!selectX || !selectY) return;
        
        // Helper to convert number to subscript
        const toSub = (n) => String(n).split('').map(d => '‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ'[d]).join('');
        
        // Build list of all weights with descriptive names and categories
        const weightNames = [];
        let idx = 0;
        
        // First layer: input -> hidden (category: 'input')
        // w_ij notation: weight to hidden neuron h_1j (layer 1, neuron j)
        for (let i = 0; i < network.hiddenSize; i++) {
            const neuronIdx = i + 1;
            // For single layer: w_j(x‚Üíh_j), for multi-layer: w(x‚Üíh_1j)
            const hLabel = network.numLayers === 1 ? `h${toSub(neuronIdx)}` : `h${toSub(1)}${toSub(neuronIdx)}`;
            weightNames.push({ idx: idx++, name: `w(x‚Üí${hLabel})`, category: 'input', neuron: i });
        }
        
        // Hidden -> hidden layers (category: 'hidden')
        // w(h_ij‚Üíh_kl) notation
        for (let l = 1; l < network.numLayers; l++) {
            for (let i = 0; i < network.hiddenSize; i++) {
                for (let j = 0; j < network.hiddenSize; j++) {
                    weightNames.push({ idx: idx++, name: `w(h${toSub(l)}${toSub(j+1)}‚Üíh${toSub(l+1)}${toSub(i+1)})`, category: 'hidden', layer: l });
                }
            }
        }
        
        // Output layer (category: 'output') - w_j for output weights (single subscript for last layer)
        for (let i = 0; i < network.hiddenSize; i++) {
            const neuronIdx = i + 1;
            // Reference last hidden layer with h_ij notation
            const lastLayer = network.numLayers;
            const hLabel = network.numLayers === 1 ? `h${toSub(neuronIdx)}` : `h${toSub(lastLayer)}${toSub(neuronIdx)}`;
            weightNames.push({ idx: idx++, name: `w${toSub(neuronIdx)}(${hLabel}‚Üíy)`, category: 'output', neuron: i });
        }
        
        // Populate selectors
        selectX.innerHTML = '';
        selectY.innerHTML = '';
        
        weightNames.forEach(w => {
            const optX = document.createElement('option');
            optX.value = w.idx;
            optX.textContent = w.name;
            selectX.appendChild(optX);
            
            const optY = document.createElement('option');
            optY.value = w.idx;
            optY.textContent = w.name;
            selectY.appendChild(optY);
        });
        
        // Auto-select interesting weights:
        // Pick one from input layer and one from output layer for maximum independence
        const inputWeights = weightNames.filter(w => w.category === 'input');
        const outputWeights = weightNames.filter(w => w.category === 'output');
        
        let bestPair = [0, 1];
        
        if (inputWeights.length > 0 && outputWeights.length > 0) {
            // Pick first input weight and first output weight (different layers = more interesting)
            bestPair = [inputWeights[0].idx, outputWeights[0].idx];
        } else if (weightNames.length >= 2) {
            // Fallback: pick weights from different neurons
            bestPair = [0, Math.min(1, weightNames.length - 1)];
        }
        
        selectX.value = bestPair[0].toString();
        selectY.value = bestPair[1].toString();
        lossSurfaceWeightIndices = bestPair;
    }
    
    // Find the most "interesting" pair of weights by sampling loss variance
    function autoSelectInterestingWeights() {
        try {
            const selectX = document.getElementById('weightXSelect');
            const selectY = document.getElementById('weightYSelect');
            if (!selectX || !selectY) {
                console.log('Weight selectors not found');
                return;
            }
            
            const numWeights = selectX.options.length;
            if (numWeights < 2) {
                console.log('Not enough weights:', numWeights);
                // Just use first two weights as default
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
                return;
            }
            
            // Simple approach: just pick first input weight and first output weight
            // This is more robust for different network sizes
            const H = network.hiddenSize;
            const L = network.numLayers;
            
            // First weight (input to first hidden)
            const idx1 = 0;
            // Last weight (last hidden to output) - approximate
            const idx2 = Math.min(numWeights - 1, H);
            
            if (idx1 !== idx2 && idx2 < numWeights) {
                lossSurfaceWeightIndices = [idx1, idx2];
            } else {
                lossSurfaceWeightIndices = [0, Math.min(1, numWeights - 1)];
            }
            
            selectX.value = lossSurfaceWeightIndices[0].toString();
            selectY.value = lossSurfaceWeightIndices[1].toString();
            lossSurfaceCache = null;
            lossSurfaceOriginalGrid = null;
            lossSurfaceTrail = [];
            lossSurfaceViewBounds = null;  // Reset view bounds
            console.log('Auto-selected weights:', lossSurfaceWeightIndices);
        } catch(e) {
            console.error('autoSelectInterestingWeights error:', e);
            // Fallback to default
            lossSurfaceWeightIndices = [0, 1];
        }
    }
    
    function getWeightByIndex(idx) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            return network.weights[0][idx];
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                return network.weights[l][i][j];
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            return network.weights[network.weights.length - 1][outIdx];
        }
        
        return 0;
    }
    
    function getGradByIndex(idx) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            return grads.weights[0][idx];
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                return grads.weights[l][i][j];
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            return grads.weights[grads.weights.length - 1][outIdx];
        }
        
        return 0;
    }
    
    function setWeightByIndex(idx, value) {
        let currentIdx = 0;
        
        // First layer
        if (idx < network.hiddenSize) {
            network.weights[0][idx] = value;
            return;
        }
        currentIdx += network.hiddenSize;
        
        // Hidden -> hidden
        for (let l = 1; l < network.numLayers; l++) {
            const layerSize = network.hiddenSize * network.hiddenSize;
            if (idx < currentIdx + layerSize) {
                const localIdx = idx - currentIdx;
                const i = Math.floor(localIdx / network.hiddenSize);
                const j = localIdx % network.hiddenSize;
                network.weights[l][i][j] = value;
                return;
            }
            currentIdx += layerSize;
        }
        
        // Output layer
        const outIdx = idx - currentIdx;
        if (outIdx < network.hiddenSize) {
            network.weights[network.weights.length - 1][outIdx] = value;
        }
    }
    
    // Convert layer index + position to global weight index
    // Layer indices: 0 = input‚Üíhidden1, 1..L-1 = hidden‚Üíhidden, L = hidden‚Üíoutput
    // where L = network.numLayers (number of hidden layers)
    function getGlobalWeightIndex(layer, position) {
        const H = network.hiddenSize;
        const L = network.numLayers;
        
        // Layer 0: H weights at indices 0 to H-1
        if (layer === 0) {
            return position;
        }
        
        // Layers 1 to L-1: H¬≤ weights each (hidden‚Üíhidden)
        // Layer L: H weights (output)
        // Formula: H + sum of H¬≤ for each hidden‚Üíhidden layer before this one
        const numHiddenToHiddenBefore = Math.min(layer - 1, L - 1);
        const globalIdx = H + numHiddenToHiddenBefore * H * H;
        
        return globalIdx + position;
    }
    
    async function computeLossSurface() {
        // EXPLORATION ALGORITHM:
        // 1. Start training from random (w1,w2) locations
        // 2. Run until initial convergence
        // 3. Map the loss at the destination + start region
        // 4. Repeat from all grid starting positions
        // 5. Average overlapping probes, interpolate gaps
        
        // === CONFIGURATION - Adjust these for finer/coarser mapping ===
        // SIMPLIFIED: 15√ó10 starts (150 runs), 60√ó40 display, 5√ó5 patches, 600 steps
        const coarseResX = 15;  // Starting positions width (# of training runs = 150)
        const coarseResY = 10;  // Starting positions height
        const fineResX = 60;    // Display grid width (aspect 1.5:1 for 520√ó340 canvas)
        const fineResY = 40;    // Display grid height
        const stepsPerRun = 600;  // Steps per training run - fast convergence
        // Probe radius to get ~5√ó5 patches: grid is ¬±2, so 4 total. 60 cells = 4/60 per cell
        // 5 cells wide = 5 * (4/60) = 0.33
        const startProbeRadius = 0.17;  // ~5√ó5 patch around start
        const endProbeRadius = 0.17;    // ~5√ó5 patch around end
        // ==============================================================
        
        const maxRuns = coarseResX * coarseResY;  // Cover all grid positions
        const coverageTarget = 0.90;  // Stop when 90% of coarse cells covered (used for early exit)
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Grid range: ¬±2.0 around ORIGIN
        const padding = 2.0;
        const minX = -padding;
        const maxX = padding;
        const minY = -padding;
        const maxY = padding;
        
        // Use actual training data (with noise) - same as real training
        const samples = dataset.train || [];
        if (samples.length === 0) {
            console.log('No training data available, using synthetic samples');
            for (let i = 0; i < 20; i++) {
                const x = config.xMin + (i + 0.5) * (config.xMax - config.xMin) / 20;
                let y;
                try { y = config.targetFunc(x); } catch { y = 0; }
                samples.push({ x, y });
            }
        }
        const lr = 0.1;
        const L = network.numLayers;
        const H = network.hiddenSize;
        
        const startTime = performance.now();
        
        // Use the fixed base weights for consistent results across resets
        if (!lossSurfaceBaseWeights || !lossSurfaceBaseBiases) {
            console.warn('No base weights saved - using current weights');
            lossSurfaceBaseWeights = network.weights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            lossSurfaceBaseBiases = network.biases.map(layer => layer.slice());
        }
        
        // Initialize fine grid for direct rendering (150√ó100)
        // Each cell accumulates sum and count for averaging overlapping probes
        const fineGrid = [];  // [iy][ix] = { sum, count, wx, wy } or null
        for (let iy = 0; iy < fineResY; iy++) {
            fineGrid.push(new Array(fineResX).fill(null));
        }
        
        // Helper to add a probe to the fine grid (accumulates for averaging)
        function addProbe(fix, fiy, loss, wx, wy) {
            if (fix < 0 || fix >= fineResX || fiy < 0 || fiy >= fineResY) return;
            if (!fineGrid[fiy][fix]) {
                fineGrid[fiy][fix] = { sum: loss, count: 1, wx, wy };
            } else {
                fineGrid[fiy][fix].sum += loss;
                fineGrid[fiy][fix].count++;
            }
        }
        
        // Helper to get averaged loss from fine grid
        function getAvgLoss(fix, fiy) {
            const cell = fineGrid[fiy]?.[fix];
            if (!cell) return null;
            return cell.sum / cell.count;
        }
        
        // Coarse coverage tracking (15√ó10)
        const coverage = [];  // [iy][ix] = { count, avgLoss } or null
        for (let iy = 0; iy < coarseResY; iy++) {
            coverage.push(new Array(coarseResX).fill(null));
        }
        
        // Helper to evaluate loss at current weights
        function evalLoss() {
            let loss = 0;
            for (const sample of samples) {
                const fwd = forward(sample.x);
                const err = fwd.yhat - sample.y;
                loss += 0.5 * err * err;
            }
            return loss / samples.length;
        }
        
        // Cell sizes
        const fineCellW = (maxX - minX) / fineResX;
        const fineCellH = (maxY - minY) / fineResY;
        const coarseCellW = (maxX - minX) / coarseResX;
        const coarseCellH = (maxY - minY) / coarseResY;
        
        // Helper to get fine grid cell for a (w1,w2) position
        function getFineCell(wx, wy) {
            const ix = Math.floor((wx - minX) / fineCellW);
            const iy = Math.floor((wy - minY) / fineCellH);
            return { 
                ix: Math.max(0, Math.min(fineResX - 1, ix)), 
                iy: Math.max(0, Math.min(fineResY - 1, iy)) 
            };
        }
        
        // Helper to get coarse grid cell
        function getCoarseCell(wx, wy) {
            const ix = Math.floor((wx - minX) / coarseCellW);
            const iy = Math.floor((wy - minY) / coarseCellH);
            return { 
                ix: Math.max(0, Math.min(coarseResX - 1, ix)), 
                iy: Math.max(0, Math.min(coarseResY - 1, iy)) 
            };
        }
        
        // Helper to find uncovered coarse cell (random from uncovered)
        function findUncoveredCell() {
            const uncovered = [];
            for (let iy = 0; iy < coarseResY; iy++) {
                for (let ix = 0; ix < coarseResX; ix++) {
                    if (!coverage[iy][ix]) {
                        uncovered.push({ ix, iy });
                    }
                }
            }
            if (uncovered.length === 0) return null;
            return uncovered[Math.floor(Math.random() * uncovered.length)];
        }
        
        // Count covered coarse cells
        function countCoverage() {
            let count = 0;
            for (let iy = 0; iy < coarseResY; iy++) {
                for (let ix = 0; ix < coarseResX; ix++) {
                    if (coverage[iy][ix]) count++;
                }
            }
            return count;
        }
        
        // Count filled fine cells
        function countFineCells() {
            let count = 0;
            for (let iy = 0; iy < fineResY; iy++) {
                for (let ix = 0; ix < fineResX; ix++) {
                    if (fineGrid[iy][ix] && fineGrid[iy][ix].count > 0) count++;
                }
            }
            return count;
        }
        
        // Get total probe count (for stats)
        function getTotalProbeCount() {
            let total = 0;
            for (let iy = 0; iy < fineResY; iy++) {
                for (let ix = 0; ix < fineResX; ix++) {
                    if (fineGrid[iy][ix]) total += fineGrid[iy][ix].count;
                }
            }
            return total;
        }
        
        // Pre-compute for optimized training
        const scaledLr = lr / samples.length;
        const maxGrad = 10.0;
        const clip = (g) => g > maxGrad ? maxGrad : (g < -maxGrad ? -maxGrad : g);
        const actPrime = activationFns[config.activation].dfn;
        const actFn = activationFns[config.activation].fn;
        
        // Pre-extract samples
        const numSamples = samples.length;
        const sampleX = new Float64Array(numSamples);
        const sampleY = new Float64Array(numSamples);
        for (let i = 0; i < numSamples; i++) {
            sampleX[i] = samples[i].x;
            sampleY[i] = samples[i].y;
        }
        
        // Pre-allocate arrays
        const deltaNext = new Float64Array(H);
        const deltaPrev = new Float64Array(H);
        const delta = new Float64Array(H);
        const fwdActivations = [];
        const fwdZValues = [];
        for (let l = 0; l < L; l++) {
            fwdActivations.push(new Float64Array(H));
            fwdZValues.push(new Float64Array(H));
        }
        
        // ========== EXPLORATION PHASE ==========
        let runCount = 0;
        let totalSteps = 0;
        const explorationTrails = [];
        
        // Helper to draw current exploration state (fine grid)
        function drawExplorationState() {
            try {
            const canvas = document.getElementById('lossCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Draw fine grid (150√ó100)
            const pixelW = width / fineResX;
            const pixelH = height / fineResY;
            
            // Find loss range for coloring (using averaged values)
            let lossMin = Infinity, lossMax = -Infinity;
            for (let iy = 0; iy < fineResY; iy++) {
                for (let ix = 0; ix < fineResX; ix++) {
                    const cell = fineGrid[iy][ix];
                    if (cell && cell.count > 0) {
                        const loss = cell.sum / cell.count;  // Average
                        if (loss < lossMin) lossMin = loss;
                        if (loss > lossMax) lossMax = loss;
                    }
                }
            }
            if (lossMin === Infinity) { lossMin = 0.001; lossMax = 1; }
            
            const logMin = Math.log10(Math.max(1e-10, lossMin));
            const logMax = Math.log10(Math.max(1e-10, lossMax));
            
            // Draw each fine cell
            for (let iy = 0; iy < fineResY; iy++) {
                for (let ix = 0; ix < fineResX; ix++) {
                    const cellX = ix * pixelW;
                    const cellY = (fineResY - 1 - iy) * pixelH;  // Flip Y
                    const cell = fineGrid[iy][ix];
                    
                    if (cell && cell.count > 0) {
                        // Colored by AVERAGED loss (log scale)
                        const avgLoss = cell.sum / cell.count;
                        const logLoss = Math.log10(Math.max(1e-10, avgLoss));
                        const t = Math.max(0, Math.min(1, (logLoss - logMin) / (logMax - logMin + 1e-10)));
                        
                        // Blue ‚Üí Cyan ‚Üí Green ‚Üí Yellow ‚Üí Red
                        let r, g, b;
                        if (t < 0.25) {
                            const u = t / 0.25;
                            r = 0; g = Math.floor(200 * u); b = 255;
                        } else if (t < 0.5) {
                            const u = (t - 0.25) / 0.25;
                            r = 0; g = 200 + Math.floor(55 * u); b = Math.floor(255 * (1 - u));
                        } else if (t < 0.75) {
                            const u = (t - 0.5) / 0.25;
                            r = Math.floor(255 * u); g = 255; b = 0;
                        } else {
                            const u = (t - 0.75) / 0.25;
                            r = 255; g = Math.floor(255 * (1 - u)); b = 0;
                        }
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                    } else {
                        // Unfilled - dark gray
                        ctx.fillStyle = '#222';
                    }
                    ctx.fillRect(cellX, cellY, pixelW + 0.5, pixelH + 0.5);
                }
            }
            
            // Draw all exploration trails
            for (let ti = 0; ti < explorationTrails.length; ti++) {
                const trail = explorationTrails[ti];
                if (trail.length < 2) continue;
                
                const alpha = 0.3 + 0.7 * (ti / explorationTrails.length);
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = 0; i < trail.length; i++) {
                    const px = ((trail[i].wx - minX) / (maxX - minX)) * width;
                    const py = (1 - (trail[i].wy - minY) / (maxY - minY)) * height;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                // Start point (green)
                const startPx = ((trail[0].wx - minX) / (maxX - minX)) * width;
                const startPy = (1 - (trail[0].wy - minY) / (maxY - minY)) * height;
                ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(startPx, startPy, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // End point (red)
                const endPx = ((trail[trail.length-1].wx - minX) / (maxX - minX)) * width;
                const endPy = (1 - (trail[trail.length-1].wy - minY) / (maxY - minY)) * height;
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(endPx, endPy, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Stats are logged to console only - no overlay text
            } catch (err) {
                console.error('  drawExplorationState error:', err);
            }
        }
        
        // Draw detailed local probe map
        function drawLocalProbeMap(localLosses, centerWx, centerWy, radius, localMin, localMax, runNum) {
            const canvas = document.getElementById('lossCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // First draw the global coverage as background
            drawExplorationState();
            
            // Now overlay the local probe detail
            // Convert local probe region to canvas coordinates
            const localLeft = ((centerWx - radius) - minX) / (maxX - minX) * width;
            const localRight = ((centerWx + radius) - minX) / (maxX - minX) * width;
            const localTop = (1 - ((centerWy + radius) - minY) / (maxY - minY)) * height;
            const localBottom = (1 - ((centerWy - radius) - minY) / (maxY - minY)) * height;
            const localW = localRight - localLeft;
            const localH = localBottom - localTop;
            
            // Draw border around local probe region
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(localLeft, localTop, localW, localH);
            
            // Draw each local probe point as a colored square
            const localRes = 10;
            const cellW = localW / localRes;
            const cellH = localH / localRes;
            const logMin = Math.log10(Math.max(1e-10, localMin));
            const logMax = Math.log10(Math.max(1e-10, localMax));
            
            for (const probe of localLosses) {
                // Position within local region
                const lx = (probe.wx - (centerWx - radius)) / (2 * radius);
                const ly = 1 - (probe.wy - (centerWy - radius)) / (2 * radius);
                
                const px = localLeft + lx * localW;
                const py = localTop + ly * localH;
                
                // Color by loss
                const logLoss = Math.log10(Math.max(1e-10, probe.loss));
                const t = Math.max(0, Math.min(1, (logLoss - logMin) / (logMax - logMin + 1e-10)));
                
                // Blue ‚Üí Cyan ‚Üí Green ‚Üí Yellow ‚Üí Red
                let r, g, b;
                if (t < 0.25) {
                    const u = t / 0.25;
                    r = 0; g = Math.floor(200 * u); b = 255;
                } else if (t < 0.5) {
                    const u = (t - 0.25) / 0.25;
                    r = 0; g = 200 + Math.floor(55 * u); b = Math.floor(255 * (1 - u));
                } else if (t < 0.75) {
                    const u = (t - 0.5) / 0.25;
                    r = Math.floor(255 * u); g = 255; b = 0;
                } else {
                    const u = (t - 0.75) / 0.25;
                    r = 255; g = Math.floor(255 * (1 - u)); b = 0;
                }
                
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(px - cellW/2, py - cellH/2, cellW, cellH);
            }
            
            // Draw probe center marker
            const centerPx = ((centerWx - minX) / (maxX - minX)) * width;
            const centerPy = (1 - (centerWy - minY) / (maxY - minY)) * height;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(centerPx, centerPy, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(centerPx, centerPy, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Label
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(localLeft, localTop - 18, 120, 16);
            ctx.fillStyle = '#fff';
            ctx.font = '11px monospace';
            ctx.fillText(`Run ${runNum}: ${localMin.toExponential(1)}-${localMax.toExponential(1)}`, localLeft + 2, localTop - 5);
        }
        
        // Build list of ALL starting positions - ensure every coarse cell gets a start
        const startingPositions = [];
        for (let siy = 0; siy < coarseResY; siy++) {
            for (let six = 0; six < coarseResX; six++) {
                startingPositions.push({
                    wx: minX + (six + 0.5) * coarseCellW,
                    wy: minY + (siy + 0.5) * coarseCellH,
                    type: 'grid'
                });
            }
        }
        // Shuffle to randomize order
        for (let i = startingPositions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [startingPositions[i], startingPositions[j]] = [startingPositions[j], startingPositions[i]];
        }
        
        while (runCount < startingPositions.length) {
            if (lossSurfaceAbort) {
                console.log('Loss surface computation aborted');
                return;
            }
            
            // Get next starting position from the list
            const startPos = startingPositions[runCount];
            let startWx = startPos.wx;
            let startWy = startPos.wy;
            let startType = startPos.type;
            
            // Reset to SAME base weights for ALL runs (consistent starting point)
            network.weights = lossSurfaceBaseWeights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            network.biases = lossSurfaceBaseBiases.map(layer => layer.slice());
            
            // Set starting (w1,w2) - this is the ONLY difference between runs
            setWeightByIndex(idxX, startWx);
            setWeightByIndex(idxY, startWy);
            
            const startLoss = evalLoss();
            const { ix: startIx, iy: startIy } = getCoarseCell(startWx, startWy);
            
            // Start a new trail for this run
            const currentTrail = [{ wx: startWx, wy: startWy }];
            
            
            // Cache references
            const netWeights = network.weights;
            const netBiases = network.biases;
            const gradWeights = grads.weights;
            const gradBiases = grads.biases;
            const numGradLayers = gradWeights.length;
            const outLayerIdx = numGradLayers - 1;
            
            // Run training for stepsPerRun steps
            for (let step = 0; step < stepsPerRun; step++) {
                totalSteps++;
                
                // Record trail every 100 steps
                if (step % 100 === 0) {
                    currentTrail.push({
                        wx: getWeightByIndex(idxX),
                        wy: getWeightByIndex(idxY)
                    });
                }
                
                
                // Zero gradients
                for (let l = 0; l < numGradLayers; l++) {
                    const gwl = gradWeights[l];
                    if (Array.isArray(gwl[0])) {
                        for (let i = 0; i < gwl.length; i++) gwl[i].fill(0);
                    } else {
                        gwl.fill(0);
                    }
                    gradBiases[l].fill(0);
                }
                
                // Forward/backward over all samples
                for (let si = 0; si < numSamples; si++) {
                    const x = sampleX[si];
                    const y = sampleY[si];
                    
                    // Inline forward
                    let input = x;
                    for (let l = 0; l < L; l++) {
                        const w = netWeights[l];
                        const b = netBiases[l];
                        const act = fwdActivations[l];
                        const zv = fwdZValues[l];
                        if (l === 0) {
                            for (let i = 0; i < H; i++) {
                                const z = w[i] * input + b[i];
                                zv[i] = z;
                                act[i] = actFn(z);
                            }
                        } else {
                            const prevAct = fwdActivations[l - 1];
                            for (let i = 0; i < H; i++) {
                                const wi = w[i];
                                let z = b[i];
                                for (let j = 0; j < H; j++) z += wi[j] * prevAct[j];
                                zv[i] = z;
                                act[i] = actFn(z);
                            }
                        }
                    }
                    const outW = netWeights[outLayerIdx];
                    const outB = netBiases[outLayerIdx];
                    const lastAct = fwdActivations[L - 1];
                    let yhat = outB[0];
                    for (let i = 0; i < H; i++) yhat += outW[i] * lastAct[i];
                    
                    // Inline backward
                    const deltaOut = yhat - y;
                    const outGrads = gradWeights[outLayerIdx];
                    for (let i = 0; i < H; i++) {
                        outGrads[i] += deltaOut * lastAct[i];
                        deltaNext[i] = outW[i] * deltaOut;
                    }
                    gradBiases[outLayerIdx][0] += deltaOut;
                    
                    for (let l = L - 1; l >= 0; l--) {
                        const zv = fwdZValues[l];
                        for (let i = 0; i < H; i++) delta[i] = deltaNext[i] * actPrime(zv[i]);
                        
                        if (l === 0) {
                            const gw0 = gradWeights[0];
                            const gb0 = gradBiases[0];
                            for (let i = 0; i < H; i++) {
                                gw0[i] += delta[i] * x;
                                gb0[i] += delta[i];
                            }
                        } else {
                            const prevAct = fwdActivations[l - 1];
                            const gwl = gradWeights[l];
                            const gbl = gradBiases[l];
                            for (let i = 0; i < H; i++) {
                                const gwli = gwl[i];
                                const di = delta[i];
                                for (let j = 0; j < H; j++) gwli[j] += di * prevAct[j];
                                gbl[i] += di;
                            }
                        }
                        
                        if (l > 0) {
                            const w = netWeights[l];
                            for (let j = 0; j < H; j++) deltaPrev[j] = 0;
                            for (let i = 0; i < H; i++) {
                                const wi = w[i];
                                const di = delta[i];
                                for (let j = 0; j < H; j++) deltaPrev[j] += wi[j] * di;
                            }
                            for (let j = 0; j < H; j++) deltaNext[j] = deltaPrev[j];
                        }
                    }
                }
                
                // Update ALL weights (including w1,w2 - they're free to move)
                const nw0 = netWeights[0];
                const gw0 = gradWeights[0];
                for (let i = 0; i < H; i++) nw0[i] -= scaledLr * clip(gw0[i]);
                const nb0 = netBiases[0];
                const gb0 = gradBiases[0];
                for (let i = 0; i < H; i++) nb0[i] -= scaledLr * clip(gb0[i]);
                
                for (let l = 1; l < L; l++) {
                    const nwl = netWeights[l];
                    const gwl = gradWeights[l];
                    for (let i = 0; i < H; i++) {
                        const nwli = nwl[i];
                        const gwli = gwl[i];
                        for (let j = 0; j < H; j++) nwli[j] -= scaledLr * clip(gwli[j]);
                    }
                    const nbl = netBiases[l];
                    const gbl = gradBiases[l];
                    for (let i = 0; i < H; i++) nbl[i] -= scaledLr * clip(gbl[i]);
                }
                
                const nwOut = netWeights[outLayerIdx];
                const gwOut = gradWeights[outLayerIdx];
                for (let i = 0; i < H; i++) nwOut[i] -= scaledLr * clip(gwOut[i]);
                const nbOut = netBiases[outLayerIdx];
                const gbOut = gradBiases[outLayerIdx];
                nbOut[0] -= scaledLr * clip(gbOut[0]);
            }
            
            // After training, record the destination
            const endWx = getWeightByIndex(idxX);
            const endWy = getWeightByIndex(idxY);
            const endLoss = evalLoss();
            
            // Complete the trail
            currentTrail.push({ wx: endWx, wy: endWy });
            explorationTrails.push(currentTrail);
            
            // Save current trained weights for local probing
            const probeWeights = netWeights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            const probeBiases = netBiases.map(layer => layer.slice());
            
            // ===== PROBE START REGION (captures high-loss areas) =====
            const startFineIxMin = Math.max(0, Math.floor((startWx - startProbeRadius - minX) / fineCellW));
            const startFineIxMax = Math.min(fineResX, Math.ceil((startWx + startProbeRadius - minX) / fineCellW));
            const startFineIyMin = Math.max(0, Math.floor((startWy - startProbeRadius - minY) / fineCellH));
            const startFineIyMax = Math.min(fineResY, Math.ceil((startWy + startProbeRadius - minY) / fineCellH));
            
            for (let fiy = startFineIyMin; fiy < startFineIyMax; fiy++) {
                for (let fix = startFineIxMin; fix < startFineIxMax; fix++) {
                    const probeWx = minX + (fix + 0.5) * fineCellW;
                    const probeWy = minY + (fiy + 0.5) * fineCellH;
                    
                    // Restore probe weights and set position
                    for (let l = 0; l < probeWeights.length; l++) {
                        const src = probeWeights[l];
                        const dst = netWeights[l];
                        if (Array.isArray(src[0])) {
                            for (let i = 0; i < src.length; i++) {
                                const srcRow = src[i], dstRow = dst[i];
                                for (let j = 0; j < srcRow.length; j++) dstRow[j] = srcRow[j];
                            }
                        } else {
                            for (let i = 0; i < src.length; i++) dst[i] = src[i];
                        }
                    }
                    for (let l = 0; l < probeBiases.length; l++) {
                        const src = probeBiases[l], dst = netBiases[l];
                        for (let i = 0; i < src.length; i++) dst[i] = src[i];
                    }
                    setWeightByIndex(idxX, probeWx);
                    setWeightByIndex(idxY, probeWy);
                    
                    const probeLoss = evalLoss();
                    addProbe(fix, fiy, probeLoss, probeWx, probeWy);
                }
            }
            
            // ===== PROBE END REGION (where training converged) =====
            const localRadius = endProbeRadius;
            
            // Determine which fine cells fall within the local region
            const localMinX = Math.max(minX, endWx - localRadius);
            const localMaxX = Math.min(maxX, endWx + localRadius);
            const localMinY = Math.max(minY, endWy - localRadius);
            const localMaxY = Math.min(maxY, endWy + localRadius);
            
            // Fine cell indices for the local region
            const fineIxMin = Math.floor((localMinX - minX) / fineCellW);
            const fineIxMax = Math.ceil((localMaxX - minX) / fineCellW);
            const fineIyMin = Math.floor((localMinY - minY) / fineCellH);
            const fineIyMax = Math.ceil((localMaxY - minY) / fineCellH);
            
            for (let fiy = fineIyMin; fiy < fineIyMax && fiy < fineResY; fiy++) {
                if (fiy < 0) continue;
                for (let fix = fineIxMin; fix < fineIxMax && fix < fineResX; fix++) {
                    if (fix < 0) continue;
                    const probeWx = minX + (fix + 0.5) * fineCellW;
                    const probeWy = minY + (fiy + 0.5) * fineCellH;
                    
                    // Restore probe weights
                    for (let l = 0; l < probeWeights.length; l++) {
                        const src = probeWeights[l], dst = netWeights[l];
                        if (Array.isArray(src[0])) {
                            for (let i = 0; i < src.length; i++) {
                                const srcRow = src[i], dstRow = dst[i];
                                for (let j = 0; j < srcRow.length; j++) dstRow[j] = srcRow[j];
                            }
                        } else {
                            for (let i = 0; i < src.length; i++) dst[i] = src[i];
                        }
                    }
                    for (let l = 0; l < probeBiases.length; l++) {
                        const src = probeBiases[l], dst = netBiases[l];
                        for (let i = 0; i < src.length; i++) dst[i] = src[i];
                    }
                    setWeightByIndex(idxX, probeWx);
                    setWeightByIndex(idxY, probeWy);
                    addProbe(fix, fiy, evalLoss(), probeWx, probeWy);
                }
            }
            
            // Update coarse coverage
            const { ix: coarseIx, iy: coarseIy } = getCoarseCell(endWx, endWy);
            if (!coverage[coarseIy][coarseIx]) {
                coverage[coarseIy][coarseIx] = { count: 1, avgLoss: endLoss };
            } else {
                coverage[coarseIy][coarseIx].count++;
            }
            
            runCount++;
        }
        
        // Brief summary
        const phase1Time = ((performance.now() - startTime) / 1000).toFixed(1);
        const finalFineCells = countFineCells();
        const finalTotalProbes = getTotalProbeCount();
        console.log(`Loss surface: ${phase1Time}s, ${runCount} runs, ${finalFineCells}/${fineResX*fineResY} cells, ${finalTotalProbes} probes`);
        
        // ========== PHASE 2: Compute averages and interpolate gaps ==========
        
        // Convert fineGrid to grid format with averaged values
        const grid = [];
        let minLoss = Infinity, maxLoss = -Infinity;
        let maxLossPos = { wx: 0, wy: 0 };
        let minLossPos = { wx: 0, wy: 0 };
        
        // First pass: compute averages for filled cells
        for (let iy = 0; iy < fineResY; iy++) {
            const row = [];
            for (let ix = 0; ix < fineResX; ix++) {
                const cell = fineGrid[iy][ix];
                const wx = minX + (ix + 0.5) * fineCellW;
                const wy = minY + (iy + 0.5) * fineCellH;
                
                if (cell && cell.count > 0) {
                    const avgLoss = cell.sum / cell.count;
                    row.push({ loss: avgLoss, wx, wy, probeCount: cell.count });
                    if (avgLoss < minLoss) { minLoss = avgLoss; minLossPos = { wx, wy }; }
                    if (avgLoss > maxLoss) { maxLoss = avgLoss; maxLossPos = { wx, wy }; }
                } else {
                    row.push({ loss: null, wx, wy, probeCount: 0 });  // Mark as needing interpolation
                }
            }
            grid.push(row);
        }
        
        // Fill gaps using distance-weighted interpolation from nearby filled cells
        let filledCount = 0;
        const searchRadius = 30;
        for (let iy = 0; iy < fineResY; iy++) {
            for (let ix = 0; ix < fineResX; ix++) {
                if (grid[iy][ix].loss === null) {
                    // Weighted average of nearby filled cells
                    let weightedSum = 0;
                    let totalWeight = 0;
                    
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                            const ny = iy + dy;
                            const nx = ix + dx;
                            if (ny >= 0 && ny < fineResY && nx >= 0 && nx < fineResX) {
                                const neighbor = grid[ny][nx];
                                if (neighbor.loss !== null) {
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist > 0) {
                                        const weight = 1 / (dist * dist);  // Inverse square weighting
                                        weightedSum += neighbor.loss * weight;
                                        totalWeight += weight;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (totalWeight > 0) {
                        grid[iy][ix].loss = weightedSum / totalWeight;
                        // Update min/max with interpolated values
                        if (grid[iy][ix].loss < minLoss) { minLoss = grid[iy][ix].loss; minLossPos = { wx: grid[iy][ix].wx, wy: grid[iy][ix].wy }; }
                        if (grid[iy][ix].loss > maxLoss) { maxLoss = grid[iy][ix].loss; maxLossPos = { wx: grid[iy][ix].wx, wy: grid[iy][ix].wy }; }
                    } else {
                        grid[iy][ix].loss = 1.0;  // Fallback
                    }
                    filledCount++;
                }
            }
        }
        console.log(`    Interpolated ${filledCount} unfilled cells using distance-weighted averaging`);
        
        // Apply light smoothing
        function applyGaussianSmooth(srcGrid, radius) {
            const result = [];
            const sigma = radius / 2;
            const weights = [];
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    weights.push({ dx, dy, w: Math.exp(-dist*dist / (2*sigma*sigma)) });
                }
            }
            
            for (let iy = 0; iy < fineResY; iy++) {
                const row = [];
                for (let ix = 0; ix < fineResX; ix++) {
                    let weightedSum = 0;
                    let totalWeight = 0;
                    
                    for (const {dx, dy, w} of weights) {
                        const ny = iy + dy;
                        const nx = ix + dx;
                        if (ny >= 0 && ny < fineResY && nx >= 0 && nx < fineResX) {
                            weightedSum += srcGrid[ny][nx].loss * w;
                            totalWeight += w;
                        }
                    }
                    
                    row.push({
                        loss: weightedSum / totalWeight,
                        wx: srcGrid[iy][ix].wx,
                        wy: srcGrid[iy][ix].wy
                    });
                }
                result.push(row);
            }
            return result;
        }
        
        // Light smoothing
        let smoothedGrid = applyGaussianSmooth(grid, 2);
        
        // Recalculate min/max after smoothing
        minLoss = Infinity;
        maxLoss = -Infinity;
        for (let iy = 0; iy < fineResY; iy++) {
            for (let ix = 0; ix < fineResX; ix++) {
                grid[iy][ix] = smoothedGrid[iy][ix];
                const loss = grid[iy][ix].loss;
                if (loss < minLoss) { minLoss = loss; minLossPos = { wx: grid[iy][ix].wx, wy: grid[iy][ix].wy }; }
                if (loss > maxLoss) { maxLoss = loss; maxLossPos = { wx: grid[iy][ix].wx, wy: grid[iy][ix].wy }; }
            }
        }
        
        // Restore base weights
        network.weights = lossSurfaceBaseWeights.map(layer => 
            Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
        );
        network.biases = lossSurfaceBaseBiases.map(layer => layer.slice());
        
        // Find starting position (top 90% loss)
        const allPositions = [];
        for (let iy = 0; iy < fineResY; iy++) {
            for (let ix = 0; ix < fineResX; ix++) {
                const cell = grid[iy][ix];
                if (isFinite(cell.loss)) {
                    allPositions.push({ wx: cell.wx, wy: cell.wy, loss: cell.loss });
                }
            }
        }
        
        allPositions.sort((a, b) => a.loss - b.loss);
        const percentile10Idx = Math.floor(allPositions.length * 0.1);
        const threshold = allPositions[percentile10Idx]?.loss || minLoss;
        const startCandidates = allPositions.filter(p => p.loss > threshold);
        
        let startPos;
        if (startCandidates.length > 0) {
            const randomIdx = Math.floor(Math.random() * startCandidates.length);
            startPos = startCandidates[randomIdx];
            console.log(`Selected random start from top 90% (${startCandidates.length} candidates, loss=${startPos.loss.toExponential(2)})`);
        } else {
            startPos = maxLossPos;
            console.log(`No start candidates found, using max loss position`);
        }
        
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
        console.log(`Loss surface computed in ${elapsed}s. Loss range: ${minLoss.toExponential(2)} to ${maxLoss.toFixed(2)}`);
        
        // Store starting (w1,w2) from startPos
        const startWx = startPos.wx;
        const startWy = startPos.wy;
        
        lossSurfaceCache = {
            grid, minLoss, maxLoss, minX, maxX, minY, maxY,
            resolutionX: fineResX,
            resolutionY: fineResY,
            currentX: startWx, currentY: startWy,
            nonUniform: false,
            maxLossPos,
            minLossPos,
            startPos,
            coverage,  // Store coverage for refinement
            coarseResX,
            coarseResY
        };
        
        // Save backup of original grid (before any refinement)
        lossSurfaceOriginalGrid = grid.map(row => 
            row.map(cell => ({ loss: cell.loss, wx: cell.wx, wy: cell.wy }))
        );
        
        if (!lossColorScale.calibrated) {
            calibrateLossColorScale(grid, minLoss, maxLoss);
        }
    }
    
    // Calibrate loss color scale based on initial loss surface
    function calibrateLossColorScale(grid, gridMinLoss, gridMaxLoss) {
        console.log('Calibrating loss color scale...');
        
        // Use actual surface range from regional mini-trainings
        // Surface minimum ‚Üí blue (actual minimum on surface)
        // Surface maximum ‚Üí red
        // Maintain 2-3 log units of dynamic range for meaningful colors
        const floorFromMax = gridMaxLoss / 1000;  // Max 3 log units of range
        const safeMinLoss = Math.max(gridMinLoss, floorFromMax, 1e-6);
        
        lossColorScale.minLoss = safeMinLoss * 0.8;  // Slight room for training to find lower
        lossColorScale.maxLoss = gridMaxLoss;  // Actual maximum on the grid
        lossColorScale.gridMin = gridMinLoss;
        lossColorScale.calibrated = true;
        
        const logRange = Math.log10(lossColorScale.maxLoss) - Math.log10(lossColorScale.minLoss);
        console.log(`Loss color scale: ${lossColorScale.minLoss.toExponential(2)} to ${lossColorScale.maxLoss.toFixed(2)} (${logRange.toFixed(1)} log units)`);
        console.log(`  Grid actual range: ${gridMinLoss.toExponential(2)} to ${gridMaxLoss.toFixed(2)}`);
    }
    
    // Refine cells in trail bounding box at or below current training loss
    // DISABLED: The exploration-based map is good enough without refinement
    let refinementInProgress = false;
    function refineLowLossRegions() {
        // Refinement disabled - exploration map captures structure, fine detail is noise
        return;
        
        const currentEpoch = dataset.train ? Math.floor(trainingState.step / dataset.train.length) : 0;
        console.log(`refineLowLossRegions called at step ${trainingState.step} (epoch ~${currentEpoch})...`);
        if (!lossSurfaceCache) { console.log('  bail: no lossSurfaceCache'); return; }
        if (refinementInProgress) { console.log('  bail: refinement in progress'); return; }
        if (!lossSurfaceBaseWeights || !lossSurfaceBaseBiases) { console.log('  bail: no base weights'); return; }
        if (lossSurfaceTrail.length < 2) { console.log('  bail: trail too short:', lossSurfaceTrail.length); return; }
        
        const { grid, minX, maxX, minY, maxY, resolutionX, resolutionY, coverage, coarseResX, coarseResY } = lossSurfaceCache;
        
        // Get current training loss as threshold
        const currentLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : Infinity;
        if (!isFinite(currentLoss)) return;
        
        // Use the ENTIRE visible view window for refinement (not just trail)
        // This avoids jarring color transitions at boundaries
        let refineMinX, refineMaxX, refineMinY, refineMaxY;
        
        if (lossSurfaceViewBounds) {
            // Use current view bounds
            refineMinX = lossSurfaceViewBounds.minX;
            refineMaxX = lossSurfaceViewBounds.maxX;
            refineMinY = lossSurfaceViewBounds.minY;
            refineMaxY = lossSurfaceViewBounds.maxY;
        } else {
            // Fallback to grid bounds
            refineMinX = minX;
            refineMaxX = maxX;
            refineMinY = minY;
            refineMaxY = maxY;
        }
        
        // Alias for the rest of the code
        const trailMinX = refineMinX;
        const trailMaxX = refineMaxX;
        const trailMinY = refineMinY;
        const trailMaxY = refineMaxY;
        
        // Collect cells in trail bounding box
        const candidateCells = [];
        // Grid covers [minX, maxX] x [minY, maxY] with resolutionX √ó resolutionY cells
        const cellWidth = (maxX - minX) / resolutionX;
        const cellHeight = (maxY - minY) / resolutionY;
        
        for (let iy = 0; iy < resolutionY; iy++) {
            for (let ix = 0; ix < resolutionX; ix++) {
                const cell = grid[iy][ix];
                // Cell center coordinates
                const wx = cell.wx !== undefined ? cell.wx : minX + (ix + 0.5) * cellWidth;
                const wy = cell.wy !== undefined ? cell.wy : minY + (iy + 0.5) * cellHeight;
                
                // Check if cell is in trail bounding box
                if (wx >= trailMinX && wx <= trailMaxX && 
                    wy >= trailMinY && wy <= trailMaxY) {
                    candidateCells.push({ ix, iy, loss: cell.loss, wx, wy });
                }
            }
        }
        
        // Debug: show grid vs trail bounds
        if (candidateCells.length === 0) {
            console.log(`  grid bounds: [${minX.toFixed(2)},${maxX.toFixed(2)}] x [${minY.toFixed(2)},${maxY.toFixed(2)}]`);
            console.log(`  cell size: ${cellWidth.toFixed(3)} x ${cellHeight.toFixed(3)}`);
        }
        
        console.log(`  trail bbox: [${trailMinX.toFixed(2)},${trailMaxX.toFixed(2)}] x [${trailMinY.toFixed(2)},${trailMaxY.toFixed(2)}]`);
        console.log(`  candidates in bbox: ${candidateCells.length}`);
        
        if (candidateCells.length === 0) { console.log('  bail: no candidate cells in bbox'); return; }
        
        // Refine many cells per pass for fast coverage (500 cells)
        let cellsToRefine = candidateCells;
        if (cellsToRefine.length > 500) {
            cellsToRefine = cellsToRefine.sort(() => Math.random() - 0.5).slice(0, 500);
        }
        
        refinementInProgress = true;
        const startTime = performance.now();
        
        // Mini-train each cell starting from CURRENT trained weights
        const idxX = lossSurfaceWeightIndices[0];
        const idxY = lossSurfaceWeightIndices[1];
        
        // Save current weights (these are our good starting point)
        const trainedWeights = network.weights.map(layer => 
            Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
        );
        const trainedBiases = network.biases.map(layer => layer.slice());
        
        // Use actual training data (with noise) - same as real training
        const samples = dataset.train || [];
        if (samples.length === 0) {
            console.log('  bail: no training data');
            refinementInProgress = false;
            return;
        }
        
        const lr = 0.1;   // Higher LR for faster convergence
        const miniSteps = 10;  // Fewer steps - we're starting from good weights
        
        let refined = 0;
        let totalImprovement = 0;
        let maxImprovement = 0;
        
        for (const cell of cellsToRefine) {
            // Start from current trained weights
            network.weights = trainedWeights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            network.biases = trainedBiases.map(layer => layer.slice());
            
            // Set w1, w2 to this cell's position
            setWeightByIndex(idxX, cell.wx);
            setWeightByIndex(idxY, cell.wy);
            
            // Mini-training: optimize other weights while holding (w1, w2) FROZEN
            // Must match initial mini-training algorithm exactly
            const H = network.hiddenSize;
            const L = network.numLayers;
            const actPrime = activationFns[config.activation].dfn;
            const frozenWeights = new Set([idxX, idxY]);
            const maxGrad = 10.0;
            const clipGrad = (g) => Math.max(-maxGrad, Math.min(maxGrad, g));
            
            // Pre-allocate arrays for backprop
            const deltaNext = new Float64Array(H);
            const deltaPrev = new Float64Array(H);
            const delta = new Float64Array(H);
            
            for (let step = 0; step < miniSteps; step++) {
                // Zero gradients
                for (let l = 0; l < grads.weights.length; l++) {
                    const gwl = grads.weights[l];
                    if (Array.isArray(gwl[0])) {
                        for (let i = 0; i < gwl.length; i++) gwl[i].fill(0);
                    } else {
                        gwl.fill(0);
                    }
                    grads.biases[l].fill(0);
                }
                
                // Accumulate gradients from all samples
                for (const sample of samples) {
                    const fwd = forward(sample.x);
                    const activations = fwd.activations;
                    const zValues = fwd.zValues;
                    const deltaOut = fwd.yhat - sample.y;
                    
                    // Output layer
                    const hLast = activations[activations.length - 1];
                    const outGrads = grads.weights[grads.weights.length - 1];
                    const outWeights = network.weights[network.weights.length - 1];
                    for (let i = 0; i < H; i++) {
                        outGrads[i] += deltaOut * hLast[i];
                        deltaNext[i] = outWeights[i] * deltaOut;
                    }
                    grads.biases[grads.biases.length - 1][0] += deltaOut;
                    
                    // Hidden layers (backprop)
                    for (let l = L - 1; l >= 0; l--) {
                        const z = zValues[l];
                        for (let i = 0; i < H; i++) delta[i] = deltaNext[i] * actPrime(z[i]);
                        
                        if (l === 0) {
                            const gw0 = grads.weights[0];
                            const gb0 = grads.biases[0];
                            for (let i = 0; i < H; i++) {
                                gw0[i] += delta[i] * sample.x;
                                gb0[i] += delta[i];
                            }
                        } else {
                            const prev = activations[l];
                            const gwl = grads.weights[l];
                            const gbl = grads.biases[l];
                            for (let i = 0; i < H; i++) {
                                const gwli = gwl[i];
                                const di = delta[i];
                                for (let j = 0; j < H; j++) gwli[j] += di * prev[j];
                                gbl[i] += di;
                            }
                        }
                        
                        if (l > 0) {
                            const w = network.weights[l];
                            for (let j = 0; j < H; j++) deltaPrev[j] = 0;
                            for (let i = 0; i < H; i++) {
                                const wi = w[i];
                                const di = delta[i];
                                for (let j = 0; j < H; j++) deltaPrev[j] += wi[j] * di;
                            }
                            for (let j = 0; j < H; j++) deltaNext[j] = deltaPrev[j];
                        }
                    }
                }
                
                // Update weights - SKIP frozen weights (same as mini-training)
                const scaledLr = lr / samples.length;
                
                // Layer 0
                const nw0 = network.weights[0];
                const gw0 = grads.weights[0];
                for (let i = 0; i < H; i++) {
                    if (!frozenWeights.has(i)) {
                        nw0[i] -= scaledLr * clipGrad(gw0[i]);
                    }
                }
                const nb0 = network.biases[0];
                const gb0 = grads.biases[0];
                for (let i = 0; i < nb0.length; i++) {
                    nb0[i] -= scaledLr * clipGrad(gb0[i]);
                }
                
                // Hidden layers
                let baseIdx = H;
                for (let l = 1; l < L; l++) {
                    const nwl = network.weights[l];
                    const gwl = grads.weights[l];
                    for (let i = 0; i < H; i++) {
                        const nwli = nwl[i];
                        const gwli = gwl[i];
                        for (let j = 0; j < H; j++) {
                            const globalIdx = baseIdx + i * H + j;
                            if (!frozenWeights.has(globalIdx)) {
                                nwli[j] -= scaledLr * clipGrad(gwli[j]);
                            }
                        }
                    }
                    const nbl = network.biases[l];
                    const gbl = grads.biases[l];
                    for (let i = 0; i < nbl.length; i++) {
                        nbl[i] -= scaledLr * clipGrad(gbl[i]);
                    }
                    baseIdx += H * H;
                }
                
                // Output layer
                const outLayerIdx = network.weights.length - 1;
                const nwOut = network.weights[outLayerIdx];
                const gwOut = grads.weights[outLayerIdx];
                for (let i = 0; i < H; i++) {
                    const globalIdx = baseIdx + i;
                    if (!frozenWeights.has(globalIdx)) {
                        nwOut[i] -= scaledLr * clipGrad(gwOut[i]);
                    }
                }
                const nbOut = network.biases[outLayerIdx];
                const gbOut = grads.biases[outLayerIdx];
                for (let i = 0; i < nbOut.length; i++) {
                    nbOut[i] -= scaledLr * clipGrad(gbOut[i]);
                }
            }
            
            // Evaluate final loss
            let newLoss = 0;
            for (const sample of samples) {
                const fwd = forward(sample.x);
                const err = fwd.yhat - sample.y;
                newLoss += 0.5 * err * err;
            }
            newLoss /= samples.length;
            
            // Track all comparisons for debugging
            const ratio = cell.loss / newLoss;
            
            // Update cell if loss is LOWER than original surface
            if (newLoss < cell.loss) {
                totalImprovement += ratio;
                if (ratio > maxImprovement) maxImprovement = ratio;
                grid[cell.iy][cell.ix].loss = newLoss;
                refined++;
            }
        }
        
        // Sample a few cells to show what refinement is finding
        if (cellsToRefine.length > 0 && refined === 0) {
            const sampleCell = cellsToRefine[0];
            // Re-evaluate to show the comparison
            network.weights = trainedWeights.map(layer => 
                Array.isArray(layer[0]) ? layer.map(row => row.slice()) : layer.slice()
            );
            network.biases = trainedBiases.map(layer => layer.slice());
            setWeightByIndex(idxX, sampleCell.wx);
            setWeightByIndex(idxY, sampleCell.wy);
            let sampleLoss = 0;
            for (const sample of samples) {
                const fwd = forward(sample.x);
                const err = fwd.yhat - sample.y;
                sampleLoss += 0.5 * err * err;
            }
            sampleLoss /= samples.length;
            console.log(`    Sample cell (${sampleCell.wx.toFixed(2)},${sampleCell.wy.toFixed(2)}): original=${sampleCell.loss.toExponential(2)}, refined=${sampleLoss.toExponential(2)}, ratio=${(sampleCell.loss/sampleLoss).toFixed(2)}√ó`);
        }
        
        // Restore current trained weights
        network.weights = trainedWeights;
        network.biases = trainedBiases;
        
        refinementInProgress = false;
        
        const elapsed = (performance.now() - startTime).toFixed(0);
        
        // Log current training loss for context
        const currentTrainLoss = history.loss.length > 0 ? history.loss[history.loss.length - 1] : null;
        const avgOriginalLoss = cellsToRefine.reduce((s, c) => s + c.loss, 0) / cellsToRefine.length;
        
        if (refined > 0) {
            const avgImprove = (totalImprovement / refined).toFixed(1);
            console.log(`  Refined ${refined}/${cellsToRefine.length} cells in ${elapsed}ms (avg ${avgImprove}√ó better, max ${maxImprovement.toFixed(1)}√ó)`);
            console.log(`    Current training loss: ${currentTrainLoss?.toExponential(2)}, avg original cell loss: ${avgOriginalLoss.toExponential(2)}`);
            drawLossSurface();
        } else {
            console.log(`  No cells improved (${elapsed}ms) - training loss: ${currentTrainLoss?.toExponential(2)}, avg cell loss: ${avgOriginalLoss.toExponential(2)}`);
        }
    }
    
    function drawLossSurface() {
        const canvas = document.getElementById('lossCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;
        const paddingLeft = 60;
        const paddingRight = 60;
        const paddingTop = 40;
        const paddingBottom = 40;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const plotW = w - paddingLeft - paddingRight;
        const plotH = h - paddingTop - paddingBottom;
        
        if (!lossSurfaceCache) {
            // Draw placeholder axes and message
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(paddingLeft, paddingTop);
            ctx.lineTo(paddingLeft, h - paddingBottom);
            ctx.lineTo(w - paddingRight, h - paddingBottom);
            ctx.stroke();
            
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Computing...', w/2, h/2);
            return;
        }
        
        const { grid, minLoss, maxLoss, minX: gridMinX, maxX: gridMaxX, minY: gridMinY, maxY: gridMaxY, resolutionX, resolutionY } = lossSurfaceCache;
        
        // Use view bounds for display (slow zoom), or grid bounds if view not initialized
        const viewMinX = lossSurfaceViewBounds ? lossSurfaceViewBounds.minX : gridMinX;
        const viewMaxX = lossSurfaceViewBounds ? lossSurfaceViewBounds.maxX : gridMaxX;
        const viewMinY = lossSurfaceViewBounds ? lossSurfaceViewBounds.minY : gridMinY;
        const viewMaxY = lossSurfaceViewBounds ? lossSurfaceViewBounds.maxY : gridMaxY;
        
        // Grid coordinate ranges
        const gridRangeX = gridMaxX - gridMinX;
        const gridRangeY = gridMaxY - gridMinY;
        
        // Calibrated logarithmic color scale - set at start of training and locked
        const calibratedMinLog = Math.log10(Math.max(1e-6, lossColorScale.minLoss));
        const calibratedMaxLog = Math.log10(Math.max(1e-6, lossColorScale.maxLoss));
        const calibratedLogRange = Math.max(0.1, calibratedMaxLog - calibratedMinLog);  // Avoid division by zero
        
        // Debug first draw
        if (!lossSurfaceCache._debugged) {
            console.log(`Drawing loss surface: minLog=${calibratedMinLog.toFixed(2)}, maxLog=${calibratedMaxLog.toFixed(2)}, range=${calibratedLogRange.toFixed(2)}`);
            console.log(`  First cell loss: ${grid[0][0].loss?.toFixed(4) || grid[0][0]}`);
            lossSurfaceCache._debugged = true;
        }
        
        // Draw the portion of the grid visible in the view
        // Map view coordinates to grid indices and draw at appropriate screen positions
        const viewRangeX = viewMaxX - viewMinX;
        const viewRangeY = viewMaxY - viewMinY;
        
        // Number of pixels per unit in view space
        const pxPerUnitX = plotW / viewRangeX;
        const pxPerUnitY = plotH / viewRangeY;
        
        // Set up clipping region for the plot area
        ctx.save();
        ctx.beginPath();
        ctx.rect(paddingLeft, paddingTop, plotW, plotH);
        ctx.clip();
        
        // Check for valid loss range
        if (!isFinite(minLoss) || !isFinite(maxLoss) || minLoss >= maxLoss) {
            ctx.fillStyle = '#ddd';
            ctx.fillRect(paddingLeft, paddingTop, plotW, plotH);
            ctx.restore();
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Invalid loss range', w/2, h/2);
            return;
        }
        
        // Draw grid cells - handles non-uniform grids with stored coordinates
        for (let iy = 0; iy < resolutionY; iy++) {
            for (let ix = 0; ix < resolutionX; ix++) {
                const cell = grid[iy][ix];
                // Support both old format (just loss) and new format ({loss, wx, wy})
                const loss = typeof cell === 'object' ? cell.loss : cell;
                const cellCenterX = typeof cell === 'object' ? cell.wx : (gridMinX + ((ix + 0.5) / resolutionX) * gridRangeX);
                const cellCenterY = typeof cell === 'object' ? cell.wy : (gridMinY + ((iy + 0.5) / resolutionY) * gridRangeY);
                
                // For non-uniform grids, estimate cell size from neighbors
                let cellHalfW, cellHalfH;
                if (typeof cell === 'object') {
                    // Non-uniform: estimate size from neighboring cells
                    const nextX = ix < resolutionX - 1 ? grid[iy][ix + 1].wx : cellCenterX + (cellCenterX - grid[iy][Math.max(0, ix - 1)].wx);
                    const prevX = ix > 0 ? grid[iy][ix - 1].wx : cellCenterX - (grid[iy][Math.min(resolutionX - 1, ix + 1)].wx - cellCenterX);
                    const nextY = iy < resolutionY - 1 ? grid[iy + 1][ix].wy : cellCenterY + (cellCenterY - grid[Math.max(0, iy - 1)][ix].wy);
                    const prevY = iy > 0 ? grid[iy - 1][ix].wy : cellCenterY - (grid[Math.min(resolutionY - 1, iy + 1)][ix].wy - cellCenterY);
                    cellHalfW = (nextX - prevX) / 4;  // Half of average spacing
                    cellHalfH = (nextY - prevY) / 4;
                } else {
                    // Uniform grid
                    cellHalfW = gridRangeX / resolutionX / 2;
                    cellHalfH = gridRangeY / resolutionY / 2;
                }
                
                const cellMinX = cellCenterX - cellHalfW;
                const cellMaxX = cellCenterX + cellHalfW;
                const cellMinY = cellCenterY - cellHalfH;
                const cellMaxY = cellCenterY + cellHalfH;
                
                // Skip if cell is completely outside view
                if (cellMaxX < viewMinX || cellMinX > viewMaxX || cellMaxY < viewMinY || cellMinY > viewMaxY) {
                    continue;
                }
                
                // Clip cell to view bounds
                const drawMinX = Math.max(cellMinX, viewMinX);
                const drawMaxX = Math.min(cellMaxX, viewMaxX);
                const drawMinY = Math.max(cellMinY, viewMinY);
                const drawMaxY = Math.min(cellMaxY, viewMaxY);
                
                // Convert to screen coordinates
                const px = paddingLeft + (drawMinX - viewMinX) * pxPerUnitX;
                const py = paddingTop + (viewMaxY - drawMaxY) * pxPerUnitY;  // Y is flipped
                const pw = (drawMaxX - drawMinX) * pxPerUnitX;
                const ph = (drawMaxY - drawMinY) * pxPerUnitY;
                
                // Calibrated log scale normalization with power compression
                // Using x^1.5 makes green closer to blue (more of map appears blue/cyan/green)
                // Linear 50% loss ‚Üí appears at 35% of color scale (more blue-ish green)
                const clampedLoss = Math.max(lossColorScale.minLoss, Math.min(lossColorScale.maxLoss, loss));
                const logLoss = Math.log10(clampedLoss);
                const linearNorm = Math.max(0, Math.min(1, (logLoss - calibratedMinLog) / calibratedLogRange));
                // Apply power > 1 to expand low-loss colors: 0.5^1.5 ‚âà 0.35
                const normLoss = Math.pow(linearNorm, 1.5);
                
                // HSL color gradient: 240 (blue) ‚Üí 120 (green) ‚Üí 0 (red)
                const hue = 240 * (1 - normLoss);
                const sat = 85 + 15 * Math.sin(normLoss * Math.PI);
                const light = 38 + 22 * (1 - Math.abs(normLoss - 0.5) * 2);
                
                ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                ctx.fillRect(px, py, pw + 1, ph + 1);
            }
        }
        
        // Restore context (remove clipping)
        ctx.restore();
        
        // Draw border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.strokeRect(paddingLeft, paddingTop, plotW, plotH);
        
        // Helper to convert weight values to canvas coordinates (using VIEW bounds for slow zoom)
        const toCanvasX = (wx) => paddingLeft + ((wx - viewMinX) / (viewMaxX - viewMinX)) * plotW;
        const toCanvasY = (wy) => paddingTop + (1 - (wy - viewMinY) / (viewMaxY - viewMinY)) * plotH;
        
        // Check for comparison mode - only valid if network architecture, activation, and target are the same
        // (comparing optimizer or learning rate differences makes sense, but different architectures don't share a loss landscape)
        function canCompareLossLandscapes() {
            if (!comparisonModeActive || !savedRuns.A || !savedRuns.B) return false;
            const cfgA = savedRuns.A.config;
            const cfgB = savedRuns.B.config;
            
            // Must have same architecture
            if (cfgA.numLayers !== cfgB.numLayers) return false;
            if (cfgA.hiddenSize !== cfgB.hiddenSize) return false;
            
            // Must have same activation (changes landscape shape)
            if (cfgA.activation !== cfgB.activation) return false;
            
            // Must have same target function
            if (cfgA.targetFuncStr !== cfgB.targetFuncStr) return false;
            
            // Must have saved trails with same weight indices
            if (!savedRuns.A.lossSurfaceTrail || !savedRuns.B.lossSurfaceTrail) return false;
            if (!savedRuns.A.lossSurfaceWeightIndices || !savedRuns.B.lossSurfaceWeightIndices) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[0] !== savedRuns.B.lossSurfaceWeightIndices[0]) return false;
            if (savedRuns.A.lossSurfaceWeightIndices[1] !== savedRuns.B.lossSurfaceWeightIndices[1]) return false;
            
            return true;
        }
        
        const inComparisonMode = canCompareLossLandscapes();
        
        // Helper to draw a trail
        function drawTrail(trail, color, alpha = 0.85) {
            if (!trail || trail.length < 2) return;
            ctx.strokeStyle = color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(toCanvasX(trail[0].x), toCanvasY(trail[0].y));
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(toCanvasX(trail[i].x), toCanvasY(trail[i].y));
            }
            ctx.stroke();
        }
        
        if (inComparisonMode) {
            // Draw Run A trail (red/orange)
            if (savedRuns.A.lossSurfaceTrail) {
                drawTrail(savedRuns.A.lossSurfaceTrail, 'rgb(220, 53, 69)', 0.9);
                // Start marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const startA = savedRuns.A.lossSurfaceTrail[0];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startA.x), toCanvasY(startA.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for A
                if (savedRuns.A.lossSurfaceTrail.length > 0) {
                    const endA = savedRuns.A.lossSurfaceTrail[savedRuns.A.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#dc3545';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endA.x), toCanvasY(endA.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw Run B trail (cyan/teal)
            if (savedRuns.B.lossSurfaceTrail) {
                drawTrail(savedRuns.B.lossSurfaceTrail, 'rgb(0, 188, 212)', 0.9);
                // Start marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const startB = savedRuns.B.lossSurfaceTrail[0];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(startB.x), toCanvasY(startB.y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                // End marker for B
                if (savedRuns.B.lossSurfaceTrail.length > 0) {
                    const endB = savedRuns.B.lossSurfaceTrail[savedRuns.B.lossSurfaceTrail.length - 1];
                    ctx.fillStyle = '#00bcd4';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(toCanvasX(endB.x), toCanvasY(endB.y), 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        } else {
            // Normal mode - single trail
            if (lossSurfaceTrail.length > 1) {
                // Draw white trail with slight transparency
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                const first = lossSurfaceTrail[0];
                ctx.moveTo(toCanvasX(first.x), toCanvasY(first.y));
                for (let i = 1; i < lossSurfaceTrail.length; i++) {
                    const pt = lossSurfaceTrail[i];
                    ctx.lineTo(toCanvasX(pt.x), toCanvasY(pt.y));
                }
                ctx.stroke();
            }
            
            // Always draw start point if we have a starting position
            if (lossSurfaceStartPosition) {
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(toCanvasX(lossSurfaceStartPosition.x), toCanvasY(lossSurfaceStartPosition.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            // Draw current position with gradient arrow
            const currentWX = getWeightByIndex(lossSurfaceWeightIndices[0]);
            const currentWY = getWeightByIndex(lossSurfaceWeightIndices[1]);
            const posX = toCanvasX(currentWX);
            const posY = toCanvasY(currentWY);
            
            // Get gradient direction for arrow (use last completed epoch's average)
            let grad1 = 0, grad2 = 0, gradMag = 0;
            if (trainingState.lastEpochGrad) {
                grad1 = trainingState.lastEpochGrad.w1;
                grad2 = trainingState.lastEpochGrad.w2;
                gradMag = trainingState.lastEpochGrad.mag;
            }
            
            ctx.fillStyle = '#dc3545';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            
            // Draw arrow if gradient is significant, otherwise draw dot
            const minGradForArrow = 1e-6;
            if (gradMag > minGradForArrow) {
                // Normalize and scale gradient for arrow length
                // Arrow points in descent direction (negative gradient)
                const scale = Math.min(30, 10 + 20 * Math.log10(gradMag + 1e-10) / 3);  // 10-30 pixels
                const arrowLen = Math.max(12, Math.min(40, scale > 0 ? scale : 12));
                const dx = -grad1 / gradMag * arrowLen;
                const dy = grad2 / gradMag * arrowLen;  // Y is inverted in canvas
                
                const endX = posX + dx;
                const endY = posY + dy;
                
                // Draw arrow shaft
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(posX, posY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Draw arrowhead
                const headLen = 8;
                const angle = Math.atan2(dy, dx);
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI/6), endY - headLen * Math.sin(angle - Math.PI/6));
                ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI/6), endY - headLen * Math.sin(angle + Math.PI/6));
                ctx.closePath();
                ctx.fillStyle = '#dc3545';
                ctx.fill();
                
                // Draw small dot at current position (arrow origin)
                ctx.fillStyle = '#dc3545';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(posX, posY, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            } else {
                // No significant gradient - draw simple dot
                ctx.beginPath();
                ctx.arc(posX, posY, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        // Axis labels
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        
        // X axis labels - just below the plot area (using VIEW bounds for slow zoom)
        const xLabelY = h - paddingBottom + 15;
        ctx.fillText(viewMinX.toFixed(1), paddingLeft, xLabelY);
        ctx.fillText(viewMaxX.toFixed(1), w - paddingRight, xLabelY);
        ctx.fillText('w‚ÇÅ', (paddingLeft + w - paddingRight) / 2, xLabelY);
        
        // Y axis labels - just left of the plot area (using VIEW bounds for slow zoom)
        ctx.textAlign = 'right';
        ctx.fillText(viewMinY.toFixed(1), paddingLeft - 4, h - paddingBottom + 3);
        ctx.fillText(viewMaxY.toFixed(1), paddingLeft - 4, paddingTop + 3);
        
        // Y axis title
        ctx.save();
        ctx.translate(12, (paddingTop + h - paddingBottom) / 2);
        ctx.rotate(-Math.PI/2);
        ctx.textAlign = 'center';
        ctx.fillText('w‚ÇÇ', 0, 0);
        ctx.restore();
    }
   
    function updateUI() {
        try {
            document.getElementById('stepCount').textContent = trainingState.step;
            const lastLoss = history.loss[history.loss.length - 1];
            const lossValue = document.getElementById('lossValue');
            if (lossValue) {
                lossValue.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }

            document.getElementById('totalAdds').textContent = trainingState.totalAdds.toLocaleString();
            document.getElementById('totalMuls').textContent = trainingState.totalMuls.toLocaleString();
            
            // Format ops count helper
            function formatOps(count) {
                if (count >= 1e9) return (count / 1e9).toFixed(1) + 'B';
                if (count >= 1e6) return (count / 1e6).toFixed(1) + 'M';
                if (count >= 1e3) return (count / 1e3).toFixed(1) + 'K';
                return count.toString();
            }
            
            // Update individual adds/muls displays
            const totalAddsDisplay = document.getElementById('totalAddsDisplay');
            const totalMulsDisplay = document.getElementById('totalMulsDisplay');
            if (totalAddsDisplay) totalAddsDisplay.textContent = formatOps(trainingState.totalAdds);
            if (totalMulsDisplay) totalMulsDisplay.textContent = formatOps(trainingState.totalMuls);
            
            // Update total ops display
            const totalOps = trainingState.totalAdds + trainingState.totalMuls;
            const totalOpsDisplay = document.getElementById('totalOpsDisplay');
            if (totalOpsDisplay) {
                totalOpsDisplay.textContent = formatOps(totalOps);
            }
            
            // Update epoch and step counters
            const epochCountEl = document.getElementById('epochCount');
            if (epochCountEl) {
                epochCountEl.textContent = dataset.epoch;
            }
            
            // Update train/test loss displays
            const trainLossEl = document.getElementById('trainLossValue');
            const testLossEl = document.getElementById('testLossValue');
            
            if (trainLossEl) {
                trainLossEl.textContent = Number.isFinite(lastLoss) ? lastLoss.toExponential(2) : '‚Äî';
            }
            
            // Only show test loss after evaluation button is clicked
            if (testLossEl && history.testLoss.length > 0 && revealOptions.evaluated) {
                const lastTestLoss = history.testLoss[history.testLoss.length - 1].loss;
                testLossEl.textContent = Number.isFinite(lastTestLoss) ? lastTestLoss.toExponential(2) : '‚Äî';
                
                // Highlight overfitting: test loss > train loss significantly
                if (lastTestLoss > lastLoss * 1.5) {
                    testLossEl.style.color = '#dc3545';  // Red warning
                } else {
                    testLossEl.style.color = '#ff9800';  // Normal orange
                }
            } else if (testLossEl) {
                testLossEl.textContent = '‚Äî';
                testLossEl.style.color = '#888';
            }
            
            // Update epoch status display
            if (dataset.generated) {
                const epochStatus = document.getElementById('epochStatus');
                if (epochStatus) {
                    epochStatus.textContent = `Epoch ${dataset.epoch} ‚Ä¢ Step ${dataset.stepInEpoch}/${dataset.train.length}`;
                }
            }
            
            // Calculate delta-loss (change in rolling average over last window)
            const deltaLossEl = document.getElementById('deltaLossValue');
            if (deltaLossEl && history.avgLoss.length >= 2) {
                const windowSize = Math.min(config.avgWindow, history.avgLoss.length);
                const currentAvg = history.avgLoss[history.avgLoss.length - 1];
                const prevAvg = history.avgLoss[Math.max(0, history.avgLoss.length - windowSize)];
                const deltaLoss = currentAvg - prevAvg;
                
                if (Number.isFinite(deltaLoss)) {
                    const sign = deltaLoss > 0 ? '+' : '';
                    deltaLossEl.textContent = sign + deltaLoss.toExponential(2);
                    // Green if decreasing (good), red if increasing (bad)
                    deltaLossEl.style.color = deltaLoss <= 0 ? '#28a745' : '#dc3545';
                } else {
                    deltaLossEl.textContent = '‚Äî';
                    deltaLossEl.style.color = '#666';
                }
            }

            // Update view slider max based on training progress
            try { updateViewSliderMax(); } catch(e) { /* ignore */ }

            try { drawNetwork(); } catch(e) { console.error('drawNetwork error:', e); }
            try { drawFitPlot(); } catch(e) { console.error('drawFitPlot error:', e); }
            try { drawTrainingTrace(); } catch(e) { console.error('drawTrainingTrace error:', e); }
            try { drawLossSurface(); } catch(e) { console.error('drawLossSurface error:', e); }
            try { updateEquations(); } catch(e) { console.error('updateEquations error:', e); }
        } catch(e) {
            console.error('updateUI error:', e);
        }
    }
    
    // Track when we last auto-paused to allow continued training
    let lastAutoPauseStep = -2000;
    
    // Check if training should auto-pause (no improvement in last 1000 steps)
    function shouldAutoPause() {
        // Need at least 2000 steps before first check
        if (history.loss.length < 2000) return false;
        
        // Must run at least 500 steps since last auto-pause before checking again
        if (trainingState.step - lastAutoPauseStep < 500) return false;
        
        // Compute 1000-step rolling average for current window
        const windowSize = 1000;
        const currentWindow = history.loss.slice(-windowSize);
        const currentAvg = currentWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Compute 1000-step rolling average for previous window (1000 steps ago)
        const prevWindow = history.loss.slice(-2000, -1000);
        const prevAvg = prevWindow.reduce((a, b) => a + b, 0) / windowSize;
        
        // Pause if current average hasn't improved by at least 1% over previous average
        if (currentAvg >= prevAvg * 0.99) {
            lastAutoPauseStep = trainingState.step;
            return true;
        }
        return false;
    }

    // --------------- Wiring Controls ----------------

    function setupControls() {
        const lrSlider = document.getElementById('learningRate');
        const lrValue = document.getElementById('learningRateValue');
        lrSlider.addEventListener('input', () => {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        });
        (function initLR() {
            const log10eta = parseFloat(lrSlider.value);
            const eta = Math.pow(10, log10eta);
            config.learningRate = eta;
            lrValue.textContent = eta.toFixed(3);
        })();

        const noiseSlider = document.getElementById('noise');
        const noiseLabel = document.getElementById('noiseValue');
        noiseSlider.addEventListener('input', () => {
            config.noise = parseFloat(noiseSlider.value);
            noiseLabel.textContent = config.noise.toFixed(2);
        });
        config.noise = parseFloat(noiseSlider.value);
        noiseLabel.textContent = config.noise.toFixed(2);

        // ===== UNIFIED SLIDERS =====
        
        // Helper: Update slider value label position
        function updateSliderValuePosition(slider, valueEl) {
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const val = parseFloat(slider.value);
            const percent = ((val - min) / (max - min)) * 100;
            // Thumb doesn't go to 0% or 100% - it's constrained by thumb width (30px)
            // Interpolate position from 15px at 0% to (100% - 15px) at 100%
            valueEl.style.left = `calc(15px + (100% - 30px) * ${percent / 100})`;
            // Also update fill for non-range sliders
            slider.style.setProperty('--fill-percent', percent + '%');
            // Set thumb position on parent track element
            const track = slider.parentElement;
            if (track) track.style.setProperty('--thumb-position', percent + '%');
        }
        
        // Layers Slider
        const layersSlider = document.getElementById('layersSlider');
        const layersValue = document.getElementById('layersValue');
        if (layersSlider && layersValue) {
            console.log('Setting up layers slider, current network.numLayers:', network.numLayers);
            layersSlider.oninput = function() {
                const newVal = parseInt(this.value, 10);
                console.log('Layers slider changed to:', newVal, 'from network.numLayers:', network.numLayers);
                network.numLayers = newVal;
                layersValue.textContent = newVal.toString();
                updateSliderValuePosition(this, layersValue);
                console.log('Calling resetModel for layers change...');
                try {
                    resetModel();
                    console.log('resetModel completed, network.numLayers is now:', network.numLayers);
                } catch(e) {
                    console.error('resetModel error (layers):', e);
                }
            };
            // Initialize slider to match network state
            layersSlider.value = network.numLayers;
            layersValue.textContent = network.numLayers.toString();
            updateSliderValuePosition(layersSlider, layersValue);
        } else {
            console.error('Layers slider or value element not found!');
        }
        
        // Width Slider
        const widthSlider = document.getElementById('widthSlider');
        const widthValue = document.getElementById('widthValue');
        if (widthSlider && widthValue) {
            console.log('Setting up width slider, current network.hiddenSize:', network.hiddenSize);
            widthSlider.oninput = function() {
                const newVal = parseInt(this.value, 10);
                console.log('Width slider changed to:', newVal, 'from network.hiddenSize:', network.hiddenSize);
                network.hiddenSize = newVal;
                widthValue.textContent = newVal.toString();
                updateSliderValuePosition(this, widthValue);
                console.log('Calling resetModel for width change...');
                try {
                    resetModel();
                    console.log('resetModel completed, network.hiddenSize is now:', network.hiddenSize);
                } catch(e) {
                    console.error('resetModel error (width):', e);
                }
            };
            // Initialize
            widthSlider.value = network.hiddenSize;
            widthValue.textContent = network.hiddenSize.toString();
            updateSliderValuePosition(widthSlider, widthValue);
        } else {
            console.error('Width slider or value element not found!');
        }
        
        // Train Range Sliders (two-thumb)
        const trainMinSlider = document.getElementById('trainMinSlider');
        const trainMaxSlider = document.getElementById('trainMaxSlider');
        const trainMinValue = document.getElementById('trainMinValue');
        const trainMaxValue = document.getElementById('trainMaxValue');
        const trainRangeFill = document.getElementById('trainRangeFill');
        
        function updateTrainRangeUI() {
            if (!trainMinSlider || !trainMaxSlider) return;
            
            const min = parseFloat(trainMinSlider.min);
            const max = parseFloat(trainMinSlider.max);
            const minVal = parseFloat(trainMinSlider.value);
            const maxVal = parseFloat(trainMaxSlider.value);
            
            // Thumb is 34px wide, so half-width is 17px
            // Interpolate position from 17px at 0% to (100% - 17px) at 100%
            const minPercent = ((minVal - min) / (max - min));
            const maxPercent = ((maxVal - min) / (max - min));
            
            // Update value labels - position them on the thumb center
            if (trainMinValue) {
                trainMinValue.textContent = minVal.toFixed(1);
                trainMinValue.style.left = `calc(17px + (100% - 34px) * ${minPercent})`;
            }
            if (trainMaxValue) {
                trainMaxValue.textContent = maxVal.toFixed(1);
                trainMaxValue.style.left = `calc(17px + (100% - 34px) * ${maxPercent})`;
            }
            
            // Update fill bar - same positioning formula
            if (trainRangeFill) {
                const leftPos = `calc(17px + (100% - 34px) * ${minPercent})`;
                const rightPos = `calc(17px + (100% - 34px) * ${maxPercent})`;
                trainRangeFill.style.left = leftPos;
                trainRangeFill.style.width = `calc((100% - 34px) * ${maxPercent - minPercent})`;
            }
        }
        
        if (trainMinSlider && trainMaxSlider) {
            trainMinSlider.addEventListener('input', () => {
                // Ensure min doesn't exceed max
                const maxVal = parseFloat(trainMaxSlider.value);
                if (parseFloat(trainMinSlider.value) > maxVal - 0.2) {
                    trainMinSlider.value = (maxVal - 0.2).toString();
                }
                config.trainXMin = parseFloat(trainMinSlider.value);
                updateTrainRangeUI();
                if (dataset.generated) {
                    updateTrainingRangeFromConfig();
                    drawFitPlot();
                    updateUI();
                }
            });
            
            trainMaxSlider.addEventListener('input', () => {
                // Ensure max doesn't go below min
                const minVal = parseFloat(trainMinSlider.value);
                if (parseFloat(trainMaxSlider.value) < minVal + 0.2) {
                    trainMaxSlider.value = (minVal + 0.2).toString();
                }
                config.trainXMax = parseFloat(trainMaxSlider.value);
                updateTrainRangeUI();
                if (dataset.generated) {
                    updateTrainingRangeFromConfig();
                    drawFitPlot();
                    updateUI();
                }
            });
        }
        
        // View Slider (training trace zoom)
        const viewSlider = document.getElementById('viewSlider');
        const viewValue = document.getElementById('viewValue');
        
        if (viewSlider && viewValue) {
            viewSlider.addEventListener('input', () => {
                const sliderVal = parseInt(viewSlider.value, 10);
                const maxPossible = parseInt(viewSlider.max, 10);
                
                if (sliderVal >= maxPossible) {
                    traceViewState.maxStep = Infinity;
                    viewValue.textContent = 'All';
                } else {
                    traceViewState.maxStep = sliderVal;
                    viewValue.textContent = sliderVal.toString();
                }
                updateSliderValuePosition(viewSlider, viewValue);
                drawTrainingTrace();
            });
            // Initialize
            updateSliderValuePosition(viewSlider, viewValue);
        }
        
        // Legacy backward compatibility (old mobile sliders - hidden)
        const numLayersSlider = document.getElementById('numLayers');
        const numLayersDisplay = document.getElementById('numLayersDisplay');
        const hiddenSizeSlider = document.getElementById('hiddenSize');
        const hiddenSizeDisplay = document.getElementById('hiddenSizeDisplay');

        const xMinSlider = document.getElementById('xMin');
        const xMaxSlider = document.getElementById('xMax');
        const xMinLabel = document.getElementById('xMinLabel');
        const xMaxLabel = document.getElementById('xMaxLabel');
        function syncXRange() {
            let minVal = parseFloat(xMinSlider.value);
            let maxVal = parseFloat(xMaxSlider.value);
            if (minVal >= maxVal) {
                if (this === xMinSlider) {
                    minVal = maxVal - 0.1;
                    xMinSlider.value = minVal.toString();
                } else {
                    maxVal = minVal + 0.1;
                    xMaxSlider.value = maxVal.toString();
                }
            }
            config.xMin = minVal;
            config.xMax = maxVal;
            xMinLabel.textContent = minVal.toFixed(1);
            xMaxLabel.textContent = maxVal.toFixed(1);
        }
        xMinSlider.addEventListener('input', syncXRange);
        xMaxSlider.addEventListener('input', syncXRange);
        config.xMin = parseFloat(xMinSlider.value);
        config.xMax = parseFloat(xMaxSlider.value);

        // Mobile x-range sliders
        const xMinMobile = document.getElementById('xMinMobile');
        const xMaxMobile = document.getElementById('xMaxMobile');
        const xMinMobileVal = document.getElementById('xMinMobileVal');
        const xMaxMobileVal = document.getElementById('xMaxMobileVal');
        if (xMinMobile && xMaxMobile) {
            xMinMobile.addEventListener('input', () => {
                config.xMin = parseFloat(xMinMobile.value);
                xMinMobileVal.textContent = config.xMin.toFixed(1);
                xMinSlider.value = config.xMin;
                drawFitPlot();
            });
            xMaxMobile.addEventListener('input', () => {
                config.xMax = parseFloat(xMaxMobile.value);
                xMaxMobileVal.textContent = config.xMax.toFixed(1);
                xMaxSlider.value = config.xMax;
                drawFitPlot();
            });
        }

        const targetFuncInput = document.getElementById('targetFuncInput');
        targetFuncInput.addEventListener('change', () => {
            compileTargetFunc();
            drawFitPlot();  // Update preview
        });
        targetFuncInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                compileTargetFunc();
                drawFitPlot();
            }
        });
        
        // Phase 1: Data generation controls
        const totalSamplesSlider = document.getElementById('totalSamples');
        const totalSamplesValue = document.getElementById('totalSamplesValue');
        if (totalSamplesSlider && totalSamplesValue) {
            totalSamplesSlider.addEventListener('input', () => {
                config.totalSamples = parseInt(totalSamplesSlider.value);
                totalSamplesValue.textContent = config.totalSamples;
            });
            config.totalSamples = parseInt(totalSamplesSlider.value);
        }
        
        // Data Range inputs for Phase 1
        const dataXMinInput = document.getElementById('dataXMinInput');
        const dataXMaxInput = document.getElementById('dataXMaxInput');
        const trainXMinInput = document.getElementById('trainXMinInput');
        const trainXMaxInput = document.getElementById('trainXMaxInput');
        
        if (dataXMinInput && dataXMaxInput) {
            dataXMinInput.addEventListener('change', () => {
                config.dataXMin = parseFloat(dataXMinInput.value);
                config.xMin = config.dataXMin;
                // Ensure train range is within data range
                if (config.trainXMin < config.dataXMin) {
                    config.trainXMin = config.dataXMin;
                    trainXMinInput.value = config.trainXMin;
                }
                drawFitPlot();
            });
            dataXMaxInput.addEventListener('change', () => {
                config.dataXMax = parseFloat(dataXMaxInput.value);
                config.xMax = config.dataXMax;
                // Ensure train range is within data range
                if (config.trainXMax > config.dataXMax) {
                    config.trainXMax = config.dataXMax;
                    trainXMaxInput.value = config.trainXMax;
                }
                drawFitPlot();
            });
            config.dataXMin = parseFloat(dataXMinInput.value);
            config.dataXMax = parseFloat(dataXMaxInput.value);
            config.xMin = config.dataXMin;
            config.xMax = config.dataXMax;
        }
        
        if (trainXMinInput && trainXMaxInput) {
            trainXMinInput.addEventListener('change', () => {
                config.trainXMin = parseFloat(trainXMinInput.value);
                // Clamp to data range
                config.trainXMin = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMin));
                trainXMinInput.value = config.trainXMin;
                drawFitPlot();
            });
            trainXMaxInput.addEventListener('change', () => {
                config.trainXMax = parseFloat(trainXMaxInput.value);
                // Clamp to data range
                config.trainXMax = Math.max(config.dataXMin, Math.min(config.dataXMax, config.trainXMax));
                trainXMaxInput.value = config.trainXMax;
                drawFitPlot();
            });
            config.trainXMin = parseFloat(trainXMinInput.value);
            config.trainXMax = parseFloat(trainXMaxInput.value);
        }
        
        // Evaluate button
        const evaluateBtn = document.getElementById('evaluateBtn');
        const evalResults = document.getElementById('evalResults');
        if (evaluateBtn) {
            evaluateBtn.addEventListener('click', () => {
                if (!dataset.generated) {
                    alert('Generate training data first!');
                    return;
                }
                
                const results = runEvaluation();
                
                if (results && evalResults) {
                    let resultText = `Total: ${results.testLossTotal.toFixed(4)}`;
                    if (results.pointsInRange > 0) {
                        resultText += ` | In-range: ${results.testLossInRange.toFixed(4)}`;
                    }
                    if (results.pointsOutRange > 0) {
                        resultText += ` | Out-range: ${results.testLossOutRange.toFixed(4)}`;
                        // Highlight if extrapolation is much worse
                        if (results.testLossOutRange > results.testLossInRange * 2) {
                            resultText += ' ‚ö†Ô∏è';
                        }
                    }
                    evalResults.textContent = resultText;
                    evalResults.style.display = 'inline';
                    evalResults.style.color = '#ff9800';
                }
                
                updateUI();
            });
        }
        
        // Generate Data button
        const generateDataBtn = document.getElementById('generateDataBtn');
        if (generateDataBtn) {
            generateDataBtn.addEventListener('click', () => {
                compileTargetFunc();
                
                // Keep training range at config defaults (symmetric -2.8 to 2.8)
                // Don't recalculate - just use what's already set in config
                document.getElementById('trainXMinInput').value = config.trainXMin;
                document.getElementById('trainXMaxInput').value = config.trainXMax;
                
                generateDataset();
                resetModel();  // Initialize model for new data
                updateUI();
            });
        }
        
        // New Data button (returns to Phase 1)
        const newDataBtn = document.getElementById('newDataBtn');
        if (newDataBtn) {
            newDataBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Don't trigger header toggle
                clearDataset();
                updateUI();
            });
        }
        
        // Data summary accordion toggle
        const dataSummaryHeader = document.getElementById('dataSummaryHeader');
        if (dataSummaryHeader) {
            dataSummaryHeader.addEventListener('click', (e) => {
                // Don't toggle if clicking the New button
                if (e.target.id === 'newDataBtn') return;
                
                const content = document.getElementById('dataSummaryContent');
                const toggle = document.getElementById('dataSummaryToggle');
                if (content && toggle) {
                    const isHidden = content.style.display === 'none';
                    content.style.display = isHidden ? 'block' : 'none';
                    toggle.textContent = isHidden ? '‚ñº' : '‚ñ∂';
                }
            });
        }
        
        // Learning Guide sidebar toggle (sidebar is visible by default)
        const guideToggle = document.getElementById('guideToggle');
        const guideSidebar = document.getElementById('guideSidebar');
        
        if (guideToggle && guideSidebar) {
            guideToggle.addEventListener('click', () => {
                const isHidden = guideSidebar.style.display === 'none';
                guideSidebar.style.display = isHidden ? '' : 'none';  // Use '' to restore default flex behavior
                guideToggle.style.background = isHidden ? '#138496' : '#17a2b8';
                guideToggle.textContent = isHidden ? 'Hide Guide ‚óÄ' : 'üìñ Show Guide';
            });
        }
        
        // Restart button (keeps loss surface, restarts training from initial position)
        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) {
            restartBtn.addEventListener('click', () => {
                resetTraining();
                document.getElementById('runBtn').textContent = 'Run';
            });
        }
        
        // Reset Model button (reinitializes weights, recomputes surface)
        const resetModelBtn = document.getElementById('resetModelBtn');
        if (resetModelBtn) {
            resetModelBtn.addEventListener('click', () => {
                resetModel();
                document.getElementById('runBtn').textContent = 'Run';
                updateUI();
            });
        }
        
        // Run Epoch button
        const runEpochBtn = document.getElementById('runEpochBtn');
        if (runEpochBtn) {
            runEpochBtn.addEventListener('click', async () => {
                if (!dataset.generated) {
                    alert('Generate examples first!');
                    return;
                }
                
                exitComparisonMode();
                runEpochBtn.disabled = true;
                runEpochBtn.textContent = 'Running...';
                
                // Run one complete epoch
                const stepsPerEpoch = dataset.train.length;
                const startStep = dataset.stepInEpoch;
                const stepsRemaining = stepsPerEpoch - startStep;
                
                for (let i = 0; i < stepsRemaining; i++) {
                    trainStep();
                    
                    // Update UI periodically
                    if (i % 10 === 0) {
                        updateUI();
                        await new Promise(r => setTimeout(r, 0));  // Allow UI to update
                    }
                }
                
                runEpochBtn.disabled = false;
                runEpochBtn.textContent = 'Run Epoch';
                updateUI();
            });
        }
        
        // Reveal controls (Assessment phase)
        const showHeldOutCheckbox = document.getElementById('showHeldOut');
        const showRecipeCheckbox = document.getElementById('showRecipe');
        
        if (showHeldOutCheckbox) {
            showHeldOutCheckbox.addEventListener('change', () => {
                revealOptions.showHeldOut = showHeldOutCheckbox.checked;
                drawFitPlot();
                // Also evaluate test loss when revealing held-out
                if (revealOptions.showHeldOut && dataset.generated) {
                    const testLoss = computeTestLoss();
                    if (history.testLoss.length === 0 || 
                        history.testLoss[history.testLoss.length - 1].step !== trainingState.step) {
                        history.testLoss.push({ step: trainingState.step, loss: testLoss });
                    }
                    updateUI();
                }
            });
        }
        
        if (showRecipeCheckbox) {
            showRecipeCheckbox.addEventListener('change', () => {
                revealOptions.showRecipe = showRecipeCheckbox.checked;
                drawFitPlot();
            });
        }
        
        // Recipe accordion toggle
        const toggleRecipeBtn = document.getElementById('toggleRecipeBtn');
        const recipeControls = document.getElementById('recipeControls');
        if (toggleRecipeBtn && recipeControls) {
            toggleRecipeBtn.addEventListener('click', () => {
                const isHidden = recipeControls.style.display === 'none';
                recipeControls.style.display = isHidden ? 'flex' : 'none';
                recipeControls.style.opacity = isHidden ? '1' : '0.6';  // Bright when editing
                toggleRecipeBtn.textContent = isHidden ? '‚ñº Hide Recipe' : '‚úèÔ∏è Edit Recipe';
            });
        }
        
        // View full data button
        const viewFullDataBtn = document.getElementById('viewFullDataBtn');
        if (viewFullDataBtn) {
            viewFullDataBtn.addEventListener('click', showFullDataView);
        }
        
        // Equations accordion toggle
        const toggleEquationsBtn = document.getElementById('toggleEquationsBtn');
        const equationsDiv = document.getElementById('equationsDiv');
        const equationsHeader = document.getElementById('equationsHeader');
        
        if (toggleEquationsBtn && equationsDiv) {
            const toggleEquations = () => {
                const isHidden = equationsDiv.style.display === 'none';
                equationsDiv.style.display = isHidden ? 'grid' : 'none';
                toggleEquationsBtn.textContent = isHidden ? '‚ñº Collapse' : '‚ñ∂ Expand';
            };
            
            toggleEquationsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleEquations();
            });
            
            // Also allow clicking on the header
            if (equationsHeader) {
                equationsHeader.addEventListener('click', toggleEquations);
            }
            
            // Start collapsed on mobile/tablet (sidebar is at bottom, want it visible)
            if (window.innerWidth <= 768) {
                equationsDiv.style.display = 'none';
                toggleEquationsBtn.textContent = '‚ñ∂ Expand';
            }
        }

        const activationSelector = document.getElementById('activationSelector');
        activationSelector.addEventListener('click', (e) => {
            if (!e.target.classList.contains('activation-option')) return;
            const options = activationSelector.querySelectorAll('.activation-option');
            options.forEach(opt => opt.classList.remove('selected'));
            e.target.classList.add('selected');
            config.activation = e.target.dataset.act;
            backwardCache.actPrime = activationFns[config.activation].dfn;  // Update cached derivative
            updateUI();
        });

        // Optimizer buttons
        document.querySelectorAll('#optimizerButtons .opt-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#optimizerButtons .opt-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                
                // Update config
                config.optimizer = btn.dataset.opt;
                
                // Auto-adjust learning rate for optimizer
                // Adam works best with lower learning rates (0.001-0.01)
                // Simple SGD works with higher rates (0.01-0.1)
                const lrSlider = document.getElementById('learningRate');
                const lrValue = document.getElementById('learningRateValue');
                if (btn.dataset.opt === 'adam' && config.learningRate > 0.02) {
                    // Lower the learning rate for Adam
                    config.learningRate = 0.01;
                    lrSlider.value = Math.log10(0.01);
                    lrValue.textContent = '0.010';
                } else if (btn.dataset.opt === 'sgd' && config.learningRate < 0.05) {
                    // Raise the learning rate for SGD
                    config.learningRate = 0.1;
                    lrSlider.value = Math.log10(0.1);
                    lrValue.textContent = '0.100';
                }
                
                initializeOptimizerState();
                updateUI();
            });
        });

        const gifBtnEl = document.getElementById('gifBtn');
        // Set button label based on whether GIF capture is available
        gifBtnEl.textContent = canUseGifWorkers() ? 'Capture GIF' : 'Screenshot';
        gifBtnEl.title = canUseGifWorkers() 
            ? 'Record an animated GIF of training convergence' 
            : 'Save a PNG screenshot (run from web server for animated GIF)';
        gifBtnEl.addEventListener('click', () => {
            startGifCapture();
        });

        const saveRunABtn = document.getElementById('saveRunA');
        const saveRunBBtn = document.getElementById('saveRunB');
        const compareBtn = document.getElementById('compareBtn');
        
        saveRunABtn.addEventListener('click', () => saveRun('A'));
        saveRunBBtn.addEventListener('click', () => saveRun('B'));
        
        compareBtn.addEventListener('click', () => {
            if (savedRuns.A && savedRuns.B) {
                comparisonModeActive = !comparisonModeActive;
                // Toggle button appearance
                if (comparisonModeActive) {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#0056b3; color:white; border:1px solid #0056b3; cursor:pointer;';
                    compareBtn.textContent = '‚úì Comparing A vs B';
                } else {
                    compareBtn.style.cssText = 'font-size:11px; padding:4px 8px; margin-right:12px; background-color:#007bff; color:white; border:1px solid #007bff; cursor:pointer;';
                    compareBtn.textContent = 'Compare A vs B';
                }
                updateUI();
            }
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            trainingState.running = false;
            document.getElementById('runBtn').textContent = 'Run';
            exitComparisonMode();  // Exit comparison when stepping
            animatedStep();
        });

        document.getElementById('runBtn').addEventListener('click', () => {
            trainingState.running = !trainingState.running;
            const btn = document.getElementById('runBtn');
            btn.textContent = trainingState.running ? 'Pause' : 'Run';
            trainingState.lastUpdateTime = performance.now();
            if (trainingState.running) {
                exitComparisonMode();  // Exit comparison when running
                requestAnimationFrame(runLoop);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            document.getElementById('runBtn').textContent = 'Run';
            reset();
        });

        document.getElementById('traceLoss').addEventListener('change', updateUI);
        document.getElementById('traceAvgLoss').addEventListener('change', updateUI);
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        document.getElementById('traceLogScale').addEventListener('change', updateUI);
        
        // Loss surface controls
        const weightXSelect = document.getElementById('weightXSelect');
        const weightYSelect = document.getElementById('weightYSelect');
        
        // Auto mode for loss landscape (uses global lossLandscapeAutoMode)
        const weightSelectContainer = document.getElementById('weightSelectContainer');
        
        function setAutoMode(enabled) {
            lossLandscapeAutoMode = enabled;
            if (weightSelectContainer) weightSelectContainer.style.opacity = enabled ? '0.5' : '1';
            if (autoSelectBtn) {
                autoSelectBtn.style.background = enabled ? '#007bff' : '#6c757d';
                autoSelectBtn.style.borderColor = enabled ? '#007bff' : '#6c757d';
            }
        }
        
        if (weightXSelect && weightYSelect) {
            weightXSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[0] = parseInt(weightXSelect.value);
                lossSurfaceCache = null;  // Invalidate cache
                lossSurfaceOriginalGrid = null;
                lossSurfaceViewBounds = null;  // Reset view bounds
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
            weightYSelect.addEventListener('change', () => {
                setAutoMode(false);  // Exit auto mode on manual selection
                lossSurfaceWeightIndices[1] = parseInt(weightYSelect.value);
                lossSurfaceCache = null;
                lossSurfaceOriginalGrid = null;
                lossSurfaceViewBounds = null;  // Reset view bounds
                drawLossSurface();
                drawNetwork();  // Update highlight boxes
            });
        }
        
        const autoSelectBtn = document.getElementById('autoSelectBtn');
        if (autoSelectBtn) {
            autoSelectBtn.addEventListener('click', () => {
                setAutoMode(true);  // Re-enter auto mode
                autoSelectBtn.textContent = '...';
                setTimeout(() => {
                    autoSelectInterestingWeights();
                    computeLossSurface();
                    
                    // Set weights to random high-loss position, view to include both extremes
                    if (lossSurfaceCache && lossSurfaceCache.startPos && lossSurfaceCache.minLossPos) {
                        const startPos = lossSurfaceCache.startPos;
                        const minPos = lossSurfaceCache.minLossPos;
                        
                        setWeightByIndex(lossSurfaceWeightIndices[0], startPos.wx);
                        setWeightByIndex(lossSurfaceWeightIndices[1], startPos.wy);
                        lossSurfaceStartPosition = { x: startPos.wx, y: startPos.wy };
                        lossSurfaceTrail = [lossSurfaceStartPosition];
                        
                        // Start with FULL grid view (centered on origin)
                        const { minX: gridMinX, maxX: gridMaxX, minY: gridMinY, maxY: gridMaxY } = lossSurfaceCache;
                        lossSurfaceViewBounds = {
                            minX: gridMinX,
                            maxX: gridMaxX,
                            minY: gridMinY,
                            maxY: gridMaxY
                        };
                    }
                    
                    drawLossSurface();
                    drawNetwork();  // Update highlight boxes
                    autoSelectBtn.textContent = 'Auto';
                }, 10);
            });
        }
        
        // Rolling average window slider
        const avgWindowSlider = document.getElementById('avgWindowSlider');
        const avgWindowValue = document.getElementById('avgWindowValue');
        avgWindowSlider.addEventListener('input', () => {
            config.avgWindow = parseInt(avgWindowSlider.value);
            avgWindowValue.textContent = config.avgWindow;
            // Recalculate all rolling averages with new window size
            history.avgLoss = [];
            const minPointsForAvg = 10;
            for (let i = 0; i < history.loss.length; i++) {
                if (i + 1 < minPointsForAvg) {
                    history.avgLoss.push(null);  // Not enough points yet
                } else {
                    let sum = 0, count = 0;
                    for (let j = i; j >= 0 && count < config.avgWindow; j--, count++) {
                        sum += history.loss[j];
                    }
                    history.avgLoss.push(sum / Math.max(1, count));
                }
            }
            updateUI();
        });
        document.getElementById('traceWeights').addEventListener('change', updateUI);
        
        // Activation buttons in header - triggers full reset (changes loss surface)
        document.querySelectorAll('#activationButtons .act-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update button styling
                document.querySelectorAll('#activationButtons .act-btn').forEach(b => {
                    b.style.border = '2px solid #ccc';
                    b.style.background = '#fff';
                    b.style.color = '#333';
                    b.style.fontWeight = '500';
                });
                btn.style.border = '2px solid #007bff';
                btn.style.background = '#007bff';
                btn.style.color = 'white';
                btn.style.fontWeight = '600';
                
                // Update config
                config.activation = btn.dataset.act;
                backwardCache.actPrime = activationFns[config.activation].dfn;
                
                // Also update hidden selector for compatibility
                const options = document.querySelectorAll('#activationSelector .activation-option');
                options.forEach(opt => opt.classList.remove('selected'));
                document.querySelector(`#activationSelector .activation-option[data-act="${btn.dataset.act}"]`)?.classList.add('selected');
                
                // Activation changes the loss surface - need full reset
                resetModel();
            });
        });
        
        // OLD DRAG HANDLES - Now replaced by unified sliders
        // The drag handles are hidden but we keep setupDragHandle function for potential future use
        // All control is now done via the new sliders: layersSlider, widthSlider, trainMinSlider/trainMaxSlider, viewSlider
        
        // Update displays on init
        document.getElementById('networkLayersDisplay').textContent = network.numLayers;
        document.getElementById('networkSizeDisplay').textContent = network.hiddenSize;
        document.getElementById('xMinDisplay').textContent = config.xMin.toFixed(1);
        document.getElementById('xMaxDisplay').textContent = config.xMax.toFixed(1);
    }
    
    function setupDragHandle(elementId, direction, onDrag, getLimits) {
        const handle = document.getElementById(elementId);
        if (!handle) return;
        
        let startX, startY;
        let currentOffset = 0;
        let intervalId = null;
        const DEAD_ZONE = 10;  // pixels before triggering
        const INTERVAL_MS = 200;  // slower rate - 5 changes per second max
        const INCREMENT_PER_TICK = 15;  // pixels worth of change per tick
        
        const startInterval = () => {
            if (intervalId) return;
            intervalId = setInterval(() => {
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    // Check if we can move in this direction
                    const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                    const wantsIncrease = currentOffset > 0;
                    
                    // For vertical handles, up (negative offset) = increase
                    const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                    
                    if ((effectiveIncrease && limits.canIncrease) || (!effectiveIncrease && limits.canDecrease)) {
                        const sign = currentOffset > 0 ? 1 : -1;
                        onDrag(sign * INCREMENT_PER_TICK);
                    }
                }
            }, INTERVAL_MS);
        };
        
        const stopInterval = () => {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }
        };
        
        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            currentOffset = 0;
            
            // Disable transition during drag for immediate feedback
            handle.style.transition = 'none';
            
            const onMouseMove = (e) => {
                const rawOffset = direction === 'horizontal' ? (e.clientX - startX) : (e.clientY - startY);
                
                // Check limits and prevent visual displacement in blocked direction
                const limits = getLimits ? getLimits() : { canDecrease: true, canIncrease: true };
                const wantsIncrease = rawOffset > 0;
                const effectiveIncrease = direction === 'vertical' ? !wantsIncrease : wantsIncrease;
                
                // Block displacement if at limit
                if (effectiveIncrease && !limits.canIncrease) {
                    currentOffset = direction === 'vertical' ? Math.max(0, rawOffset) : Math.min(0, rawOffset);
                } else if (!effectiveIncrease && !limits.canDecrease) {
                    currentOffset = direction === 'vertical' ? Math.min(0, rawOffset) : Math.max(0, rawOffset);
                } else {
                    currentOffset = rawOffset;
                }
                
                // Clamp visual offset to reasonable range (¬±20px)
                const clampedOffset = Math.max(-20, Math.min(20, currentOffset));
                
                // Visual feedback - move the handle
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = `translateX(calc(-50% + ${clampedOffset}px))`;
                    } else {
                        handle.style.transform = `translateX(${clampedOffset}px)`;
                    }
                } else {
                    handle.style.transform = `translateY(calc(-50% + ${clampedOffset}px))`;
                }
                
                // Start interval if displaced beyond dead zone
                if (Math.abs(currentOffset) > DEAD_ZONE) {
                    startInterval();
                } else {
                    stopInterval();
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                stopInterval();
                
                // Re-enable transition for rubberband effect
                handle.style.transition = 'transform 0.15s ease-out';
                
                // Rubberband back to original position
                if (direction === 'horizontal') {
                    if (elementId === 'layersHandle') {
                        handle.style.transform = 'translateX(-50%)';
                    } else {
                        handle.style.transform = 'translateX(0)';
                    }
                } else {
                    handle.style.transform = 'translateY(-50%)';
                }
                
                currentOffset = 0;
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    }

    // --------------- Init ----------------------------

    function init() {
        try {
            console.log('LearnCurve: initializing...');
            compileTargetFunc();
            initializeNetwork();
            setupControls();
            populateWeightSelectors();
            
            // Don't compute loss surface on startup - wait for training data to be generated
            // This saves significant computation time on page load
            console.log('LearnCurve: skipping loss surface (will compute after data generation)');
            autoSelectInterestingWeights();
            
            console.log('LearnCurve: setup complete, drawing initial UI...');
            
            // Draw all charts immediately (don't wait for requestAnimationFrame)
            try {
                console.log('LearnCurve: drawing all charts...');
                drawNetwork();
                drawFitPlot();
                drawTrainingTrace();
                drawLossSurface();
                updateEquations();
                
                // Update phase UI at the end
                updatePhaseUI();
                updateUI();
                
                console.log('LearnCurve: initialization complete');
            } catch(e) {
                console.error('Initial draw error:', e);
            }
        } catch(e) {
            console.error('Init error:', e);
        }
    }

    // Run init immediately since script is at end of body
    console.log('LearnCurve: starting init...');
    init();
</script>
</body>
</html>

